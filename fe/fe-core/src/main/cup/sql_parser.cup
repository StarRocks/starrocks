// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package com.starrocks.analysis;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.starrocks.sql.ast.PartitionNames;
import com.starrocks.catalog.AccessPrivilege;
import com.starrocks.catalog.AggregateType;
import com.starrocks.catalog.ArrayType;
import com.starrocks.catalog.KeysType;
import com.starrocks.catalog.PrimitiveType;
import com.starrocks.catalog.ScalarType;
import com.starrocks.catalog.Type;
import com.starrocks.catalog.View;
import com.starrocks.common.AnalysisException;
import com.starrocks.common.Version;
import com.starrocks.mysql.MysqlPassword;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

import java_cup.runtime.Symbol;

// Commented by Zhao Chun
// Now we have 2 shift/reduce conflict
// between TIMESTAMP "20100101" and TIMESTAMP "alias"
// between DATE "20100101" and DATE "alias"

parser code {:
    private Symbol errorToken;
    public boolean isVerbose = false;
    public String wild;
    public Expr where;

    // List of expected tokens ids from current parsing state for generating syntax error message
    private final List<Integer> expectedTokenIds = Lists.newArrayList();

    // To avoid reporting trivial tokens as expected tokens in error messages
    private boolean reportExpectedToken(Integer tokenId) {
        if (SqlScanner.isKeyword(tokenId) ||
                tokenId.intValue() == SqlParserSymbols.COMMA ||
                tokenId.intValue() == SqlParserSymbols.IDENT) {
            return true;
        } else {
            return false;
        }
    }

    private String getErrorTypeMessage(int lastTokenId) {
        String msg = null;
        switch(lastTokenId) {
            case SqlParserSymbols.UNMATCHED_STRING_LITERAL:
                msg = "Unmatched string literal";
                break;
            case SqlParserSymbols.NUMERIC_OVERFLOW:
                msg = "Numeric overflow";
                break;
            default:
                msg = "Syntax error";
                break;
        }
        return msg;
    }

    // Override to save error token, just update error information.
    @Override
    public void syntax_error(Symbol token) {
        errorToken = token;

        // derive expected tokens from current parsing state
        expectedTokenIds.clear();
        int state = ((Symbol)stack.peek()).parse_state;
        // get row of actions table corresponding to current parsing state
        // the row consists of pairs of <tokenId, actionId>
        // a pair is stored as row[i] (tokenId) and row[i+1] (actionId)
        // the last pair is a special error action
        short[] row = action_tab[state];
        short tokenId;
        // the expected tokens are all the symbols with a
        // corresponding action from the current parsing state
        for (int i = 0; i < row.length-2; ++i) {
            // Get tokenId and skip actionId
            tokenId = row[i++];
            expectedTokenIds.add(Integer.valueOf(tokenId));
        }
    }

    // Override to keep it from calling report_fatal_error()
    // This exception is not AnalysisException because we don't want this report to client.
    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws AnalysisException {
        throw new AnalysisException(getErrorTypeMessage(cur_token.sym));
    }


    // Manually throw a parse error on a given symbol for special circumstances.
    public void parseError(String symbolName, int symbolId) throws AnalysisException {
        Symbol errorToken = getSymbolFactory().newSymbol(symbolName, symbolId,
                ((Symbol) stack.peek()), ((Symbol) stack.peek()), null);
        // Call syntax error to gather information about expected tokens, etc.
        // syntax_error does not throw an exception
        syntax_error(errorToken);

        unrecovered_syntax_error(errorToken);
    }

    // Returns error string, consisting of the original
    // stmt with a '^' under the offending token. Assumes
    // that parse() has been called and threw an exception
    public String getErrorMsg(String stmt) {
        if (errorToken == null || stmt == null) {
            return null;
        }
        String[] lines = stmt.split("\n", -1);
        StringBuffer result = new StringBuffer();
        result.append(getErrorTypeMessage(errorToken.sym) + " in line ");
        result.append(errorToken.left);
        result.append(":\n");

        // errorToken_.left is the line number of error.
        // errorToken_.right is the column number of the error.
        // index is start from 0, so "minus 1" is the real error line idx
        String errorLine = lines[errorToken.left - 1];
        // If the error is that additional tokens are expected past the end,
        // errorToken_.right will be past the end of the string.
        int lastCharIndex = Math.min(errorLine.length(), errorToken.right);
        int maxPrintLength = 60;
        int errorLoc = 0;
        if (errorLine.length() <= maxPrintLength) {
            // The line is short. Print the entire line.
            result.append(errorLine);
            result.append('\n');
            errorLoc = errorToken.right;
        } else {
            // The line is too long. Print maxPrintLength/2 characters before the error and
            // after the error.
            int contextLength = maxPrintLength / 2 - 3;
            String leftSubStr;
            if (errorToken.right > maxPrintLength / 2) {
                leftSubStr = "..." + errorLine.substring(errorToken.right - contextLength,
                        lastCharIndex);
            } else {
                leftSubStr = errorLine.substring(0, errorToken.right);
            }
            errorLoc = leftSubStr.length();
            result.append(leftSubStr);
            if (errorLine.length() - errorToken.right > maxPrintLength / 2) {
                result.append(errorLine.substring(errorToken.right,
                            errorToken.right + contextLength) + "...");
            } else {
                result.append(errorLine.substring(lastCharIndex));
            }
            result.append("\n");
        }

        // print error indicator
        for (int i = 0; i < errorLoc - 1; ++i) {
            result.append(' ');
        }
        result.append("^\n");

        // only report encountered and expected tokens for syntax errors
        if (errorToken.sym == SqlParserSymbols.UNMATCHED_STRING_LITERAL ||
                errorToken.sym == SqlParserSymbols.NUMERIC_OVERFLOW) {
            return result.toString();
        }

        // append last encountered token
        result.append("Encountered: ");
        String lastToken = SqlScanner.tokenIdMap.get(Integer.valueOf(errorToken.sym));
        if (lastToken != null) {
            result.append(lastToken);
        } else if (SqlScanner.isKeyword((String) errorToken.value)) {
            result.append("A reserved word cannot be used as an identifier: ").append((String) errorToken.value);
        } else {
            result.append("Unknown last token with id: " + errorToken.sym);
        }

        // Append expected tokens
        result.append('\n');
        result.append("Expected: ");
        String expectedToken = null;
        Integer tokenId = null;
        for (int i = 0; i < expectedTokenIds.size(); ++i) {
            tokenId = expectedTokenIds.get(i);
            // keywords hints
            if (SqlScanner.isKeyword(lastToken) && tokenId.intValue() == SqlParserSymbols.IDENT) {
                result.append(String.format("%s is keyword, maybe `%s`", lastToken, lastToken) + ", ");
                continue;
            }

            if (reportExpectedToken(tokenId)) {
                expectedToken = SqlScanner.tokenIdMap.get(tokenId);
                result.append(expectedToken + ", ");
            }
        }
        // remove trailing ", "
        result.delete(result.length() - 2, result.length());
        result.append('\n');

        return result.toString();
    }

:};

// Total keywords of starrocks
terminal String KW_ADD, KW_AFTER, KW_AGGREGATE, KW_ALL, KW_ALTER, KW_AND, KW_ARRAY, KW_AS, KW_ASC, KW_AUTHORS,
    KW_BACKEND, KW_BACKUP, KW_BETWEEN, KW_BEGIN, KW_BIGINT, KW_BITMAP, KW_BITMAP_UNION, KW_BOOLEAN, KW_BROKER, KW_BACKENDS, KW_BY, KW_BUILTIN,
    KW_CANCEL, KW_CASE, KW_CAST, KW_CHAIN, KW_CHAR, KW_CHARSET, KW_CHECK, KW_CLUSTER, KW_CLUSTERS,
    KW_COLLATE, KW_COLLATION, KW_COLUMNS, KW_COMMENT, KW_COMMIT, KW_COMMITTED,
    KW_CONFIG, KW_CONNECTION, KW_CONNECTION_ID, KW_CONSISTENT, KW_COUNT, KW_CREATE, KW_CURRENT, KW_CURRENT_TIMESTAMP, KW_CURRENT_USER,
    KW_DATA, KW_DATABASE, KW_DATE, KW_DATETIME, KW_DAY, KW_DECIMAL, KW_DECIMALV2, KW_DECIMAL32, KW_DECIMAL64, KW_DECIMAL128, KW_DECOMMISSION, KW_DEFAULT, KW_DESC,
    KW_DELETE, KW_DISTINCT, KW_DISTINCTPC, KW_DISTINCTPCSA, KW_DYNAMIC, KW_BUCKETS, KW_DIV, KW_DOUBLE, KW_DROP,
    KW_ELSE, KW_END, KW_ENGINE, KW_ENGINES, KW_ERRORS, KW_EVENTS, KW_EXISTS, KW_EXPORT,
    KW_EXTERNAL, KW_EXTRACT,
    KW_FALSE, KW_FOLLOWING, KW_FREE, KW_FROM, KW_FILE, KW_FIRST, KW_FLOAT, KW_FOR, KW_FORMAT, KW_FN, KW_FUNCTION,
    KW_GLOBAL, KW_GRANT, KW_GRANTS, KW_GROUPING,
    KW_HASH, KW_HELP,KW_HLL, KW_HLL_UNION, KW_HOUR, KW_HUB,
    KW_IDENTIFIED, KW_IF, KW_IN, KW_INDEXES, KW_INSTALL,
    KW_INT, KW_SIGNED, KW_INTERVAL, KW_IS, KW_ISNULL, KW_ISOLATION,
    KW_JSON,
    KW_LABEL, KW_LARGEINT, KW_LAST, KW_LEFT, KW_LESS, KW_LEVEL, KW_LIKE, KW_LIMIT, KW_LINK, KW_LIST, KW_LOAD,
    KW_LOCAL, KW_LOCATION, KW_LOGICAL,
    KW_MAX, KW_MERGE, KW_MIN, KW_MINUTE, KW_MODIFY, KW_MONTH,
    KW_NAME, KW_NAMES, KW_NEGATIVE, KW_NO, KW_NOT, KW_NULL, KW_NULLS,
    KW_OFFSET, KW_ON, KW_ONLY, KW_OPEN, KW_OR, KW_ORDER, KW_OVER,
    KW_PARTITION, KW_PARTITIONS, KW_PASSWORD, KW_PATH, KW_PAUSE, KW_PIPE, KW_PRECEDING,
    KW_PLUGIN, KW_PLUGINS,
    KW_PROC, KW_PROPERTIES, KW_PROPERTY, KW_PERCENTILE, KW_PERCENTILE_UNION,
    KW_QUERY, KW_QUOTA,
    KW_RANGE, KW_READ, KW_RECOVER, KW_REGEXP, KW_RELEASE,
    KW_REPEATABLE, KW_REPOSITORY, KW_REPOSITORIES, KW_REPLACE, KW_REPLACE_IF_NOT_NULL, KW_RESOURCE, KW_RESOURCES, KW_RESTORE, KW_RETURNS, KW_RESUME, KW_REVOKE,
    KW_RIGHT, KW_ROLE, KW_ROLES, KW_ROLLBACK, KW_ROLLUP, KW_ROUTINE, KW_ROW, KW_ROWS,
    KW_SCHEMA, KW_SECOND, KW_SERIALIZABLE, KW_SESSION, KW_SET, KW_SHOW,
    KW_SMALLINT, KW_SNAPSHOT, KW_SONAME, KW_SPLIT, KW_START, KW_STATUS, KW_STOP, KW_STORAGE, KW_STRING,
    KW_SUM, KW_SUPERUSER,
    KW_TABLE, KW_TABLES, KW_TABLET, KW_TASK, KW_TEMPORARY, KW_TERMINATED, KW_THAN, KW_TIME, KW_THEN, KW_TIMESTAMP, KW_TINYINT,
    KW_TO, KW_TRANSACTION, KW_TRIGGERS, KW_TRIM, KW_TRUE, KW_TRUNCATE, KW_TYPE, KW_TYPES,
    KW_UNCOMMITTED, KW_UNBOUNDED, KW_USER, KW_UNINSTALL,
    KW_VALUE, KW_VARCHAR, KW_VARIABLES, KW_VERBOSE, KW_VIEW,
    KW_WARNINGS, KW_WEEK, KW_WHEN, KW_SQLBLACKLIST, KW_WHITELIST, KW_WHERE, KW_WITH, KW_WORK, KW_WRITE,
    KW_YEAR;

terminal COMMA, DOT, AT, STAR, LPAREN, RPAREN, COLON, SEMICOLON, LBRACE, RBRACE, LBRACKET, RBRACKET, DIVIDE, MOD, ADD, SUBTRACT;
terminal BITAND, BITOR, BITXOR, BITNOT;
terminal EQUAL, NOT, LESSTHAN, GREATERTHAN, SET_VAR;
terminal COMMENTED_PLAN_HINT_START, COMMENTED_PLAN_HINT_END;
terminal ARROW;
terminal String IDENT;
terminal String NUMERIC_OVERFLOW;
terminal Long INTEGER_LITERAL;
terminal String LARGE_INTEGER_LITERAL;
terminal Double FLOATINGPOINT_LITERAL;
terminal BigDecimal DECIMAL_LITERAL;
terminal String STRING_LITERAL;
terminal String UNMATCHED_STRING_LITERAL;

// Statement that the result of this parser.
nonterminal List<StatementBase> stmts;
nonterminal StatementBase stmt, show_stmt, show_param, help_stmt, create_routine_load_stmt, pause_routine_load_stmt, resume_routine_load_stmt, stop_routine_load_stmt,
    show_routine_load_stmt, show_routine_load_task_stmt, alter_stmt,
    drop_stmt, grant_stmt, revoke_stmt, create_stmt, set_stmt, cancel_stmt, cancel_param, delete_stmt,
    unsupported_stmt, export_stmt,
    import_columns_stmt, import_where_stmt, install_plugin_stmt, uninstall_plugin_stmt;

nonterminal ImportColumnDesc import_column_desc;
nonterminal List<ImportColumnDesc> import_column_descs;

// unsupported statement
nonterminal opt_with_consistent_snapshot, opt_work, opt_chain, opt_release;

// No return.
nonterminal from_or_in, opt_wild_where,
            charset, equal, transaction_characteristics, isolation_level,
            transaction_access_mode, isolation_types;

// String
nonterminal UserIdentity user_identity;

// Description of user
nonterminal UserDesc grant_user;

nonterminal BackupStmt backup_stmt;
nonterminal RestoreStmt restore_stmt;

nonterminal Expr expr, non_pred_expr, arithmetic_expr, timestamp_arithmetic_expr;
nonterminal Expr array_expr, array_subscript, array_slice;
nonterminal Expr set_expr_or_default;
nonterminal Expr arrow_expr;
nonterminal ArrayList<Expr> expr_list;
nonterminal ArrayList<Expr> func_arg_list;
nonterminal ArrayList<Expr> expr_pipe_list;
nonterminal String opt_table_alias;
nonterminal ArrayList<String> ident_list;
nonterminal PartitionNames opt_partition_names, partition_names;
nonterminal ArrayList<Long> opt_tablet_list, tablet_list;
nonterminal TableName table_name;
nonterminal FunctionName function_name;
nonterminal Expr where_clause;
nonterminal Predicate predicate, between_predicate, comparison_predicate,
  compound_predicate, in_predicate, like_predicate, exists_predicate;
nonterminal ArrayList<Expr> opt_partition_by_clause;
nonterminal ArrayList<OrderByElement> order_by_elements, order_by_clause;
nonterminal OrderByElement order_by_element;
nonterminal Boolean opt_order_param;
nonterminal Boolean opt_nulls_order_param;
nonterminal LimitElement limit_clause;
nonterminal TypeDef type_def;
nonterminal Type type, array_def;
nonterminal Expr cast_expr, case_else_clause, analytic_expr;
nonterminal LiteralExpr literal;
nonterminal CaseExpr case_expr;
nonterminal ArrayList<CaseWhenClause> case_when_clause_list;
nonterminal FunctionParams function_params;
nonterminal Expr function_call_expr;
nonterminal AnalyticWindow opt_window_clause;
nonterminal AnalyticWindow.Type window_type;
nonterminal AnalyticWindow.Boundary window_boundary;
nonterminal SlotRef column_ref;
nonterminal TableRef base_table_ref;
nonterminal Subquery subquery;
nonterminal Expr sign_chain_expr;
nonterminal ArrayList<String> opt_common_hints;

// Set type
nonterminal SetType option_type, var_ident_type;

// Set variable
nonterminal SetVar option_value, option_value_follow_option_type, option_value_no_option_type;

// List of set variable
nonterminal List<SetVar> option_value_list, option_value_list_continued, start_option_value_list,
        start_option_value_list_following_option_type;

nonterminal Map<String, String> key_value_map, opt_properties;
nonterminal Long opt_field_length;

nonterminal List<AccessPrivilege> privilege_list;
nonterminal List<String> string_list;
nonterminal List<Long> integer_list;
nonterminal AccessPrivilege privilege_type;

nonterminal LabelName job_label;
nonterminal BrokerDesc opt_broker;
nonterminal List<String> opt_col_list;
nonterminal ColumnSeparator column_separator;
nonterminal RowDelimiter row_delimiter;
nonterminal String opt_user_role;
nonterminal TablePattern tbl_pattern;
nonterminal ResourcePattern resource_pattern;
nonterminal String ident_or_star;

// Routine load
nonterminal ParseNode load_property;
nonterminal List<ParseNode> opt_load_property_list;

// Boolean
nonterminal Boolean opt_read_only;

nonterminal String keyword, ident, ident_or_text, variable_name, text_or_password,
        charset_name_or_default, old_or_new_charset_name_or_default, opt_collate,
        collation_name_or_default, type_func_name_keyword, type_function_name, time_unit;

nonterminal String opt_db;
nonterminal Boolean opt_if_not_exists;

nonterminal RoutineLoadDataSourceProperties opt_datasource_properties;

precedence nonassoc COMMA;
precedence nonassoc STRING_LITERAL;
precedence nonassoc KW_COLUMNS;
precedence nonassoc KW_WITH;

precedence left KW_MERGE;
precedence left DOT;
precedence left SET_VAR;
precedence left KW_OR;
precedence left KW_AND;
precedence left KW_NOT, NOT;
precedence left KW_BETWEEN, KW_IN, KW_IS, KW_EXISTS;
precedence left KW_LIKE, KW_REGEXP;
precedence left EQUAL, LESSTHAN, GREATERTHAN;
precedence left ADD, SUBTRACT;
precedence left AT, STAR, DIVIDE, MOD, KW_DIV;
precedence left BITAND, BITOR, BITXOR;
precedence left KW_PIPE;
precedence left BITNOT;
precedence left KW_ORDER, KW_BY, KW_LIMIT;
precedence left ARROW;
precedence right KW_PROPERTIES;
precedence left LPAREN, RPAREN;
// Support chaining of timestamp arithmetic exprs.
precedence left KW_INTERVAL;
precedence left KW_OVER;
precedence left KW_COLLATE;
precedence left KW_PARTITION;
precedence left KW_PARTITIONS;
precedence right KW_TEMPORARY;
precedence right LBRACKET;
// fix conflict in create table function
// http://tryitnw.blogspot.com/2012/02/tip-avoiding-shiftreduce-conflict.html
precedence left KW_FUNCTION;

start with stmts;

stmts ::=
    stmt:stmt
    {:
        RESULT = Lists.newArrayList(stmt);
    :}
    | stmts:stmts SEMICOLON stmt:stmt
    {:
        stmts.add(stmt);
        RESULT = stmts;
    :}
    | import_columns_stmt:stmt
    {:
        RESULT = Lists.newArrayList(stmt);
    :}
    | import_where_stmt:stmt
    {:
        RESULT = Lists.newArrayList(stmt);
    :}
    ;

import_columns_stmt ::=
    KW_COLUMNS LPAREN import_column_descs:columns RPAREN
    {:
        RESULT = new ImportColumnsStmt(columns);
    :}
    ;

import_column_descs ::=
    import_column_desc:column
    {:
        RESULT = Lists.newArrayList(column);
    :}
    | import_column_descs:columns COMMA import_column_desc:column
    {:
        columns.add(column);
        RESULT = columns;
    :}
    ;

import_column_desc ::=
    ident:name
    {:
        RESULT = new ImportColumnDesc(name, null);
    :}
    | ident:name EQUAL expr:expr
    {:
        RESULT = new ImportColumnDesc(name, expr);
    :}
    ;

import_where_stmt ::=
    KW_WHERE expr:expr
    {:
        RESULT = new ImportWhereStmt(expr);
    :}
    ;

stmt ::=
     alter_stmt:stmt
    {: RESULT = stmt; :}
    | create_stmt:query
    {: RESULT = query; :}
    | drop_stmt:stmt
    {: RESULT = stmt; :}
    | set_stmt:set
    {: RESULT = set; :}
    | KW_ADD KW_SQLBLACKLIST STRING_LITERAL:sql
    {: RESULT = new AddSqlBlackListStmt(sql); :}
    | show_stmt:show
    {: RESULT = show; :}
    | grant_stmt:grant
    {: RESULT = grant; :}
    | revoke_stmt:revoke
    {: RESULT = revoke; :}
    | help_stmt : stmt
    {: RESULT = stmt; :}
    | create_routine_load_stmt : stmt
    {: RESULT = stmt; :}
    | pause_routine_load_stmt : stmt
    {: RESULT = stmt; :}
    | resume_routine_load_stmt : stmt
    {: RESULT = stmt; :}
    | stop_routine_load_stmt : stmt
    {: RESULT = stmt; :}
    | show_routine_load_stmt : stmt
    {: RESULT = stmt; :}
    | show_routine_load_task_stmt : stmt
    {: RESULT = stmt; :}
    | cancel_stmt : stmt
    {: RESULT = stmt; :}
    | delete_stmt : stmt
    {: RESULT = stmt; :}
    | backup_stmt : stmt
    {: RESULT = stmt; :}
	| restore_stmt : stmt
    {: RESULT = stmt; :}
    | unsupported_stmt : stmt
    {: RESULT = stmt; :}
    | export_stmt : stmt
    {: RESULT = stmt; :}
    | install_plugin_stmt : stmt
    {: RESULT = stmt; :}
    | uninstall_plugin_stmt : stmt
    {: RESULT = stmt; :}
    | /* empty: query only has comments */
    {:
        RESULT = new EmptyStmt();
    :}
    ;

// plugin statement
install_plugin_stmt ::=
    KW_INSTALL KW_PLUGIN KW_FROM ident_or_text:source opt_properties:properties
    {:
        RESULT = new InstallPluginStmt(source, properties);
    :}
    ;

uninstall_plugin_stmt ::=
    KW_UNINSTALL KW_PLUGIN ident_or_text:name
    {:
        RESULT = new UninstallPluginStmt(name);
    :}
    ;

// Alter Statement
alter_stmt ::=
     KW_ALTER KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel
      opt_load_property_list:loadPropertyList
      opt_properties:jobProperties
      opt_datasource_properties:datasourceProperties
    {:
        RESULT = new AlterRoutineLoadStmt(jobLabel, loadPropertyList, jobProperties, datasourceProperties);
    :}
    ;

opt_datasource_properties ::=
    // empty
    {:
        RESULT = new RoutineLoadDataSourceProperties();
    :}
    | KW_FROM ident:type LPAREN key_value_map:customProperties RPAREN
    {:
        RESULT = new RoutineLoadDataSourceProperties(type, customProperties);
    :}
    ;

// Create Statement
create_stmt ::=
    /* User */
    KW_CREATE KW_USER opt_if_not_exists:ifNotExists grant_user:user opt_user_role:userRole
    {:
        RESULT = new CreateUserStmt(ifNotExists, user, userRole);
    :}
    | KW_CREATE KW_ROLE ident_or_text:role
    {:
        RESULT = new CreateRoleStmt(role);
    :}
    | KW_CREATE KW_FILE STRING_LITERAL:fileName opt_db:db KW_PROPERTIES LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new CreateFileStmt(fileName, db, properties);
    :}
    ;

opt_read_only ::=
    {:
        RESULT = false;
    :}
    | KW_READ KW_ONLY
    {:
        RESULT = true;
    :}
    ;

grant_user ::=
    user_identity:user_id
    {:
        /* No password */
        RESULT = new UserDesc(user_id);
    :}
    | user_identity:user_id KW_IDENTIFIED KW_BY STRING_LITERAL:password
    {:
        /* plain text password */
        RESULT = new UserDesc(user_id, password, true);
    :}
    | user_identity:user_id KW_IDENTIFIED KW_BY KW_PASSWORD STRING_LITERAL:password
    {:
        /* hashed password */
        RESULT = new UserDesc(user_id, password, false);
    :}
    | user_identity:user_id KW_IDENTIFIED KW_WITH IDENT:auth_plugin
    {:
        /* with auth plugin */
        RESULT = new UserDesc(user_id, auth_plugin);
    :}
    | user_identity:user_id KW_IDENTIFIED KW_WITH IDENT:auth_plugin KW_AS STRING_LITERAL:auth_string
    {:
        /* with auth plugin and auth string, encrypted if auth string is password */
        RESULT = new UserDesc(user_id, auth_plugin, auth_string, false);
    :}
    | user_identity:user_id KW_IDENTIFIED KW_WITH IDENT:auth_plugin KW_BY STRING_LITERAL:auth_string
    {:
        /* with auth plugin and auth string, plain text if auth string is password */
        RESULT = new UserDesc(user_id, auth_plugin, auth_string, true);
    :}
    ;

opt_user_role ::=
    /* Empty */
    {:
        RESULT = null;
    :}
    | KW_SUPERUSER /* for forward compatibility*/
    {:
        RESULT = "superuser";
    :}
    | KW_DEFAULT KW_ROLE STRING_LITERAL:role
    {:
        RESULT = role;
    :}
    ;

user_identity ::=
    ident_or_text:user
    {:
        RESULT = new UserIdentity(user, "%", false);
    :}
    | ident_or_text:user AT ident_or_text:host
    {:
        RESULT = new UserIdentity(user, host, false);
    :}
    | ident_or_text:user AT LBRACKET ident_or_text:host RBRACKET
    {:
        RESULT = new UserIdentity(user, host, true);
    :}
    ;

// Help statement
help_stmt ::=
    KW_HELP ident_or_text:mark
    {:
        RESULT = new HelpStmt(mark);
    :}
    ;

// Export statement
export_stmt ::=
    KW_EXPORT KW_TABLE base_table_ref:tblRef opt_col_list:cols
    KW_TO STRING_LITERAL:path
    opt_properties:properties
    opt_broker:broker
    {:
        RESULT = new ExportStmt(tblRef, cols, path, properties, broker);
    :}
    ;

job_label ::=
    ident:label
    {:
        RESULT = new LabelName("", label);
    :}
    | ident:db DOT ident:label
    {:
        RESULT = new LabelName(db, label);
    :}
    ;

column_separator ::=
    KW_COLUMNS KW_TERMINATED KW_BY STRING_LITERAL:sep
    {:
        RESULT = new ColumnSeparator(sep);
    :}
    ;

row_delimiter::=
    KW_ROWS KW_TERMINATED KW_BY STRING_LITERAL:delimiter
    {:
        RESULT = new RowDelimiter(delimiter);
    :}
    ;

opt_col_list ::=
    {:
        RESULT = null;
    :}
    | LPAREN ident_list:colList RPAREN
    {:
        RESULT = colList;
    :}
    ;

opt_broker ::=
    {:
        RESULT = null;
    :}
    | KW_WITH KW_BROKER
    {:
        RESULT = new BrokerDesc(null);
    :}
    | KW_WITH KW_BROKER LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new BrokerDesc(properties);
    :}
    | KW_WITH KW_BROKER ident_or_text:name
    {:
        RESULT = new BrokerDesc(name, null);
    :}
    | KW_WITH KW_BROKER ident_or_text:name LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new BrokerDesc(name, properties);
    :}
    ;

// Routine load statement
create_routine_load_stmt ::=
    KW_CREATE KW_ROUTINE KW_LOAD job_label:jobLabel KW_ON ident:tableName
    opt_load_property_list:loadPropertyList
    opt_properties:properties
    KW_FROM ident:type LPAREN key_value_map:customProperties RPAREN
    {:
        RESULT = new CreateRoutineLoadStmt(jobLabel, tableName, loadPropertyList, properties, type, customProperties);
    :}
    ;

opt_load_property_list ::=
    {:
        RESULT = null;
    :}
    | load_property:loadProperty
    {:
        RESULT = Lists.newArrayList(loadProperty);
    :}
    | opt_load_property_list:list COMMA load_property:loadProperty
    {:
        list.add(loadProperty);
        RESULT = list;
    :}
    ;

load_property ::=
    column_separator:colSep
    {:
        RESULT = colSep;
    :}
    | row_delimiter:rowDelimiter
    {:
        RESULT = rowDelimiter;
    :}
    | import_columns_stmt:columnsInfo
    {:
        RESULT = columnsInfo;
    :}
    | import_where_stmt:wherePredicate
    {:
        RESULT = wherePredicate;
    :}
    | partition_names:partitionNames
    {:
        RESULT = partitionNames;
    :}
    ;

pause_routine_load_stmt ::=
    KW_PAUSE KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel
    {:
        RESULT = new PauseRoutineLoadStmt(jobLabel);
    :}
    ;

resume_routine_load_stmt ::=
    KW_RESUME KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel
    {:
        RESULT = new ResumeRoutineLoadStmt(jobLabel);
    :}
    ;

stop_routine_load_stmt ::=
    KW_STOP KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel
    {:
        RESULT = new StopRoutineLoadStmt(jobLabel);
    :}
    ;

show_routine_load_stmt ::=
    KW_SHOW KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel
    {:
        RESULT = new ShowRoutineLoadStmt(jobLabel, false);
    :}
    | KW_SHOW KW_ALL KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel
    {:
        RESULT = new ShowRoutineLoadStmt(jobLabel, true);
    :}
    | KW_SHOW KW_ROUTINE KW_LOAD opt_db:dbName opt_wild_where order_by_clause:orderByClause limit_clause:limitClause
    {:
        RESULT = new ShowRoutineLoadStmt(new LabelName(dbName, null), false, parser.where, orderByClause, limitClause);
    :}
    | KW_SHOW KW_ALL KW_ROUTINE KW_LOAD opt_db:dbName opt_wild_where order_by_clause:orderByClause limit_clause:limitClause
    {:
        RESULT = new ShowRoutineLoadStmt(new LabelName(dbName, null), true, parser.where, orderByClause, limitClause);
    :}
    ;

show_routine_load_task_stmt ::=
    KW_SHOW KW_ROUTINE KW_LOAD KW_TASK opt_db:dbName opt_wild_where
    {:
        RESULT = new ShowRoutineLoadTaskStmt(dbName, parser.where);
    :}
    ;

// Grant statement
grant_stmt ::=
    KW_GRANT privilege_list:privs KW_ON tbl_pattern:tblPattern KW_TO user_identity:userId
    {:
        RESULT = new GrantStmt(userId, null, tblPattern, privs);
    :}
    | KW_GRANT privilege_list:privs KW_ON tbl_pattern:tblPattern KW_TO KW_ROLE STRING_LITERAL:role
    {:
        RESULT = new GrantStmt(null, role, tblPattern, privs);
    :}
    | KW_GRANT privilege_list:privs KW_ON KW_RESOURCE resource_pattern:resourcePattern KW_TO user_identity:userId
    {:
        RESULT = new GrantStmt(userId, null, resourcePattern, privs);
    :}
    | KW_GRANT privilege_list:privs KW_ON KW_RESOURCE resource_pattern:resourcePattern KW_TO KW_ROLE STRING_LITERAL:role
    {:
        RESULT = new GrantStmt(null, role, resourcePattern, privs);
    :}
    ;

tbl_pattern ::=
    ident_or_star:db
    {:
        RESULT = new TablePattern(db, "*");
    :}
    | ident_or_star:db DOT ident_or_star:tbl
    {:
        RESULT = new TablePattern(db, tbl);
    :}
    ;

resource_pattern ::=
    ident_or_star:resourceName
    {:
        RESULT = new ResourcePattern(resourceName);
    :}
    | STRING_LITERAL:resourceName
    {:
        RESULT = new ResourcePattern(resourceName);
    :}
    ;

ident_or_star ::=
    STAR
    {:
        RESULT = "*";
    :}
    | ident:ident
    {:
        RESULT = ident;
    :}
    ;

// Revoke statement
revoke_stmt ::=
    KW_REVOKE privilege_list:privs KW_ON tbl_pattern:tblPattern KW_FROM user_identity:userId
    {:
        RESULT = new RevokeStmt(userId, null, tblPattern, privs);
    :}
    | KW_REVOKE privilege_list:privs KW_ON tbl_pattern:tblPattern KW_FROM KW_ROLE STRING_LITERAL:role
    {:
        RESULT = new RevokeStmt(null, role, tblPattern, privs);
    :}
    | KW_REVOKE privilege_list:privs KW_ON KW_RESOURCE resource_pattern:resourcePattern KW_FROM user_identity:userId
    {:
        RESULT = new RevokeStmt(userId, null, resourcePattern, privs);
    :}
    | KW_REVOKE privilege_list:privs KW_ON KW_RESOURCE resource_pattern:resourcePattern KW_FROM KW_ROLE STRING_LITERAL:role
    {:
        RESULT = new RevokeStmt(null, role, resourcePattern, privs);
    :}
    ;

// Drop statement
drop_stmt ::=
    /* User */
    KW_DROP KW_USER user_identity:userId
    {:
        RESULT = new DropUserStmt(userId);
    :}
    | KW_DROP KW_REPOSITORY ident:repoName
    {:
        RESULT = new DropRepositoryStmt(repoName);
    :}
    | KW_DROP KW_ROLE ident_or_text:role
    {:
        RESULT = new DropRoleStmt(role);
    :}
    | KW_DROP KW_FILE STRING_LITERAL:fileName opt_db:dbName KW_PROPERTIES LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new DropFileStmt(fileName, dbName, properties);
    :}
    ;

key_value_map ::=
    STRING_LITERAL:name EQUAL STRING_LITERAL:value
    {:
    RESULT = Maps.newHashMap();
    RESULT.put(name, value);
    :}
    | key_value_map:map COMMA STRING_LITERAL:name EQUAL STRING_LITERAL:value
    {:
    map.put(name, value);
    RESULT = map;
    :}
    ;

opt_properties ::=
    {:
    RESULT = null;
    :}
    | KW_PROPERTIES LPAREN key_value_map:map RPAREN
    {:
    RESULT = map;
    :}
    ;

opt_if_not_exists ::=
    {:
        RESULT = false;
    :}
    | KW_IF KW_NOT KW_EXISTS
    {:
        RESULT = true;
    :}
    ;

// Show statement
show_stmt ::=
    KW_SHOW show_param:stmt
    {:
        RESULT = stmt;
    :}
    ;

show_param ::=
    // show sqlblacklist
    KW_SQLBLACKLIST
    {:
        RESULT = new ShowSqlBlackListStmt();
    :}
    | KW_WHITELIST
    {:
        RESULT = new ShowWhiteListStmt();
    :}
    /* Show export statement */
    | KW_EXPORT opt_db:db opt_wild_where order_by_clause:orderByClause limit_clause:limitClause
    {:
        RESULT = new ShowExportStmt(db, parser.where, orderByClause, limitClause);
    :}
    | KW_ALL KW_GRANTS
    {:
        RESULT = new ShowGrantsStmt(null, true);
    :}
    | KW_GRANTS
    {:
        RESULT = new ShowGrantsStmt(null, false);
    :}
    | KW_GRANTS KW_FOR user_identity:userIdent
    {:
        RESULT = new ShowGrantsStmt(userIdent, false);
    :}
    | KW_ROLES
    {:
        RESULT = new ShowRolesStmt();
    :}
    | KW_FILE opt_db:dbName
    {:
        RESULT = new ShowSmallFilesStmt(dbName);
    :}
    ;

opt_db ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | from_or_in ident:db
    {:
        RESULT = db;
    :}
    ;

charset ::=
    KW_CHAR KW_SET
    | KW_CHARSET
    ;

charset_name_or_default ::=
    ident_or_text:id
    {:
        RESULT = id;
    :}
    | KW_DEFAULT
    {:
        RESULT = null;
    :}
    ;

old_or_new_charset_name_or_default ::=
    ident_or_text:id
    {:
        RESULT = id;
    :}
    | KW_DEFAULT
    {:
        RESULT = null;
    :}
    ;

opt_collate ::=
    /* Empty */
    {:
        RESULT = null;
    :}
    | KW_COLLATE collation_name_or_default:collate
    {:
        RESULT = collate;
    :}
    ;

collation_name_or_default ::=
    ident_or_text:id
    {:
        RESULT = id;
    :}
    | KW_DEFAULT
    {:
        RESULT = null;
    :}
    ;

from_or_in ::=
    KW_FROM
    | KW_IN
    ;

opt_wild_where ::=
    /* empty */
    | KW_LIKE STRING_LITERAL:wild
    {:
        parser.wild = wild;
    :}
    | KW_WHERE expr:where
    {:
        parser.where = where;
    :}
    ;

// Cancel statement
cancel_stmt ::=
    KW_CANCEL cancel_param:stmt
    {:
        RESULT = stmt;
    :}
    ;

cancel_param ::=
    | KW_DECOMMISSION KW_BACKEND string_list:hostPorts
    {:
        RESULT = new CancelAlterSystemStmt(hostPorts);
    :}
    | KW_BACKUP opt_db:db
    {:
        RESULT = new CancelBackupStmt(db, false);
    :}
    | KW_RESTORE opt_db:db
    {:
        RESULT = new CancelBackupStmt(db, true);
    :}
    | KW_EXPORT opt_db:db opt_wild_where
    {:
        RESULT = new CancelExportStmt(db, parser.where);
    :}
    ;

// Delete stmt
delete_stmt ::=
    KW_DELETE KW_FROM table_name:table opt_partition_names:partitionNames where_clause:wherePredicate
    {:
        RESULT = new DeleteStmt(table, partitionNames, wherePredicate);
    :}
    | KW_DELETE KW_SQLBLACKLIST integer_list:ids
    {:
        RESULT = new DelSqlBlackListStmt(ids);
    :}
    ;

// TODO(zhaochun): stolen from MySQL. Why not use value list, maybe avoid shift/reduce conflict
// Set statement
set_stmt ::=
    KW_SET start_option_value_list:list
    {:
        RESULT = new SetStmt(list);
    :}
    ;

// Start of set value list
start_option_value_list ::=
    /* Variable starts with keyword and have no option */
    option_value_no_option_type:value option_value_list_continued:list
    {:
        if (list == null) {
            list = Lists.newArrayList(value);
        } else {
            list.add(value);
        }
        RESULT = list;
    :}
    /* Do not support transaction, return null */
    | KW_TRANSACTION transaction_characteristics
    {:
        RESULT = Lists.newArrayList((SetVar) new SetTransaction());
    :}
    | option_type:type start_option_value_list_following_option_type:list
    {:
        if (list == null || list.isEmpty()) {
        } else {
            list.get(0).setType(type);
        }
        RESULT = list;
    :}
    ;

// Following the start of value list with option
start_option_value_list_following_option_type ::=
    option_value_follow_option_type:var option_value_list_continued:list
    {:
        list.add(var);
        RESULT = list;
    :}
    | KW_TRANSACTION transaction_characteristics
    {:
        RESULT = Lists.newArrayList((SetVar) new SetTransaction());
    :}
    ;

// option values after first value;
option_value_list_continued ::=
    /* empty */
    {:
        RESULT = Lists.newArrayList();
    :}
    | COMMA option_value_list:list
    {:
        RESULT = list;
    :}
    ;

option_value_list ::=
    option_value:var
    {:
        RESULT = Lists.newArrayList(var);
    :}
    | option_value_list:list COMMA option_value:item
    {:
        list.add(item);
        RESULT = list;
    :}
    ;

option_value ::=
    option_type:type option_value_follow_option_type:var
    {:
        var.setType(type);
        RESULT = var;
    :}
    | option_value_no_option_type:var
    {:
        RESULT = var;
    :}
    ;

option_value_follow_option_type ::=
    variable_name:variable equal set_expr_or_default:expr
    {:
        RESULT = new SetVar(variable, expr);
    :}
    ;

option_value_no_option_type ::=
    /* Normal set value */
    variable_name:variable equal set_expr_or_default:expr
    {:
        RESULT = new SetVar(variable, expr);
    :}
    | AT ident_or_text:var equal literal:expr
    {:
        RESULT = new SetVar(var, expr);
    :}
    /* Ident */
    | AT AT variable_name:variable equal set_expr_or_default:expr
    {:
        RESULT = new SetVar(variable, expr);
    :}
    | AT AT var_ident_type:type variable_name:variable equal set_expr_or_default:expr
    {:
        RESULT = new SetVar(type, variable, expr);
    :}
    /* charset */
    | charset old_or_new_charset_name_or_default:charset
    {:
        RESULT = new SetNamesVar(charset);
    :}
    | KW_NAMES equal expr
    {:
        parser.parseError("names", SqlParserSymbols.KW_NAMES);
    :}
    | KW_NAMES charset_name_or_default:charset opt_collate:collate
    {:
        RESULT = new SetNamesVar(charset, collate);
    :}
    /* Password */
    | KW_PASSWORD equal text_or_password:passwd
    {:
        RESULT = new SetPassVar(null, passwd);
    :}
    | KW_PASSWORD KW_FOR user_identity:userId equal text_or_password:passwd
    {:
        RESULT = new SetPassVar(userId, passwd);
    :}
    ;

variable_name ::=
    ident:name
    {:
        RESULT = name;
    :}
    ;

text_or_password ::=
    STRING_LITERAL:text
    {:
        // This is hashed text
        RESULT = text;
    :}
    | KW_PASSWORD LPAREN STRING_LITERAL:passwd RPAREN
    {:
        // This is plain text
        RESULT = new String(MysqlPassword.makeScrambledPassword(passwd));
    :}
    ;

option_type ::=
    KW_GLOBAL
    {:
        RESULT = SetType.GLOBAL;
    :}
    | KW_LOCAL
    {:
        RESULT = SetType.SESSION;
    :}
    | KW_SESSION
    {:
        RESULT = SetType.SESSION;
    :}
    ;

var_ident_type ::=
    KW_GLOBAL DOT
    {:
        RESULT = SetType.GLOBAL;
    :}
    | KW_LOCAL DOT
    {:
        RESULT = SetType.SESSION;
    :}
    | KW_SESSION DOT
    {:
        RESULT = SetType.SESSION;
    :}
    ;

equal ::=
    EQUAL
    | SET_VAR
    ;

transaction_characteristics ::=
    transaction_access_mode
    | isolation_level
    | transaction_access_mode COMMA isolation_level
    | isolation_level COMMA transaction_access_mode
    ;

transaction_access_mode ::=
    KW_READ KW_ONLY
    | KW_READ KW_WRITE
    ;

isolation_level ::=
    KW_ISOLATION KW_LEVEL isolation_types
    ;

isolation_types ::=
    KW_READ KW_UNCOMMITTED
    | KW_READ KW_COMMITTED
    | KW_REPEATABLE KW_READ
    | KW_SERIALIZABLE
    ;

set_expr_or_default ::=
    KW_DEFAULT
    {:
        RESULT = null;
    :}
    | KW_ON
    {:
        RESULT = new StringLiteral("ON");
    :}
    | KW_ALL
    {:
        RESULT = new StringLiteral("ALL");
    :}
    | expr:expr
    {:
        RESULT = expr;
    :}
    ;

table_name ::=
    ident:tbl
    {: RESULT = new TableName(null, tbl); :}
    | ident:db DOT ident:tbl
    {: RESULT = new TableName(db, tbl); :}
    ;

function_name ::=
    type_function_name:fn
    {: RESULT = new FunctionName(null, fn); :}
    | ident:db DOT type_function_name:fn
    {: RESULT = new FunctionName(db, fn); :}
    ;

type_function_name ::=
    ident:id
    {: RESULT = id; :}
    | type_func_name_keyword:id
    {: RESULT = id; :}
    ;

base_table_ref ::=
    table_name:name opt_partition_names:partitionNames opt_tablet_list:tabletIds opt_table_alias:alias opt_common_hints:commonHints
    {:
        RESULT = new TableRef(name, alias, partitionNames, tabletIds, commonHints);
    :}
    ;

opt_common_hints ::=
    COMMENTED_PLAN_HINT_START ident_list:l COMMENTED_PLAN_HINT_END
    {:
        RESULT = l;
    :}
    | LBRACKET ident_list:l RBRACKET
    {:
        RESULT = l;
    :}
    |
    {:
        RESULT = null;
    :}
    ;

opt_table_alias ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | ident:alias
    {:
        RESULT = alias;
    :}
    | KW_AS ident:alias
    {:
        RESULT = alias;
    :}
    | EQUAL ident:alias
    {:
        RESULT = alias;
    :}
    ;

opt_partition_names ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | partition_names:partitionNames
    {:
        RESULT = partitionNames;
    :}
    ;

partition_names ::=
    KW_PARTITION LPAREN ident_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(false, partitions);
    :}
    | KW_PARTITION LPAREN string_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(false, partitions);
    :}
    | KW_TEMPORARY KW_PARTITION LPAREN ident_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(true, partitions);
    :}
    | KW_TEMPORARY KW_PARTITION LPAREN string_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(true, partitions);
    :}
    | KW_PARTITIONS LPAREN ident_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(false, partitions);
    :}
    | KW_PARTITIONS LPAREN string_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(false, partitions);
    :}
    | KW_TEMPORARY KW_PARTITIONS LPAREN ident_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(true, partitions);
    :}
    | KW_TEMPORARY KW_PARTITIONS LPAREN string_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(true, partitions);
    :}
    | KW_PARTITION ident:partName
    {:
        RESULT = new PartitionNames(false, Lists.newArrayList(partName));
    :}
    | KW_PARTITION STRING_LITERAL:partName
    {:
        RESULT = new PartitionNames(false, Lists.newArrayList(partName));
    :}
    | KW_TEMPORARY KW_PARTITION ident:partName
    {:
        RESULT = new PartitionNames(true, Lists.newArrayList(partName));
    :}
    | KW_TEMPORARY KW_PARTITION STRING_LITERAL:partName
    {:
        RESULT = new PartitionNames(true, Lists.newArrayList(partName));
    :}
    ;

opt_tablet_list ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | tablet_list:tabletList
    {:
        RESULT = tabletList;
    :}
    ;

tablet_list ::=
    KW_TABLET LPAREN integer_list:tabletIds RPAREN
    {:
        RESULT = Lists.newArrayList(tabletIds);
    :}
    ;

ident_list ::=
    ident:ident
    {:
      ArrayList<String> list = new ArrayList<String>();
      list.add(ident);
      RESULT = list;
    :}
    | ident_list:list COMMA ident:ident
    {:
      list.add(ident);
      RESULT = list;
    :}
    ;

expr_list ::=
  expr:e
  {:
    ArrayList<Expr> list = new ArrayList<Expr>();
    list.add(e);
    RESULT = list;
  :}
  | expr_list:list COMMA expr:e
  {:
    list.add(e);
    RESULT = list;
  :}
  ;

where_clause ::=
   /* empty */
  {: RESULT = null; :}
  | KW_WHERE expr:e
  {: RESULT = e; :}
  ;


order_by_clause ::=
  KW_ORDER KW_BY order_by_elements:l
  {: RESULT = l; :}
  | /* empty */
  {: RESULT = null; :}
  ;

order_by_elements ::=
  order_by_element:e
  {:
    ArrayList<OrderByElement> list = new ArrayList<OrderByElement>();
    list.add(e);
    RESULT = list;
  :}
  | order_by_elements:list COMMA order_by_element:e
  {:
    list.add(e);
    RESULT = list;
  :}
  ;

order_by_element ::=
  expr:e opt_order_param:o opt_nulls_order_param:n
  {:
     if (n == null) {
       RESULT = new OrderByElement(e, o, o);
     } else {
       RESULT = new OrderByElement(e, o, n);
     }
   :}
  ;

opt_order_param ::=
  KW_ASC
  {: RESULT = true; :}
  | KW_DESC
  {: RESULT = false; :}
  | /* empty */
  {: RESULT = true; :}
  ;

opt_nulls_order_param ::=
  KW_NULLS KW_FIRST
  {: RESULT = true; :}
  | KW_NULLS KW_LAST
  {: RESULT = false; :}
  | /* empty */
  {: RESULT = null; :}
  ;

limit_clause ::=
  KW_LIMIT INTEGER_LITERAL:limit
  {: RESULT = new LimitElement(limit.longValue()); :}
  | /* empty */
  {: RESULT = LimitElement.NO_LIMIT; :}
  | KW_LIMIT INTEGER_LITERAL:offset COMMA INTEGER_LITERAL:limit
  {: RESULT = new LimitElement(offset.longValue(), limit.longValue()); :}
  | KW_LIMIT INTEGER_LITERAL:limit KW_OFFSET INTEGER_LITERAL:offset
  {: RESULT = new LimitElement(offset.longValue(), limit.longValue()); :}
  ;

type ::=
  KW_TINYINT opt_field_length
  {: RESULT = Type.TINYINT; :}
  | KW_SMALLINT opt_field_length
  {: RESULT = Type.SMALLINT; :}
  | KW_INT opt_field_length
  {: RESULT = Type.INT; :}
  | KW_SIGNED
  {: RESULT = Type.INT; :}
  | KW_SIGNED KW_INT
  {: RESULT = Type.INT; :}
  | KW_BIGINT opt_field_length
  {: RESULT = Type.BIGINT; :}
  | KW_LARGEINT opt_field_length
  {: RESULT = Type.LARGEINT; :}
  | KW_BOOLEAN
  {: RESULT = Type.BOOLEAN; :}
  | KW_FLOAT
  {: RESULT = Type.FLOAT; :}
  | KW_DOUBLE
  {: RESULT = Type.DOUBLE; :}
  | KW_DATE
  {: RESULT = Type.DATE; :}
  | KW_DATETIME
  {: RESULT = Type.DATETIME; :}
  | KW_TIME
  {: RESULT = Type.TIME; :}
  | KW_BITMAP
  {: RESULT = Type.BITMAP; :}
  | KW_PERCENTILE
  {: RESULT = Type.PERCENTILE; :}
  | KW_JSON
  {: RESULT = Type.JSON; :}
  | KW_STRING
  {: ScalarType type = ScalarType.createVarcharType(ScalarType.DEFAULT_STRING_LENGTH);
     type.setAssignedStrLenInColDefinition();
     RESULT = type;
  :}
  | KW_VARCHAR LPAREN INTEGER_LITERAL:len RPAREN
  {: ScalarType type = ScalarType.createVarcharType(len.intValue());
     type.setAssignedStrLenInColDefinition();
     RESULT = type;
  :}
  | KW_VARCHAR
  {: RESULT = ScalarType.createVarcharType(-1); :}
  | KW_CHAR LPAREN INTEGER_LITERAL:len RPAREN
  {: ScalarType type = ScalarType.createCharType(len.intValue());
     type.setAssignedStrLenInColDefinition();
     RESULT = type;
  :}
  | KW_CHAR
  {: RESULT = ScalarType.createCharType(-1); :}
  | KW_DECIMAL LPAREN INTEGER_LITERAL:precision RPAREN
  {: RESULT = ScalarType.createUnifiedDecimalType(precision.intValue()); :}
  | KW_DECIMAL LPAREN INTEGER_LITERAL:precision COMMA INTEGER_LITERAL:scale RPAREN
  {: RESULT = ScalarType.createUnifiedDecimalType(precision.intValue(), scale.intValue()); :}
  | KW_DECIMAL
  {: RESULT = ScalarType.createUnifiedDecimalType(10, 0); :}
  | KW_DECIMALV2 LPAREN INTEGER_LITERAL:precision RPAREN
  {: RESULT = ScalarType.createDecimalV2Type(precision.intValue()); :}
  | KW_DECIMALV2 LPAREN INTEGER_LITERAL:precision COMMA INTEGER_LITERAL:scale RPAREN
  {: RESULT = ScalarType.createDecimalV2Type(precision.intValue(), scale.intValue()); :}
  | KW_DECIMALV2
  {: RESULT = ScalarType.createDecimalV2Type(); :}
  | KW_DECIMAL32 LPAREN INTEGER_LITERAL:precision RPAREN
  {:
     ScalarType.checkEnableDecimalV3();
     RESULT = ScalarType.createDecimalV3Type(PrimitiveType.DECIMAL32, precision.intValue());
  :}
  | KW_DECIMAL32 LPAREN INTEGER_LITERAL:precision COMMA INTEGER_LITERAL:scale RPAREN
  {:
     ScalarType.checkEnableDecimalV3();
     RESULT = ScalarType.createDecimalV3Type(PrimitiveType.DECIMAL32, precision.intValue(), scale.intValue());
  :}
  | KW_DECIMAL32
  {:
     ScalarType.checkEnableDecimalV3();
     RESULT = ScalarType.createDecimalV3Type(PrimitiveType.DECIMAL32);
  :}
  | KW_DECIMAL64 LPAREN INTEGER_LITERAL:precision RPAREN
  {:
     ScalarType.checkEnableDecimalV3();
     RESULT = ScalarType.createDecimalV3Type(PrimitiveType.DECIMAL64, precision.intValue());
  :}
  | KW_DECIMAL64 LPAREN INTEGER_LITERAL:precision COMMA INTEGER_LITERAL:scale RPAREN
  {:
     ScalarType.checkEnableDecimalV3();
     RESULT = ScalarType.createDecimalV3Type(PrimitiveType.DECIMAL64, precision.intValue(), scale.intValue());
  :}
  | KW_DECIMAL64
  {:
     ScalarType.checkEnableDecimalV3();
     RESULT = ScalarType.createDecimalV3Type(PrimitiveType.DECIMAL64);
  :}
  | KW_DECIMAL128 LPAREN INTEGER_LITERAL:precision RPAREN
  {:
     ScalarType.checkEnableDecimalV3();
     RESULT = ScalarType.createDecimalV3Type(PrimitiveType.DECIMAL128, precision.intValue());
  :}
  | KW_DECIMAL128 LPAREN INTEGER_LITERAL:precision COMMA INTEGER_LITERAL:scale RPAREN
  {:
     ScalarType.checkEnableDecimalV3();
     RESULT = ScalarType.createDecimalV3Type(PrimitiveType.DECIMAL128, precision.intValue(), scale.intValue());
  :}
  | KW_DECIMAL128
  {:
     ScalarType.checkEnableDecimalV3();
     RESULT = ScalarType.createDecimalV3Type(PrimitiveType.DECIMAL128);
  :}
  | KW_HLL
  {: ScalarType type = ScalarType.createHllType();
     type.setAssignedStrLenInColDefinition();
     RESULT = type;
  :}
  ;

array_def ::=
   KW_ARRAY LESSTHAN type:item_type GREATERTHAN
   {: RESULT = new ArrayType(item_type); :}
   | KW_ARRAY LESSTHAN array_def:sub_array GREATERTHAN
   {: RESULT = new ArrayType(sub_array); :}
   ;

opt_field_length ::=
  LPAREN INTEGER_LITERAL:length RPAREN
  {: RESULT = length; :}
  |
  {: RESULT = null; :}
  ;

type_def ::=
  type:t
  {: RESULT = new TypeDef(t); :}
  | array_def:t
  {: RESULT = new TypeDef(t); :}
  ;

cast_expr ::=
  KW_CAST LPAREN expr:e KW_AS type_def:targetType RPAREN
  {: RESULT = new CastExpr(targetType, e); :}
  ;

case_expr ::=
  KW_CASE expr:caseExpr
    case_when_clause_list:whenClauseList
    case_else_clause:elseExpr
    KW_END
  {: RESULT = new CaseExpr(caseExpr, whenClauseList, elseExpr); :}
  | KW_CASE
    case_when_clause_list:whenClauseList
    case_else_clause:elseExpr
    KW_END
  {: RESULT = new CaseExpr(null, whenClauseList, elseExpr); :}
  ;

case_when_clause_list ::=
  KW_WHEN expr:whenExpr KW_THEN expr:thenExpr
  {:
    ArrayList<CaseWhenClause> list = new ArrayList<CaseWhenClause>();
    list.add(new CaseWhenClause(whenExpr, thenExpr));
    RESULT = list;
  :}
  | case_when_clause_list:list KW_WHEN expr:whenExpr
    KW_THEN expr:thenExpr
  {:
    list.add(new CaseWhenClause(whenExpr, thenExpr));
    RESULT = list;
  :}
  ;

case_else_clause ::=
  KW_ELSE expr:e
  {: RESULT = e; :}
  | /* emtpy */
  {: RESULT = null; :}
  ;

sign_chain_expr ::=
  SUBTRACT expr:e
  {:
    // integrate signs into literals
    if (e.isLiteral() && e.getType().isNumericType()) {
      ((LiteralExpr)e).swapSign();
      RESULT = e;
    } else {
      RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.MULTIPLY, new IntLiteral((long)-1), e);
    }
  :}
  | ADD expr:e
  {: RESULT = e; :}
  ;

expr ::=
  non_pred_expr:e opt_collate:collate
  {: RESULT = e; :}
  | predicate:p
  {: RESULT = p; :}
  | LBRACE KW_FN function_call_expr:fn RBRACE
    {:
      OdbcScalarFunctionCall ofn = new OdbcScalarFunctionCall(fn);
      RESULT = ofn.mappingFunction();
    :}
  | LBRACE KW_FN KW_EXTRACT LPAREN function_name:fn_name KW_FROM func_arg_list:exprs RPAREN RBRACE
    {:
      FunctionCallExpr fn = new FunctionCallExpr(fn_name, exprs);
      OdbcScalarFunctionCall ofn = new OdbcScalarFunctionCall(fn);
      RESULT = ofn.mappingFunction();
    :}
  ;

array_expr ::=
  LBRACKET expr_list:items RBRACKET
  {: RESULT = new ArrayExpr(null, items); :}
  | array_def:t LBRACKET expr_list:items RBRACKET
  {: RESULT = new ArrayExpr(t, items); :}
  | array_def:t LBRACKET RBRACKET
  {: RESULT = new ArrayExpr(t, new ArrayList<Expr>()); :}
  | LBRACKET RBRACKET
  {: RESULT = new ArrayExpr(null, new ArrayList<Expr>()); :}
  ;

array_subscript ::=
  expr:e LBRACKET expr:subscript RBRACKET
  {: RESULT = new ArrayElementExpr(e, subscript); :}
  ;

array_slice ::=
  expr:e LBRACKET expr:l COLON expr:r RBRACKET
  {: RESULT = new ArraySliceExpr(e, l, r); :}
  | expr:e LBRACKET COLON expr:r RBRACKET
  {: RESULT = new ArraySliceExpr(e, new IntLiteral(0), r); :}
  | expr:e LBRACKET expr:l COLON RBRACKET
  {: RESULT = new ArraySliceExpr(e, l, new IntLiteral(-1)); :}
  | expr:e LBRACKET COLON RBRACKET
  {: RESULT = new ArraySliceExpr(e, new IntLiteral(0), new IntLiteral(-1)); :}
  ;

arrow_expr ::=
   expr:l ARROW expr:r
   {: RESULT = new ArrowExpr(l, r); :}
   ;

function_call_expr ::=
  function_name:fn_name LPAREN RPAREN
  {: RESULT = new FunctionCallExpr(fn_name, new ArrayList<Expr>()); :}
  | function_name:fn_name LPAREN function_params:params RPAREN
  {:
    if ("grouping".equalsIgnoreCase(fn_name.getFunction())) {
      if (params.exprs().size() > 1) {
        throw new AnalysisException("GROUPING requires exactly one column parameter.");
      }
      RESULT = new GroupingFunctionCallExpr(fn_name, params);
    } else if ("grouping_id".equalsIgnoreCase(fn_name.getFunction())) {
      RESULT = new GroupingFunctionCallExpr(fn_name, params);
    } else {
      RESULT = new FunctionCallExpr(fn_name, params);
    }
  :}
  ;

exists_predicate ::=
  KW_EXISTS subquery:s
  {: RESULT = new ExistsPredicate(s, false); :}
  ;

non_pred_expr ::=
  sign_chain_expr:e
  {: RESULT = e; :}
  | AT AT ident:l
  {:
    RESULT = new VariableExpr(l);
  :}
  | AT AT var_ident_type:type ident:l
  {:
    RESULT = new VariableExpr(l, type);
  :}
  | literal:l
  {: RESULT = l; :}
  | function_call_expr:e
  {: RESULT = e; :}
  | KW_DATE STRING_LITERAL:l
  {: RESULT = new StringLiteral(l); :}
  | KW_TIMESTAMP STRING_LITERAL:l
  {: RESULT = new StringLiteral(l); :}
  | KW_EXTRACT LPAREN function_name:fn_name KW_FROM func_arg_list:exprs RPAREN
  {: RESULT = new FunctionCallExpr(fn_name, exprs); :}
  //| function_name:fn_name LPAREN RPAREN
  //{: RESULT = new FunctionCallExpr(fn_name, new ArrayList<Expr>()); :}
  //| function_name:fn_name LPAREN function_params:params RPAREN
  //{: RESULT = new FunctionCallExpr(fn_name, params); :}
  | analytic_expr:e
  {: RESULT = e; :}
  /* Since "IF" is a keyword, need to special case this function */
  | KW_IF LPAREN expr_list:exprs RPAREN
  {: RESULT = new FunctionCallExpr("if", exprs); :}
  /* For the case like e1 || e2 || e3 ... */
  | expr_pipe_list:exprs
  {:
    RESULT = new FunctionCallExpr("concat", exprs);
  :}
  | cast_expr:c
  {: RESULT = c; :}
  | case_expr:c
  {: RESULT = c; :}
  | column_ref:c
  {: RESULT = c; :}
  | timestamp_arithmetic_expr:e
  {: RESULT = e; :}
  | arithmetic_expr:e
  {: RESULT = e; :}
  | LPAREN non_pred_expr:e RPAREN
  {:
    e.setPrintSqlInParens(true);
    RESULT = e;
  :}
  /* TODO(zc): add other trim function */
  | KW_TRIM:id LPAREN function_params:params RPAREN
  {: RESULT = new FunctionCallExpr(new FunctionName(null, id), params); :}
  | KW_DATABASE LPAREN RPAREN
  {: RESULT = new InformationFunction("DATABASE"); :}
  | KW_SCHEMA LPAREN RPAREN
  {: RESULT = new InformationFunction("SCHEMA"); :}
  | KW_USER LPAREN RPAREN
  {: RESULT = new InformationFunction("USER"); :}
  | KW_CURRENT_USER LPAREN RPAREN
  {: RESULT = new InformationFunction("CURRENT_USER"); :}
  | KW_CONNECTION_ID LPAREN RPAREN
  {: RESULT = new InformationFunction("CONNECTION_ID"); :}
  | KW_PASSWORD LPAREN STRING_LITERAL:text RPAREN
  {:
    RESULT = new StringLiteral(new String(MysqlPassword.makeScrambledPassword(text)));
  :}
  | subquery:s
  {: RESULT = s; :}
  |  KW_NULL KW_IS KW_NULL
  {: RESULT = new BoolLiteral(true); :}
  | KW_NULL KW_IS KW_NOT KW_NULL
  {: RESULT = new BoolLiteral(false); :}
  | array_expr:e
  {: RESULT = e; :}
  | array_subscript:e
  {: RESULT = e; :}
  | array_slice:e
  {: RESULT = e; :}
  | arrow_expr:e
  {: RESULT = e; :}
  ;

expr_pipe_list ::=
  expr:e1 KW_PIPE expr:e2
  {:
    ArrayList<Expr> list = new ArrayList<Expr>();
    list.add(e1);
    list.add(e2);
    RESULT = list;
  :}
  | expr_pipe_list:list KW_PIPE expr:e
  {:
    list.add(e);
    RESULT = list;
  :}
  ;

func_arg_list ::=
  expr:item
  {:
    ArrayList<Expr> list = new ArrayList<Expr>();
    list.add(item);
    RESULT = list;
  :}
  | func_arg_list:list COMMA expr:item
  {:
    list.add(item);
    RESULT = list;
  :}
  ;

analytic_expr ::=
  function_call_expr:e KW_OVER LPAREN opt_partition_by_clause:p order_by_clause:o opt_window_clause:w RPAREN
  {:
    // Handle cases where function_call_expr resulted in a plain Expr
    if (!(e instanceof FunctionCallExpr)) {
      parser.parseError("over", SqlParserSymbols.KW_OVER);
    }
    FunctionCallExpr f = (FunctionCallExpr)e;
    f.setIsAnalyticFnCall(true);
    RESULT = new AnalyticExpr(f, p, o, w);
  :}
  %prec KW_OVER
  ;

opt_partition_by_clause ::=
  KW_PARTITION KW_BY expr_list:l
  {: RESULT = l; :}
  | /* empty */
  {: RESULT = null; :}
  ;

opt_window_clause ::=
  window_type:t window_boundary:b
  {: RESULT = new AnalyticWindow(t, b); :}
  | window_type:t KW_BETWEEN window_boundary:l KW_AND window_boundary:r
  {: RESULT = new AnalyticWindow(t, l, r); :}
  | /* empty */
  {: RESULT = null; :}
  ;

window_type ::=
  KW_ROWS
  {: RESULT = AnalyticWindow.Type.ROWS; :}
  | KW_RANGE
  {: RESULT = AnalyticWindow.Type.RANGE; :}
  ;

window_boundary ::=
  KW_UNBOUNDED KW_PRECEDING
  {:
    RESULT = new AnalyticWindow.Boundary(
        AnalyticWindow.BoundaryType.UNBOUNDED_PRECEDING, null);
  :}
  | KW_UNBOUNDED KW_FOLLOWING
  {:
    RESULT = new AnalyticWindow.Boundary(
        AnalyticWindow.BoundaryType.UNBOUNDED_FOLLOWING, null);
  :}
  | KW_CURRENT KW_ROW
  {:
    RESULT = new AnalyticWindow.Boundary(AnalyticWindow.BoundaryType.CURRENT_ROW, null);
  :}
  | expr:e KW_PRECEDING
  {: RESULT = new AnalyticWindow.Boundary(AnalyticWindow.BoundaryType.PRECEDING, e); :}
  | expr:e KW_FOLLOWING
  {: RESULT = new AnalyticWindow.Boundary(AnalyticWindow.BoundaryType.FOLLOWING, e); :}
  ;

arithmetic_expr ::=
  expr:e1 STAR expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.MULTIPLY, e1, e2); :}
  | expr:e1 DIVIDE expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.DIVIDE, e1, e2); :}
  | expr:e1 MOD expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.MOD, e1, e2); :}
  | expr:e1 KW_DIV expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.INT_DIVIDE, e1, e2); :}
  | expr:e1 ADD expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.ADD, e1, e2); :}
  | expr:e1 SUBTRACT expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.SUBTRACT, e1, e2); :}
  | expr:e1 BITAND expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.BITAND, e1, e2); :}
  | expr:e1 BITOR expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.BITOR, e1, e2); :}
  | expr:e1 BITXOR expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.BITXOR, e1, e2); :}
  | BITNOT expr:e
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.BITNOT, e, null); :}
  ;

// We use IDENT for the temporal unit to avoid making DAY, YEAR, etc. keywords.
// This way we do not need to change existing uses of IDENT.
// We chose not to make DATE_ADD and DATE_SUB keywords for the same reason.
timestamp_arithmetic_expr ::=
  KW_INTERVAL expr:v ident:u ADD expr:t
  {: RESULT = new TimestampArithmeticExpr(ArithmeticExpr.Operator.ADD, t, v, u, true); :}
  | expr:t ADD KW_INTERVAL expr:v ident:u
  {:
    RESULT = new TimestampArithmeticExpr(ArithmeticExpr.Operator.ADD, t, v, u, false);
  :}
  // Set precedence to KW_INTERVAL (which is higher than ADD) for chaining.
  %prec KW_INTERVAL
  | expr:t SUBTRACT KW_INTERVAL expr:v ident:u
  {:
    RESULT =
        new TimestampArithmeticExpr(ArithmeticExpr.Operator.SUBTRACT, t, v, u, false);
  :}
  // Set precedence to KW_INTERVAL (which is higher than ADD) for chaining.
  %prec KW_INTERVAL
  // Timestamp arithmetic expr that looks like a function call.
  // We use func_arg_list instead of expr to avoid a shift/reduce conflict with
  // func_arg_list on COMMA, and report an error if the list contains more than one expr.
  // Although we don't want to accept function names as the expr, we can't parse it
  // it as just an IDENT due to the precedence conflict with function_name.
  | function_name:functionName LPAREN expr_list:l COMMA
    KW_INTERVAL expr:v ident:u RPAREN
  {:
    if (l.size() > 1) {
      // Report parsing failure on keyword interval.
      parser.parseError("interval", SqlParserSymbols.KW_INTERVAL);
    }
    if (functionName.getDb() != null) {
      // This function should not fully qualified
      throw new Exception("interval should not be qualified by database name");
    }

    RESULT = new TimestampArithmeticExpr(functionName.getFunction(), l.get(0), v, u);
  :}
  | function_name:functionName LPAREN time_unit:u COMMA expr:e1 COMMA expr:e2 RPAREN
  {:
    RESULT = new TimestampArithmeticExpr(functionName.getFunction(), e2, e1, u);
  :}
  ;

literal ::=
  INTEGER_LITERAL:l
  {: RESULT = new IntLiteral(l); :}
  | LARGE_INTEGER_LITERAL:l
  {: RESULT = new LargeIntLiteral(l); :}
  | FLOATINGPOINT_LITERAL:l
  {: RESULT = new FloatLiteral(l); :}
  | DECIMAL_LITERAL:l
  {: RESULT = new DecimalLiteral(l); :}
  | STRING_LITERAL:l
  // for support mysql embedded quotation e.g. SELECT "Pat O""Hanrahan & <Matthew Eldridge]""";
  {: RESULT = new StringLiteral(l.replaceAll("\"\"", "\"")); :}
  | KW_TRUE
  {: RESULT = new BoolLiteral(true); :}
  | KW_FALSE
  {: RESULT = new BoolLiteral(false); :}
  | KW_NULL
  {: RESULT = new NullLiteral(); :}
  | UNMATCHED_STRING_LITERAL:l expr:e
  {:
    // we have an unmatched string literal.
    // to correctly report the root cause of this syntax error
    // we must force parsing to fail at this point,
    // and generate an unmatched string literal symbol
    // to be passed as the last seen token in the
    // error handling routine (otherwise some other token could be reported)
    parser.parseError("literal", SqlParserSymbols.UNMATCHED_STRING_LITERAL);
  :}
  | NUMERIC_OVERFLOW:l
  {:
    // similar to the unmatched string literal case
    // we must terminate parsing at this point
    // and generate a corresponding symbol to be reported
    parser.parseError("literal", SqlParserSymbols.NUMERIC_OVERFLOW);
  :}
  ;

function_params ::=
  STAR
  {: RESULT = FunctionParams.createStarParam(); :}
  | KW_ALL STAR
  {: RESULT = FunctionParams.createStarParam(); :}
  | expr_list:exprs
  {: RESULT = new FunctionParams(false, exprs); :}
  | KW_ALL expr_list:exprs
  {: RESULT = new FunctionParams(false, exprs); :}
  | KW_DISTINCT:distinct expr_list:exprs
  {: RESULT = new FunctionParams(true, exprs); :}
  ;

predicate ::=
  expr:e KW_IS KW_NULL
  {: RESULT = new IsNullPredicate(e, false); :}
  | KW_ISNULL LPAREN expr:e RPAREN
  {: RESULT = new IsNullPredicate(e, false); :}
  | expr:e KW_IS KW_NOT KW_NULL
  {: RESULT = new IsNullPredicate(e, true); :}
  | between_predicate:p
  {: RESULT = p; :}
  | comparison_predicate:p
  {: RESULT = p; :}
  | compound_predicate:p
  {: RESULT = p; :}
  | in_predicate:p
  {: RESULT = p; :}
  | exists_predicate:p
  {: RESULT = p; :}
  | like_predicate:p
  {: RESULT = p; :}
  | LPAREN predicate:p RPAREN
  {:
    p.setPrintSqlInParens(true);
    RESULT = p;
  :}
  ;

comparison_predicate ::=
  expr:e1 EQUAL:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.EQ, e1, e2); :}
  | expr:e1 NOT EQUAL:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.NE, e1, e2); :}
  | expr:e1 LESSTHAN GREATERTHAN:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.NE, e1, e2); :}
  | expr:e1 LESSTHAN EQUAL:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.LE, e1, e2); :}
  | expr:e1 GREATERTHAN EQUAL:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.GE, e1, e2); :}
  | expr:e1 LESSTHAN:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.LT, e1, e2); :}
  | expr:e1 GREATERTHAN:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.GT, e1, e2); :}
  | expr:e1 LESSTHAN EQUAL GREATERTHAN:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.EQ_FOR_NULL, e1, e2); :}
  ;

like_predicate ::=
  expr:e1 KW_LIKE expr:e2
  {: RESULT = new LikePredicate(LikePredicate.Operator.LIKE, e1, e2); :}
  | expr:e1 KW_REGEXP expr:e2
  {: RESULT = new LikePredicate(LikePredicate.Operator.REGEXP, e1, e2); :}
  | expr:e1 KW_NOT KW_LIKE expr:e2
  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.NOT,
    new LikePredicate(LikePredicate.Operator.LIKE, e1, e2), null); :}
  | expr:e1 KW_NOT KW_REGEXP expr:e2
  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.NOT,
    new LikePredicate(LikePredicate.Operator.REGEXP, e1, e2), null); :}
  ;

// Avoid a reduce/reduce conflict with compound_predicate by explicitly
// using non_pred_expr and predicate separately instead of expr.
between_predicate ::=
  expr:e1 KW_BETWEEN non_pred_expr:e2 KW_AND expr:e3
  {: RESULT = new BetweenPredicate(e1, e2, e3, false); :}
  | expr:e1 KW_BETWEEN predicate:e2 KW_AND expr:e3
  {: RESULT = new BetweenPredicate(e1, e2, e3, false); :}
  | expr:e1 KW_NOT KW_BETWEEN non_pred_expr:e2 KW_AND expr:e3
  {: RESULT = new BetweenPredicate(e1, e2, e3, true); :}
  | expr:e1 KW_NOT KW_BETWEEN predicate:e2 KW_AND expr:e3
  {: RESULT = new BetweenPredicate(e1, e2, e3, true); :}
  ;

in_predicate ::=
  expr:e KW_IN LPAREN expr_list:l RPAREN
  {: RESULT = new InPredicate(e, l, false); :}
  | expr:e KW_NOT KW_IN LPAREN expr_list:l RPAREN
  {: RESULT = new InPredicate(e, l, true); :}
  | expr:e KW_IN subquery:s
  {: RESULT = new InPredicate(e, s, false); :}
  | expr:e KW_NOT KW_IN subquery:s
  {: RESULT = new InPredicate(e, s, true); :}
  ;

subquery ::=
  LPAREN subquery:query RPAREN
  {: RESULT = query; :}
  ;

compound_predicate ::=
  expr:e1 KW_AND expr:e2
  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.AND, e1, e2); :}
  | expr:e1 KW_OR expr:e2
  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.OR, e1, e2); :}
  | KW_NOT expr:e
  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.NOT, e, null); :}
  | NOT expr:e
  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.NOT, e, null); :}
  ;

column_ref ::=
  ident:col
  {: RESULT = new SlotRef(null, col); :}
  // table_name:tblName DOT IDENT:col causes reduce/reduce conflicts
  | ident:tbl DOT ident:col
  {: RESULT = new SlotRef(new TableName(null, tbl), col); :}
  | ident:db DOT ident:tbl DOT ident:col
  {: RESULT = new SlotRef(new TableName(db, tbl), col); :}
  ;

privilege_type ::=
    ident:name
    {:
        RESULT = AccessPrivilege.fromName(name);
        if (RESULT == null) {
            throw new AnalysisException("Unknown privilege type " + name);
        }
    :}
    | KW_ALL:id
    {:
        RESULT = AccessPrivilege.ALL;
    :}
    ;

privilege_list ::=
    privilege_list:l COMMA privilege_type:priv
    {:
        l.add(priv);
        RESULT = l;
    :}
    | privilege_type:priv
    {:
        RESULT = Lists.newArrayList(priv);
    :}
    ;

string_list ::=
    string_list:l COMMA STRING_LITERAL:item
    {:
        l.add(item);
        RESULT = l;
    :}
    | STRING_LITERAL:item
    {:
        RESULT = Lists.newArrayList(item);
    :}
    ;

integer_list ::=
    integer_list:l COMMA INTEGER_LITERAL:item
    {:
        l.add(item);
        RESULT = l;
    :}
    | INTEGER_LITERAL:item
    {:
        RESULT = Lists.newArrayList(item);
    :}
    ;

unsupported_stmt ::=
    KW_START KW_TRANSACTION opt_with_consistent_snapshot:v
    {:
        RESULT = new UnsupportedStmt();
    :}
    | KW_BEGIN opt_work:work
    {:
        RESULT = new UnsupportedStmt();
    :}
    | KW_COMMIT opt_work opt_chain opt_release
    {:
        RESULT = new UnsupportedStmt();
    :}
    | KW_ROLLBACK opt_work opt_chain opt_release
    {:
        RESULT = new UnsupportedStmt();
    :}
    ;

opt_with_consistent_snapshot ::=
    {:
        RESULT = null;
    :}
    | KW_WITH KW_CONSISTENT KW_SNAPSHOT
    {:
        RESULT = null;
    :}
    ;

opt_work ::=
    {:
        RESULT = null;
    :}
    | KW_WORK
    {:
        RESULT = null;
    :}
    ;

opt_chain ::=
    {:
        RESULT = null;
    :}
    | KW_AND KW_NO KW_CHAIN
    {:
        RESULT = null;
    :}
    | KW_AND KW_CHAIN
    {:
        RESULT = null;
    :}
    ;

opt_release ::=
    {:
        RESULT = null;
    :}
    | KW_RELEASE
    {:
        RESULT = null;
    :}
    | KW_NO KW_RELEASE
    {:
        RESULT = null;
    :}
    ;

type_func_name_keyword ::=
    KW_LEFT:id
    {: RESULT = id; :}
    | KW_RIGHT:id
    {: RESULT = id; :}
    ;

// Keyword that we allow for identifiers
keyword ::=
    KW_AFTER:id
    {: RESULT = id; :}
    | KW_AGGREGATE:id
    {: RESULT = id; :}
    | KW_AUTHORS:id
    {: RESULT = id; :}
    | KW_BACKUP:id
    {: RESULT = id; :}
    | KW_BEGIN:id
    {: RESULT = id; :}
    | KW_BITMAP:id
    {: RESULT = id; :}
    | KW_JSON:id
    {: RESULT = id; :}
    | KW_BITMAP_UNION:id
    {: RESULT = id; :}
    | KW_BOOLEAN:id
    {: RESULT = id; :}
    | KW_BROKER:id
    {: RESULT = id; :}
    | KW_BACKENDS:id
    {: RESULT = id; :}
    | KW_BUILTIN:id
    {: RESULT = id; :}
    | KW_CHAIN:id
    {: RESULT = id; :}
    | KW_CHARSET:id
    {: RESULT = id; :}
    | KW_CHECK:id
    {: RESULT = id; :}
    | KW_COLUMNS:id
    {: RESULT = id; :}
    | KW_COMMENT:id
    {: RESULT = id; :}
    | KW_COMMITTED:id
    {: RESULT = id; :}
    | KW_CONSISTENT:id
    {: RESULT = id; :}
    | KW_COLLATION:id
    {: RESULT = id; :}
    | KW_COMMIT:id
    {: RESULT = id; :}
    | KW_CONFIG:id
    {: RESULT = id; :}
    | KW_CONNECTION:id
    {: RESULT = id; :}
    | KW_CONNECTION_ID:id
    {: RESULT = id; :}
    | KW_DATA:id
    {: RESULT = id; :}
    | KW_DATE:id
    {: RESULT = id; :}
    | KW_DATETIME:id
    {: RESULT = id; :}
    | KW_DISTINCTPC:id
    {: RESULT = id; :}
    | KW_DISTINCTPCSA:id
    {: RESULT = id; :}
    | KW_BUCKETS:id
    {: RESULT = id; :}
    | KW_FILE:id
    {: RESULT = id; :}
    | KW_FIRST:id
    {: RESULT = id; :}
    | KW_FORMAT:id
    {: RESULT = id; :}
    | KW_HLL_UNION:id
    {: RESULT = id; :}
    | KW_PATH:id
    {: RESULT = id; :}
    | KW_FUNCTION:id
    {: RESULT = id; :}
    | KW_END:id
    {: RESULT = id; :}
    | KW_ENGINE:id
    {: RESULT = id; :}
    | KW_ENGINES:id
    {: RESULT = id; :}
    | KW_ERRORS:id
    {: RESULT = id; :}
    | KW_EVENTS:id
    {: RESULT = id; :}
    | KW_EXTERNAL:id
    {: RESULT = id; :}
    | KW_GLOBAL:id
    {: RESULT = id; :}
    | KW_HASH:id
    {: RESULT = id; :}
    | KW_HELP:id
    {: RESULT = id; :}
    | KW_HUB:id
    {: RESULT = id; :}
    | KW_IDENTIFIED:id
    {: RESULT = id; :}
    | KW_INDEXES:id
    {: RESULT = id; :}
    | KW_ISNULL:id
    {: RESULT = id; :}
    | KW_ISOLATION:id
    {: RESULT = id; :}
    | KW_LABEL:id
    {: RESULT = id; :}
    | KW_LAST:id
    {: RESULT = id; :}
    | KW_LESS:id
    {: RESULT = id; :}
    | KW_LEVEL:id
    {: RESULT = id; :}
    | KW_LIST:id
    {: RESULT = id; :}
    | KW_LOCAL:id
    {: RESULT = id; :}
    | KW_LOCATION:id
    {: RESULT = id; :}
    | KW_LOGICAL:id
    {: RESULT = id; :}
    | KW_MERGE:id
    {: RESULT = id; :}
    | KW_MODIFY:id
    {: RESULT = id; :}
    | KW_NAME:id
    {: RESULT = id; :}
    | KW_NAMES:id
    {: RESULT = id; :}
    | KW_NEGATIVE:id
    {: RESULT = id; :}
    | KW_NO:id
    {: RESULT = id; :}
    | KW_NULLS:id
    {: RESULT = id; :}
    | KW_OFFSET:id
    {: RESULT = id; :}
    | KW_ONLY:id
    {: RESULT = id; :}
    | KW_OPEN:id
    {: RESULT = id; :}
    | KW_PARTITIONS:id
    {: RESULT = id; :}
    | KW_PASSWORD:id
    {: RESULT = id; :}
    | KW_PERCENTILE:id
    {: RESULT = id; :}
    | KW_PERCENTILE_UNION:id
    {: RESULT = id; :}
    | KW_PLUGIN:id
    {: RESULT = id; :}
    | KW_PLUGINS:id
    {: RESULT = id; :}
    | KW_PROC:id
    {: RESULT = id; :}
    | KW_PROPERTIES:id
    {: RESULT = id; :}
    | KW_PROPERTY:id
    {: RESULT = id; :}
    | KW_QUERY:id
    {: RESULT = id; :}
    | KW_QUOTA:id
    {: RESULT = id; :}
    | KW_RECOVER:id
    {: RESULT = id; :}
    | KW_REPEATABLE:id
    {: RESULT = id; :}
    | KW_REPLACE_IF_NOT_NULL:id
    {: RESULT = id; :}
    | KW_REPOSITORY:id
    {: RESULT = id; :}
    | KW_REPOSITORIES:id
    {: RESULT = id; :}
    | KW_RESOURCE:id
    {: RESULT = id; :}
    | KW_RESOURCES:id
    {: RESULT = id; :}
    | KW_RESTORE:id
    {: RESULT = id; :}
    | KW_RETURNS:id
    {: RESULT = id; :}
    | KW_ROLE:id
    {: RESULT = id; :}
    | KW_ROLLBACK:id
    {: RESULT = id; :}
    | KW_ROLLUP:id
    {: RESULT = id; :}
    | KW_SCHEMA:id
    {: RESULT = id; :}
    | KW_SERIALIZABLE:id
    {: RESULT = id; :}
    | KW_SESSION:id
    {: RESULT = id; :}
    | KW_SNAPSHOT:id
    {: RESULT = id; :}
    | KW_SONAME:id
    {: RESULT = id; :}
    | KW_SPLIT:id
    {: RESULT = id; :}
    | KW_START:id
    {: RESULT = id; :}
    | KW_STATUS:id
    {: RESULT = id; :}
    | KW_STORAGE:id
    {: RESULT = id; :}
    | KW_STRING:id
    {: RESULT = id; :}
    | KW_TABLES:id
    {: RESULT = id; :}
    | KW_TEMPORARY:id
    {: RESULT = id; :}
    | KW_THAN:id
    {: RESULT = id; :}
    | KW_TIMESTAMP:id
    {: RESULT = id; :}
    | KW_TRANSACTION:id
    {: RESULT = id; :}
    | KW_TRIGGERS:id
    {: RESULT = id; :}
    | KW_TRUNCATE:id
    {: RESULT = id; :}
    | KW_TYPE:id
    {: RESULT = id; :}
    | KW_TYPES:id
    {: RESULT = id; :}
    | KW_UNCOMMITTED:id
    {: RESULT = id; :}
    | KW_USER:id
    {: RESULT = id; :}
    | KW_VARIABLES:id
    {: RESULT = id; :}
    | KW_VALUE:id
    {: RESULT = id; :}
    | KW_VERBOSE:id
    {: RESULT = id; :}
    | KW_VIEW:id
    {: RESULT = id; :}
    | KW_WARNINGS:id
    {: RESULT = id; :}
    | KW_WORK:id
    {: RESULT = id; :}
    | KW_CLUSTER:id
    {: RESULT = id; :}
    | KW_CLUSTERS:id
    {: RESULT = id; :}
    | KW_LINK:id
    {: RESULT = id; :}
    | KW_COUNT:id
    {: RESULT = id; :}
    | KW_SUM:id
    {: RESULT = id; :}
    | KW_MIN:id
    {: RESULT = id; :}
    | KW_MAX:id
    {: RESULT = id; :}
    | KW_FREE:id
    {: RESULT = id; :}
    | KW_TASK:id
    {: RESULT = id; :}
    | KW_ROUTINE:id
    {: RESULT = id; :}
    | KW_PAUSE:id
    {: RESULT = id; :}
    | KW_RESUME:id
    {: RESULT = id; :}
    | KW_STOP:id
    {: RESULT = id; :}
    | KW_GROUPING:id
    {: RESULT = id; :}
    | KW_DYNAMIC:id
    {: RESULT = id; :}
    | time_unit:id
    {: RESULT = id; :}
    | KW_FN:id
    {: RESULT = id; :}
    | KW_DATABASE:id
    {: RESULT = id; :}
    | KW_CURRENT_USER:id
    {: RESULT = id; :}
    | KW_REPLACE:id
    {: RESULT = id; :}
    | KW_CHAR:id
    {: RESULT = id; :}
    | KW_CURRENT_TIMESTAMP:id
    {: RESULT = id; :}
    ;

// Identifier that contain keyword
ident ::=
    IDENT:id
    {:
        RESULT = id;
    :}
    | keyword:id
    {:
        RESULT = id;
    :}
    ;

// Identifier or text
ident_or_text ::=
    ident:id
    {:
        RESULT = id;
    :}
    | STRING_LITERAL:text
    {:
        RESULT = text;
    :}
    ;

time_unit ::=
    KW_YEAR:id
    {: RESULT = id; :}
    | KW_MONTH:id
    {: RESULT = id; :}
    | KW_WEEK:id
    {: RESULT = id; :}
    | KW_DAY:id
    {: RESULT = id; :}
    | KW_HOUR:id
    {: RESULT = id; :}
    | KW_MINUTE:id
    {: RESULT = id; :}
    | KW_SECOND:id
    {: RESULT = id; :}
    ;
