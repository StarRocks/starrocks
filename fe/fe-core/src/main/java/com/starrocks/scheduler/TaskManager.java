// This file is licensed under the Elastic License 2.0. Copyright 2021-present, StarRocks Limited.

package com.starrocks.scheduler;


import com.clearspring.analytics.util.Lists;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.google.common.collect.Queues;
import com.google.gson.annotations.SerializedName;
import com.starrocks.catalog.Column;
import com.starrocks.catalog.ScalarType;
import com.starrocks.common.Config;
import com.starrocks.common.DdlException;
import com.starrocks.common.io.Text;
import com.starrocks.common.util.QueryableReentrantLock;
import com.starrocks.common.util.Util;
import com.starrocks.persist.gson.GsonUtils;
import com.starrocks.qe.ConnectContext;
import com.starrocks.qe.ShowResultSet;
import com.starrocks.qe.ShowResultSetMetaData;
import com.starrocks.scheduler.persist.TaskRunStatus;
import com.starrocks.scheduler.persist.TaskRunStatusChange;
import com.starrocks.server.GlobalStateMgr;
import com.starrocks.sql.ast.SubmitTaskStmt;
import com.starrocks.statistic.Constants;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;

public class TaskManager {

    private static final Logger LOG = LogManager.getLogger(TaskManager.class);

    public static final long TASK_EXISTS = -1L;
    public static final long DUPLICATE_CREATE_TASK = -2L;
    public static final long GET_TASK_LOCK_FAILED = -3L;

    // taskId -> Task , Task may have Manual Task, Periodical Task
    // every TaskRun must be generated by a Task
    private final Map<Long, Task> manualTaskMap;
    // taskName -> Task, include Manual Task, Periodical Task
    private final Map<String, Task> nameToTaskMap;

    // include PENDING/RUNNING taskRun;
    private final TaskRunManager taskRunManager;

    // The dispatchTaskScheduler is responsible for periodically checking whether the running TaskRun is completed
    // and updating the status. It is also responsible for placing pending TaskRun in the running TaskRun queue.
    // This operation need to consider concurrency.
    // This scheduler can use notify/wait to optimize later.
    private final ScheduledExecutorService dispatchScheduler = Executors.newScheduledThreadPool(1);

    // Use to concurrency control
    private final QueryableReentrantLock lock;

    private AtomicBoolean isStart = new AtomicBoolean(false);

    public TaskManager() {
        manualTaskMap = Maps.newConcurrentMap();
        nameToTaskMap = Maps.newConcurrentMap();
        taskRunManager = new TaskRunManager();
        lock = new QueryableReentrantLock(true);
    }

    public void start() {
        if (isStart.compareAndSet(false, true)) {
            clearUnfinishedTaskRun();
            dispatchScheduler.scheduleAtFixedRate(() -> {
                if (!tryLock()) {
                    return;
                }
                try {
                    taskRunManager.checkRunningTaskRun();
                    taskRunManager.scheduledPendingTaskRun();
                } catch (Exception ex) {
                    LOG.warn("failed to dispatch job.", ex);
                } finally {
                    unlock();
                }
            }, 0, 1, TimeUnit.SECONDS);
        }
    }

    private void clearUnfinishedTaskRun() {
        if (!tryLock()) {
            return;
        }
        try {
            Iterator<Long> pendingIter = taskRunManager.getPendingTaskRunMap().keySet().iterator();
            while (pendingIter.hasNext()) {
                Queue<TaskRun> taskRuns = taskRunManager.getPendingTaskRunMap().get(pendingIter.next());
                for (TaskRun taskRun : taskRuns) {
                    taskRun.getStatus().setErrorMessage("Fe restart abort the task");
                    taskRun.getStatus().setErrorCode(-1);
                    taskRun.getStatus().setState(Constants.TaskRunState.FAILED);
                    taskRunManager.getTaskRunHistory().addHistory(taskRun.getStatus());
                }
                pendingIter.remove();
            }
            // will not happen, but defensive programming
            Iterator<Long> runningIter = taskRunManager.getRunningTaskRunMap().keySet().iterator();
            while (runningIter.hasNext()) {
                TaskRun taskRun = taskRunManager.getRunningTaskRunMap().get(runningIter.next());
                taskRun.getStatus().setErrorMessage("Fe restart abort the task");
                taskRun.getStatus().setErrorCode(-1);
                taskRun.getStatus().setState(Constants.TaskRunState.FAILED);
                runningIter.remove();
                taskRunManager.getTaskRunHistory().addHistory(taskRun.getStatus());
            }
        } finally {
            unlock();
        }
    }

    public long createTask(Task task, boolean isReplay) {
        if (!tryLock()) {
            return GET_TASK_LOCK_FAILED;
        }
        try {
            if (nameToTaskMap.containsKey(task.getName())) {
                return TASK_EXISTS;
            }
            nameToTaskMap.put(task.getName(), task);
            if (manualTaskMap.containsKey(task.getId())) {
                return DUPLICATE_CREATE_TASK;
            }
            manualTaskMap.put(task.getId(), task);
            if (!isReplay) {
                GlobalStateMgr.getCurrentState().getEditLog().logCreateTask(task);
            }
            return task.getId();
        } finally {
            unlock();
        }
    }

    public SubmitResult executeTask(String taskName) {
        Task task = nameToTaskMap.get(taskName);
        if (task == null) {
            return new SubmitResult(null, SubmitResult.SubmitStatus.FAILED);
        }
        return taskRunManager.submitTaskRun(TaskRunBuilder.newBuilder(task).build());
    }

    public void dropTasks(List<Long> taskIdList, boolean isReplay) {
        if (!tryLock()) {
            return;
        }
        try {
            for (long taskId : taskIdList) {
                Task task = manualTaskMap.get(taskId);
                if (task == null) {
                    LOG.warn("drop taskId {} failed because task is null", taskId);
                    continue;
                }
                nameToTaskMap.remove(task.getName());
                manualTaskMap.remove(task.getId());
            }

            if (!isReplay) {
                GlobalStateMgr.getCurrentState().getEditLog().logDropTasks(taskIdList);
            }
        } finally {
            unlock();
        }
        LOG.info("drop tasks:{}", taskIdList);
    }

    public List<Task> showTasks(String dbName) {
        List<Task> taskList = Lists.newArrayList();
        if (dbName == null) {
            taskList.addAll(manualTaskMap.values());
        } else {
            taskList.addAll(manualTaskMap.values().stream()
                    .filter(u -> u.getDbName().equals(dbName)).collect(Collectors.toList()));
        }
        return taskList;
    }

    private boolean tryLock() {
        try {
            if (!lock.tryLock(1, TimeUnit.SECONDS)) {
                Thread owner = lock.getOwner();
                if (owner != null) {
                    LOG.warn("task lock is held by: {}", Util.dumpThread(owner, 50));
                } else {
                    LOG.warn("task lock owner is null");
                }
                return false;
            }
            return true;
        } catch (InterruptedException e) {
            LOG.warn("got exception while getting task lock", e);
        }
        return lock.isHeldByCurrentThread();
    }

    private void unlock() {
        this.lock.unlock();
    }

    public void replayCreateTask(Task task) {
        if ((System.currentTimeMillis() - task.getCreateTime()) / 1000 > Config.label_keep_max_second) {
            return;
        }
        createTask(task, true);
    }

    public void replayDropTasks(List<Long> taskIdList) {
        dropTasks(taskIdList, true);
    }

    public TaskRunManager getTaskRunManager() {
        return taskRunManager;
    }

    public ShowResultSet handleSubmitTaskStmt(SubmitTaskStmt submitTaskStmt) throws DdlException {
        Task task = TaskBuilder.buildTask(submitTaskStmt, ConnectContext.get());
        long createResult = createTask(task, false);

        String taskName = task.getName();
        if (createResult < 0) {
            if (createResult == TASK_EXISTS) {
                throw new DdlException("Task " +  taskName + " already exist.");
            }
            throw new DdlException("Failed to create Task: " +  taskName + ", ErrorCode: " + createResult);
        }
        SubmitResult submitResult = executeTask(taskName);
        if (submitResult.getStatus() != SubmitResult.SubmitStatus.SUBMITTED) {
            dropTasks(ImmutableList.of(task.getId()), false);
        }

        ShowResultSetMetaData.Builder builder = ShowResultSetMetaData.builder();
        builder.addColumn(new Column("TaskName", ScalarType.createVarchar(40)));
        builder.addColumn(new Column("Status", ScalarType.createVarchar(10)));
        List<String> item = ImmutableList.of(taskName, submitResult.getStatus().toString());
        List<List<String>> result = ImmutableList.of(item);
        return new ShowResultSet(builder.build(), result);
    }

    public long loadTasks(DataInputStream dis, long checksum) throws IOException {
        int taskCount = 0;
        try {
            String s = Text.readString(dis);
            SerializeData data = GsonUtils.GSON.fromJson(s, SerializeData.class);
            if (data != null) {
                if (data.tasks != null) {
                    for (Task task : data.tasks) {
                        replayCreateTask(task);
                    }
                    taskCount = data.tasks.size();
                }

                if (data.runStatus != null) {
                    for (TaskRunStatus runStatus : data.runStatus) {
                        replayCreateTaskRun(runStatus);
                    }
                }
            }
            checksum ^= taskCount;
            LOG.info("finished replaying TaskManager from image");
        } catch (EOFException e) {
            LOG.info("no TaskManager to replay.");
        }
        return checksum;
    }

    public long saveTasks(DataOutputStream dos, long checksum) throws IOException {
        SerializeData data = new SerializeData();
        data.tasks = new ArrayList<>(nameToTaskMap.values());
        checksum ^= data.tasks.size();
        data.runStatus = showTaskRunStatus(null);
        String s = GsonUtils.GSON.toJson(data);
        Text.writeString(dos, s);
        return checksum;
    }

    public List<TaskRunStatus> showTaskRunStatus(String dbName) {
        List<TaskRunStatus> taskRunList = Lists.newArrayList();
        if (dbName == null) {
            for (Queue<TaskRun> pTaskRunQueue : taskRunManager.getPendingTaskRunMap().values()) {
                taskRunList.addAll(pTaskRunQueue.stream().map(TaskRun::getStatus).collect(Collectors.toList()));
            }
            taskRunList.addAll(taskRunManager.getRunningTaskRunMap().values().stream().map(TaskRun::getStatus)
                    .collect(Collectors.toList()));
            taskRunList.addAll(taskRunManager.getTaskRunHistory().getAllHistory());
        } else {
            for (Queue<TaskRun> pTaskRunQueue : taskRunManager.getPendingTaskRunMap().values()) {
                taskRunList.addAll(pTaskRunQueue.stream().map(TaskRun::getStatus)
                        .filter(u -> u.getDbName().equals(dbName)).collect(Collectors.toList()));
            }
            taskRunList.addAll(taskRunManager.getRunningTaskRunMap().values().stream().map(TaskRun::getStatus)
                    .filter(u -> u.getDbName().equals(dbName)).collect(Collectors.toList()));
            taskRunList.addAll(taskRunManager.getTaskRunHistory().getAllHistory().stream()
                    .filter(u -> u.getDbName().equals(dbName)).collect(Collectors.toList()));

        }
        return taskRunList;
    }

    public void replayCreateTaskRun(TaskRunStatus status) {

        if (status.getState() == Constants.TaskRunState.SUCCESS ||
                status.getState() == Constants.TaskRunState.FAILED) {
            long lastUpdateTime = status.getCreateTime();
            if (status.getFinishTime() > lastUpdateTime) {
                lastUpdateTime = status.getFinishTime();
            }
            if ((System.currentTimeMillis() - lastUpdateTime) / 1000 > Config.label_keep_max_second) {
                return;
            }
        }

        switch (status.getState()) {
            case PENDING:
                String taskName = status.getTaskName();
                Task task = nameToTaskMap.get(taskName);
                if (task == null) {
                    LOG.warn("fail to obtain task name {} because task is null", taskName);
                    return;
                }
                TaskRun taskRun = TaskRunBuilder.newBuilder(task).build();
                taskRun.initStatus(status.getQueryId(), status.getCreateTime());
                Queue<TaskRun> taskRuns = taskRunManager.getPendingTaskRunMap().computeIfAbsent(taskRun.getTaskId(),
                        u -> Queues.newConcurrentLinkedQueue());
                taskRuns.offer(taskRun);
                break;
            // this will happen in build image
            case RUNNING:
                status.setState(Constants.TaskRunState.FAILED);
                taskRunManager.getTaskRunHistory().addHistory(status);
                break;
            case FAILED:
            case SUCCESS:
                taskRunManager.getTaskRunHistory().addHistory(status);
                break;
        }
    }

    public void replayUpdateTaskRun(TaskRunStatusChange statusChange) {
        Constants.TaskRunState toStatus = statusChange.getToStatus();
        Long taskId = statusChange.getTaskId();
        Queue<TaskRun> taskRunQueue = taskRunManager.getPendingTaskRunMap().get(taskId);
        if (taskRunQueue != null) {
            if (taskRunQueue.size() == 0) {
                taskRunManager.getPendingTaskRunMap().remove(taskId);
                return;
            }

            TaskRun pendingTaskRun = taskRunQueue.poll();
            TaskRunStatus status = pendingTaskRun.getStatus();
            if (status.getQueryId().equals(statusChange.getQueryId())) {
                if (toStatus == Constants.TaskRunState.FAILED) {
                    status.setErrorMessage(statusChange.getErrorMessage());
                    status.setErrorCode(statusChange.getErrorCode());
                }
                status.setState(toStatus);
                status.setFinishTime(statusChange.getFinishTime());
                taskRunManager.getTaskRunHistory().addHistory(status);
            }
        }
    }

    public void replayDropTaskRuns(List<String> queryIdList) {
        Map<String, String> index = Maps.newHashMapWithExpectedSize(queryIdList.size());
        for (String queryId : queryIdList) {
            index.put(queryId, null);
        }
        taskRunManager.getTaskRunHistory().getAllHistory().removeIf(runStatus -> index.containsKey(runStatus.getQueryId()));
    }

    public void removeOldTaskInfo() {
        long currentTimeMs = System.currentTimeMillis();

        List<Task> currentTask = showTasks(null);
        List<Long> taskIdToDelete = Lists.newArrayList();
        currentTask.sort((o1, o2) -> Long.signum(o1.getCreateTime() - o2.getCreateTime()));
        int labelKeepMaxSecond = Config.label_keep_max_second;
        int numTaskToRemove = currentTask.size() - Config.label_keep_max_num;
        for (Task task : currentTask) {
            if ((currentTimeMs - task.getCreateTime()) / 1000 > labelKeepMaxSecond ||
                    numTaskToRemove > 0) {
                taskIdToDelete.add(task.getId());
                --numTaskToRemove;
            }
        }
        // this will do in checkpoint and does not need write log
        dropTasks(taskIdToDelete, true);
    }

    public void removeOldTaskRunHistory() {
        long currentTimeMs = System.currentTimeMillis();

        Deque<TaskRunStatus> taskRunHistory = taskRunManager.getTaskRunHistory().getAllHistory();
        List<String> historyToDelete = Lists.newArrayList();

        if (!tryLock()) {
            return;
        }
        try {
            int labelKeepMaxSecond = Config.label_keep_max_second;
            int numHistoryToRemove = taskRunHistory.size() - Config.label_keep_max_num;
            for (TaskRunStatus runStatus : taskRunHistory) {
                // task run may run for a long time and then failed
                // there may be no finish time when it fails
                long lastUpdateTime = runStatus.getCreateTime();
                if (runStatus.getFinishTime() > lastUpdateTime) {
                    lastUpdateTime = runStatus.getFinishTime();
                }
                if ((currentTimeMs - lastUpdateTime) / 1000 > labelKeepMaxSecond ||
                        numHistoryToRemove > 0) {
                    historyToDelete.add(runStatus.getQueryId());
                    taskRunHistory.remove();
                    --numHistoryToRemove;
                }
            }
        } finally {
            unlock();
        }
        LOG.info("remove run history:{}", historyToDelete);
    }


    private static class SerializeData {
        @SerializedName("tasks")
        public List<Task> tasks;

        @SerializedName("runStatus")
        public List<TaskRunStatus> runStatus;
    }

}
