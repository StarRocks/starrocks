// Copyright 2021-present StarRocks, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.starrocks.sql.ast;

import com.starrocks.analysis.ColumnPosition;
import com.starrocks.analysis.ParseNode;
import com.starrocks.analysis.TypeDef;
import com.starrocks.catalog.ArrayType;
import com.starrocks.catalog.Column;
import com.starrocks.catalog.ScalarType;
import com.starrocks.catalog.StructField;
import com.starrocks.catalog.StructType;
import com.starrocks.catalog.Type;
import com.starrocks.common.AnalysisException;
import com.starrocks.sql.parser.NodePosition;

import java.util.List;

public class StructFieldDesc implements ParseNode {
    /**
     * Struct field description which is generated by SQL syntax parser
     * User can add a new struct field into a struct column or drop an exist struct field
     * Syntax:
     *      name type (FIRST | AFTER fieldName)
     *  note:
     *      not support not null
     *      not support default value
     * |fieldName| : new added field name or target drop field name
     * |nestedParentFieldNames| : the nested parent field names
     * |typeDef| : the type definition for new added field (null in drop field)
     * |fieldPos| : the field position for new added field (null in drop field)
     *  
     * Example:
     *      c1 is a struct column and definiton is STRUCT<v1 INT, v2 STRUCT<v3, v4>>
     *      1. modify column c1 add field v2.v5 int after v1 
     *          |fieldName|: v5
     *          |nestParentFieldNames|: {v2}
     *          |typeDef|: type int
     *          |fieldPos| : after v1
     *      2. modify column c1 drop field v2.v3
     *          |fieldName| : v3
     *          |nestedParentFieldNames|: {v2}
     *          |typeDef|: null
     *          |fieldPos|: null
     */
    private final String fieldName;
    private final List<String> nestedParentFieldNames;
    private final TypeDef typeDef;
    private final ColumnPosition fieldPos;

    public StructFieldDesc(String fieldName, List<String> nestedParentFieldNames, TypeDef typeDef, ColumnPosition fieldPos) {
        this.fieldName = fieldName;
        this.nestedParentFieldNames = nestedParentFieldNames;
        this.typeDef = typeDef;
        this.fieldPos = fieldPos;
    }

    @Override
    public NodePosition getPos() {
        return null;
    }

    private boolean checkType(Type type) {
        if (type.isStructType() || type.isArrayType()) {
            return true;
        }
        return false;
    }

    private Type getFieldType(Type type, String fieldName) {
        if (type.isStructType()) {
            StructField field = ((StructType) type).getField(fieldName);
            if (field == null) {
                return null;
            }
            return field.getType();
        }

        if (type.isArrayType()) {
            return ((ArrayType) type).getItemType();
        }

        return null;
    }

    public List<String> getNestedParentFieldNames() {
        return nestedParentFieldNames;
    }

    public String getFieldName() {
        return fieldName;
    }

    public Type getType() {
        return typeDef.getType();
    }

    public ColumnPosition getFieldPos() {
        return fieldPos;
    }

    public void analyze(Column baseCol, boolean dropField) throws AnalysisException {
        if (baseCol == null) {
            throw new AnalysisException(String.format("Analyze add/drop field failed, modify column is not exist"));
        }

        Type targetFieldType = baseCol.getType();
        if (!checkType(targetFieldType)) {
            throw new AnalysisException(
                    String.format("column %s type %s is not Struct", baseCol.getName(), targetFieldType.toString()));
        }

        if (nestedParentFieldNames != null && !nestedParentFieldNames.isEmpty()) {
            for (String name : nestedParentFieldNames) {
                targetFieldType = getFieldType(targetFieldType, name);
                if (targetFieldType == null) {
                    throw new AnalysisException(
                        String.format("No field %s exist in column %s", name, baseCol.getName()));
                }
                if (!checkType(targetFieldType)) {
                    throw new AnalysisException(
                        String.format("Field %s type %s is not valid", name, targetFieldType.toString()));
                }
            }
        }

        if (!targetFieldType.isStructType()) {
            throw new AnalysisException("Target Field is not struct");
        }

        StructField childField = ((StructType) targetFieldType).getField(fieldName);
        if (dropField) {
            if (childField == null) {
                throw new AnalysisException(String.format("Drop field %s is not found", fieldName));
            }
        } else {
            if (childField != null) {
                throw new AnalysisException(String.format("Field %s is already exist", fieldName));
            }

            if (typeDef == null) {
                throw new AnalysisException("No filed type in field definition");
            }
            if (typeDef.getType().isScalarType()) {
                final ScalarType targetType = (ScalarType) typeDef.getType();
                if (targetType.getPrimitiveType().isStringType()) {
                    if (targetType.getLength() <= 0) {
                        targetType.setLength(1);
                    }
                }
            }
            typeDef.analyze();
            if (fieldPos != null) {
                fieldPos.analyze();
            }
        }
    }
}