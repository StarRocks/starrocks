// This file is licensed under the Elastic License 2.0. Copyright 2021 StarRocks Limited.

package com.starrocks.sql.optimizer;

import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.starrocks.common.Pair;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

/**
 * The space of plan alternatives generated by the optimizer is encoded in
 * a compact in-memory data structure called the Memo.
 * <p>
 * Memo Provides memoization, duplicate detection, and property + cost management.
 * <p>
 * This is key component of our optimizer. We utilize
 * dynamic programing to search optimal query plan. When
 * searching, sub-problem's result is needed to be stored.
 * We store all GroupExpression that have been searched in this struct.
 * <p>
 * Memo store all GroupExpression in a hash set,
 * which is efficient to look up if there is already GroupExpression.
 * <p>
 * All the group should be created from this class.
 */
public class Memo {
    private static final Logger LOG = LogManager.getLogger(Memo.class);

    private int nextGroupId = 0;

    // The group id is same with the group index in groups List
    private final List<Group> groups;

    private Group rootGroup;
    /**
     * The map value is root group id for the GroupExpression.
     * We need to store group id because when {@see insertGroupExpression}
     * we need to get existed group id for tmp GroupExpression,
     * which doesn't have group id info
     */
    private final Map<GroupExpression, GroupExpression> groupExpressions;

    public List<Group> getGroups() {
        return groups;
    }

    public Map<GroupExpression, GroupExpression> getGroupExpressions() {
        return groupExpressions;
    }

    public Memo() {
        groups = Lists.newLinkedList();
        groupExpressions = Maps.newHashMap();
    }

    public Group getRootGroup() {
        return rootGroup;
    }

    /**
     * Copy an expression into search space, this function will add an GroupExpression for
     * this Expression. If this Expression has children, this function will be called
     * recursively to create GroupExpression and Group for every single Expression
     * For example, Join(Scan(A), Scan(B)) will create 3 Groups and GroupExpressions for Join,
     * Scan(A) and Scan(B).
     * We return GroupExpression rather than Group because we can get Group from GroupExpression
     */
    public GroupExpression init(OptExpression originExpression) {
        Preconditions.checkState(groups.size() == 0);
        Preconditions.checkState(groupExpressions.size() == 0);
        GroupExpression rootGroupExpression = copyIn(null, originExpression).second;
        rootGroup = rootGroupExpression.getGroup();
        return rootGroupExpression;
    }

    public Pair<Boolean, GroupExpression> insertGroupExpression(GroupExpression groupExpression, Group targetGroup) {
        if (groupExpressions.get(groupExpression) != null) {
            GroupExpression existedGroupExpression = groupExpressions.get(groupExpression);
            Group existedGroup = existedGroupExpression.getGroup();

            if (needMerge(targetGroup, existedGroup)) {
                mergeGroup(existedGroup, targetGroup);
            }

            return new Pair<>(false, existedGroupExpression);
        }

        if (targetGroup == null) {
            targetGroup = newGroup();
            groups.add(targetGroup);
        }

        groupExpressions.put(groupExpression, groupExpression);

        targetGroup.addExpression(groupExpression);

        return new Pair<>(true, groupExpression);
    }

    /**
     * Insert an enforce expression into the target group.
     */
    public void insertEnforceExpression(GroupExpression groupExpression, Group targetGroup) {
        groupExpression.setGroup(targetGroup);
    }

    private Group newGroup() {
        return new Group(nextGroupId++);
    }

    public Pair<Boolean, GroupExpression> copyIn(Group targetGroup, OptExpression expression) {
        List<Group> inputs = Lists.newArrayList();
        for (OptExpression input : expression.getInputs()) {
            Group group;
            if (input.getGroupExpression() != null) {
                group = input.getGroupExpression().getGroup();
            } else {
                group = copyIn(null, input).second.getGroup();
            }
            Preconditions.checkState(group != null);
            Preconditions.checkState(group != targetGroup);
            inputs.add(group);
        }

        GroupExpression groupExpression = new GroupExpression(expression.getOp(), inputs);
        Pair<Boolean, GroupExpression> result = insertGroupExpression(groupExpression, targetGroup);
        if (result.first && targetGroup == null) {
            // For new group, we need drive property from expression
            // add set it to new group
            Preconditions.checkState(result.second.getOp().isLogical());
            result.second.deriveLogicalPropertyItself();

            // For multi join reorder,
            // We have derived statistics In ReorderJoinRule
            result.second.getGroup().setStatistics(expression.getStatistics());
        }
        return result;
    }

    private boolean needMerge(Group targetGroup, Group existedGroup) {
        return targetGroup != null && targetGroup != existedGroup;
    }

    // Merge srcGroup to dstGroup, srcGroup will be deleted
    private void mergeGroup(Group srcGroup, Group dstGroup) {
        groups.remove(srcGroup);

        // Reset root group, rewrite rule maybe eliminate the root group
        if (srcGroup == rootGroup) {
            rootGroup = dstGroup;
        }

        // If we change the GroupExpression child group, the hash value of GroupExpression
        // will change, so we must reinsert the GroupExpression to groupExpressions map
        List<GroupExpression> needReinsertedExpressions = Lists.newArrayList();
        for (Iterator<Map.Entry<GroupExpression, GroupExpression>>
                iterator = groupExpressions.entrySet().iterator(); iterator.hasNext(); ) {
            GroupExpression groupExpr = iterator.next().getKey();

            // 1 Find which group expression need to reinsert
            int referSrcGroupIndex = -1;
            for (int i = 0; i < groupExpr.getInputs().size(); i++) {
                if (groupExpr.getInputs().get(i) == srcGroup) {
                    referSrcGroupIndex = i;
                    break;
                }
            }

            // 2 Remove the GroupExpression from the groupExpressions map
            // 3 Change the child group from srcGroup to dstGroup
            if (referSrcGroupIndex >= 0) {
                iterator.remove();
                groupExpr.getInputs().set(referSrcGroupIndex, dstGroup);
                needReinsertedExpressions.add(groupExpr);
            }

            // 4 Change the group of GroupExpression
            if (groupExpr.getGroup() == srcGroup) {
                groupExpr.setGroup(dstGroup);
            }
        }

        for (GroupExpression groupExpression : needReinsertedExpressions) {
            if (!groupExpressions.containsKey(groupExpression)) {
                groupExpressions.put(groupExpression, groupExpression);
            }
        }

        dstGroup.mergeGroup(srcGroup);

        // When some rule merge two groups to one group, or
        // the GroupExpressions of one group are all removed.
        // The group is empty, We should remove it.
        List<Group> groups = getAllEmptyGroups();
        for (Group group : groups) {
            removeOneGroup(group);
        }
    }

    private List<Group> getAllEmptyGroups() {
        List<Group> groups = Lists.newArrayList();
        for (Group group : getGroups()) {
            if (group.isEmpty()) {
                groups.add(group);
                continue;
            }
            for (Group childGroup : group.getFirstLogicalExpression().getInputs()) {
                if (childGroup.isEmpty()) {
                    groups.add(childGroup);
                    break;
                }
            }
        }
        return groups;
    }

    public void removeAllEmptyGroup() {
        List<Group> groups = getAllEmptyGroups();
        while (!groups.isEmpty()) {
            for (Group group : groups) {
                removeOneGroup(group);
            }
            groups = getAllEmptyGroups();
        }
    }

    private void removeOneGroup(Group group) {
        groups.remove(group);

        for (Iterator<Map.Entry<GroupExpression, GroupExpression>>
                iterator = groupExpressions.entrySet().iterator(); iterator.hasNext(); ) {
            GroupExpression groupExpr = iterator.next().getKey();
            if (groupExpr.getGroup() == group) {
                iterator.remove();
                continue;
            }
            for (int i = 0; i < groupExpr.getInputs().size(); i++) {
                if (groupExpr.getInputs().get(i) == group) {
                    groupExpr.getGroup().removeGroupExpression(groupExpr);
                    iterator.remove();
                    break;
                }
            }
        }
    }

    private void deepSearchGroup(Group root, LinkedList<Integer> touch) {
        for (Group group : root.getFirstLogicalExpression().getInputs()) {
            touch.add(group.getId());
            deepSearchGroup(group, touch);
        }
    }

    /**
     * When performing replaceRewriteExpression, some groups may not be reachable by rootGroup.
     * These groups should be replaced.
     * In order to reduce the number of groups entering Memo,
     * we will delete inaccessible groups in this function.
     */
    public void removeUnreachableGroup() {
        LinkedList<Integer> touch = new LinkedList<>();
        touch.add(rootGroup.getId());
        deepSearchGroup(rootGroup, touch);

        List<Group> groupsCopy = new ArrayList<>(groups);
        for (Group group : groupsCopy) {
            if (!touch.contains(group.getId())) {
                removeOneGroup(group);
            }
        }
    }

    // For rewrite rule, we directly replace the old group expression by new expression
    public void replaceRewriteExpression(Group targetGroup, OptExpression expression) {
        removeGroupInitLogicExpression(targetGroup);
        GroupExpression groupExpression = copyIn(targetGroup, expression).second;

        // For group has rewritten, we need drive property from expression again
        groupExpression.deriveLogicalPropertyItself();
    }

    private void removeGroupInitLogicExpression(Group group) {
        GroupExpression initGroupExpression = group.getFirstLogicalExpression();
        groupExpressions.remove(initGroupExpression);

        Preconditions.checkState(group.isValidInitState());

        group.getLogicalExpressions().clear();
    }

    public void deriveAllGroupLogicalProperty() {
        getRootGroup().getFirstLogicalExpression().deriveLogicalPropertyRecursively();
    }
}
