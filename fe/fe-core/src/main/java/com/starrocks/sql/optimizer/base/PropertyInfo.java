// This file is licensed under the Elastic License 2.0. Copyright 2021-present, StarRocks Limited.

package com.starrocks.sql.optimizer.base;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

import java.util.List;
import java.util.Map;

// Property information for hash distribution desc, it used for check DistributionSpec satisfy condition.
public final class PropertyInfo {
    private long tableId = -1;
    private boolean isReplicate = false;
    private List<Long> partitionIds = Lists.newArrayList();
    // record nullable columns generated by outer join
    private ColumnRefSet nullableColumns = new ColumnRefSet();
    // col -> all equivalent join columns
    // For example, if A.a, B.b and C.c are equivalent, then we have three key value paris
    // A.a -> [A.a, B.b, C.c]
    // B.b -> [A.a, B.b, C.c]
    // C.c -> [A.a, B.b, C.c]
    private final Map<Integer, ColumnRefSet> joinEquivalentColumns = Maps.newHashMap();

    public boolean isSinglePartition() {
        return getPartitionIds().size() == 1;
    }

    public boolean isEmptyPartition() {
        return getPartitionIds().size() == 0;
    }

    public void addJoinEquivalentPair(int leftColumn, int rightColumn) {
        ColumnRefSet leftColumns;
        ColumnRefSet rightColumns;
        leftColumns = joinEquivalentColumns.get(leftColumn);
        rightColumns = joinEquivalentColumns.get(rightColumn);
        ColumnRefSet columns;
        if (leftColumns == null && rightColumns == null) {
            columns = new ColumnRefSet();
            joinEquivalentColumns.put(leftColumn, columns);
            joinEquivalentColumns.put(rightColumn, columns);
        } else if (leftColumns == null) {
            columns = rightColumns;
            joinEquivalentColumns.put(leftColumn, columns);
        } else if (rightColumns == null) {
            columns = leftColumns;
            joinEquivalentColumns.put(rightColumn, columns);
        } else {
            leftColumns.union(rightColumns);
            columns = leftColumns;
            joinEquivalentColumns.put(rightColumn, columns);
        }
        columns.union(leftColumn);
        columns.union(rightColumn);
    }

    public boolean isEquivalentJoinOnColumns(int leftColumn, int rightColumn) {
        if (joinEquivalentColumns.containsKey(leftColumn)) {
            return joinEquivalentColumns.get(leftColumn).contains(rightColumn);
        }
        return false;
    }

    public int[] getEquivalentJoinOnColumns(int column) {
        if (joinEquivalentColumns.containsKey(column)) {
            return joinEquivalentColumns.get(column).getColumnIds();
        } else {
            return new int[0];
        }
    }

    public ColumnRefSet getEquivalentColumns(int column) {
        // least equals self
        return joinEquivalentColumns.getOrDefault(column, new ColumnRefSet(column));
    }

    public long getTableId() {
        return tableId;
    }

    public void setTableId(long tableId) {
        this.tableId = tableId;
    }

    public void setReplicate(boolean replicate) {
        isReplicate = replicate;
    }

    public List<Long> getPartitionIds() {
        return partitionIds;
    }

    public void setPartitionIds(List<Long> partitionIds) {
        this.partitionIds = partitionIds;
    }

    public ColumnRefSet getNullableColumns() {
        return nullableColumns;
    }
}
