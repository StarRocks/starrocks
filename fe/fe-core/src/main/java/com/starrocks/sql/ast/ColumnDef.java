// Copyright 2021-present StarRocks, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is based on code available under the Apache license here:
//   https://github.com/apache/incubator-doris/blob/master/fe/fe-core/src/main/java/org/apache/doris/analysis/ColumnDef.java

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package com.starrocks.sql.ast;

import com.starrocks.catalog.AggregateType;
import com.starrocks.catalog.Type;
import com.starrocks.catalog.combinator.AggStateDesc;
import com.starrocks.sql.ast.expression.Expr;
import com.starrocks.sql.ast.expression.FunctionCallExpr;
import com.starrocks.sql.ast.expression.NullLiteral;
import com.starrocks.sql.ast.expression.StringLiteral;
import com.starrocks.sql.ast.expression.TypeDef;
import com.starrocks.sql.parser.NodePosition;

import java.util.ArrayList;

// Column definition which is generated by SQL syntax parser
// Syntax:
//      name type [key] [agg_type] [NULL | NOT NULL] [DEFAULT default_value] [comment]
// Example:
//      id bigint key NOT NULL DEFAULT "-1" "user id"
//      pv bigint sum NULL DEFAULT "-1" "page visit"
public class ColumnDef implements ParseNode {
    /*
     * User can set default value for a column
     * eg:
     *     k1 INT NOT NULL DEFAULT "10"
     *     k1 INT NULL
     *     k1 INT NULL DEFAULT NULL
     *
     * ColumnDef will be transformed to Column in Analysis phase, and in Column, default value is a String.
     * No matter does the user set the default value as NULL explicitly, or not set default value,
     * the default value in Column will be "null", so that StarRocks can not distinguish between "not set" and "set as null".
     *
     * But this is OK because Column has another attribute "isAllowNull".
     * If the column is not allowed to be null, and user does not set the default value,
     * even if default value saved in Column is null, the "null" value can not be loaded into this column,
     * so data correctness can be guaranteed.
     */
    public static class DefaultValueDef {
        public boolean isSet;
        public boolean hasArguments;
        public Expr expr;

        public DefaultValueDef(boolean isSet, Expr expr) {
            this(isSet, false, expr);
        }

        public DefaultValueDef(boolean isSet, boolean hasArgs, Expr expr) {
            this.isSet = isSet;
            this.hasArguments = hasArgs;
            // make expr always not null
            if (expr != null) {
                this.expr = expr;
            } else {
                this.expr = NullLiteral.create(Type.VARCHAR);
            }
        }

        private static final String ZERO = new String(new byte[] {0});
        // no default value
        public static DefaultValueDef NOT_SET = new DefaultValueDef(false, NullLiteral.create(Type.VARCHAR));
        // default null
        public static DefaultValueDef NULL_DEFAULT_VALUE = new DefaultValueDef(true, NullLiteral.create(Type.VARCHAR));
        // default "value", "0" means empty hll or bitmap
        public static DefaultValueDef EMPTY_VALUE = new DefaultValueDef(true, new StringLiteral(ZERO));
        // default value for date type CURRENT_TIMESTAMP
        public static DefaultValueDef CURRENT_TIMESTAMP_VALUE = new DefaultValueDef(true,
                new FunctionCallExpr("now", new ArrayList<>()));
    }



    // parameter initialized in constructor
    private final String name;
    private final TypeDef typeDef;
    private final String defaultCharset = "utf8";
    private String charsetName = defaultCharset;
    private AggregateType aggregateType;
    private AggStateDesc aggStateDesc;
    private boolean isKey;
    // Primary-key column should obey the not-null constraint. When creating a table, the not-null constraint will add to the primary-key column default. If the user specifies NULL explicitly, semantics analysis will report an error.
    // Now, isAllowNull is used to indicate a null constraint hold or not. Primary-key and non-primary-key columns obey different constraints, so the isAllowNull can not be assigned a default value.
    // Add a new variable name isAllowNullImplicit to indicate the message. If isAllowNullImplicit=true, it indicates the null constraint is obeyed implicitly.
    private boolean isAllowNullImplicit = false;
    private Boolean isAllowNull;
    private Boolean isAutoIncrement;
    private Expr generatedColumnExpr;
    private DefaultValueDef defaultValueDef;
    private final String comment;
    private boolean isPartitionColumn = false;

    private final NodePosition pos;

    public ColumnDef(String name, TypeDef typeDef) {
        this(name, typeDef, null, false, null, null, false, DefaultValueDef.NOT_SET,
                null, null, "", NodePosition.ZERO);
    }

    public ColumnDef(String name, TypeDef typeDef, Boolean isAllowNull) {
        this(name, typeDef, null, false, null, null, isAllowNull, DefaultValueDef.NOT_SET,
                null, null, "", NodePosition.ZERO);
    }

    public ColumnDef(String name, TypeDef typeDef, boolean isKey, AggregateType aggregateType, AggStateDesc aggStateDesc,
                     Boolean isAllowNull, DefaultValueDef defaultValueDef, String comment) {
        this(name, typeDef, null, isKey, aggregateType, aggStateDesc, isAllowNull, defaultValueDef,
                null, null, comment, NodePosition.ZERO);
    }

    public ColumnDef(String name, TypeDef typeDef, String charsetName, boolean isKey, AggregateType aggregateType,
                     AggStateDesc aggStateDesc,
                     Boolean isAllowNull, DefaultValueDef defaultValueDef, Boolean isAutoIncrement,
                     Expr generatedColumnExpr, String comment) {
        this(name, typeDef, charsetName, isKey, aggregateType, aggStateDesc, isAllowNull, defaultValueDef, isAutoIncrement,
                generatedColumnExpr, comment, NodePosition.ZERO);
    }

    public ColumnDef(String name, TypeDef typeDef, String charsetName, boolean isKey, AggregateType aggregateType,
                     AggStateDesc aggStateDesc, Boolean isAllowNull, DefaultValueDef defaultValueDef, Boolean isAutoIncrement,
                     Expr generatedColumnExpr, String comment, NodePosition pos) {
        this.pos = pos;
        this.name = name;
        this.typeDef = typeDef;
        if (charsetName == null) {
            this.charsetName = defaultCharset;
        } else {
            this.charsetName = charsetName;
        }
        this.isKey = isKey;
        this.aggregateType = aggregateType;
        this.aggStateDesc = aggStateDesc;
        if (isAllowNull == null) {
            this.isAllowNull = true;
            this.isAllowNullImplicit = true;
        } else {
            this.isAllowNull = isAllowNull;
            this.isAllowNullImplicit = false;
        }
        this.defaultValueDef = defaultValueDef;
        if (isAutoIncrement == null) {
            this.isAutoIncrement = false;
        } else {
            this.isAutoIncrement = true;
        }
        this.generatedColumnExpr = generatedColumnExpr;
        this.comment = comment;
    }

    public boolean isAllowNull() {
        return isAllowNull;
    }

    public void setAllowNull(Boolean allowNull) {
        isAllowNull = allowNull;
    }

    public boolean isAutoIncrement() {
        return isAutoIncrement;
    }

    public boolean isGeneratedColumn() {
        return generatedColumnExpr != null;
    }

    public Expr getGeneratedColumnExpr() {
        return generatedColumnExpr;
    }

    public Expr generatedColumnExpr() {
        return generatedColumnExpr.clone();
    }

    // The columns will obey NULL constraint if not specified. The primary key column should abide by the NOT NULL constraint default to be compatible with ANSI.
    // So add a new setPrimaryKeyNonNullable() to set isAllowNull to be true for primary key columns.
    public void setPrimaryKeyNonNullable() {
        if (isAllowNullImplicit) {
            this.isAllowNull = false;
        }
    }

    // only for test
    public String getDefaultValue() {
        if (defaultValueDef.expr instanceof StringLiteral) {
            return ((StringLiteral) defaultValueDef.expr).getValue();
        } else if (defaultValueDef.expr instanceof NullLiteral) {
            return null;
        }
        return null;
    }

    public DefaultValueDef getDefaultValueDef() {
        return defaultValueDef;
    }

    public String getName() {
        return name;
    }

    public AggregateType getAggregateType() {
        return aggregateType;
    }

    public void setAggregateType(AggregateType aggregateType) {
        this.aggregateType = aggregateType;
    }

    public String getCharsetName() {
        return charsetName;
    }

    public void setCharsetName(String charsetName) {
        this.charsetName = charsetName;
    }

    public boolean isKey() {
        return isKey;
    }

    public void setIsKey(boolean isKey) {
        this.isKey = isKey;
    }

    public void setIsPartitionColumn(boolean isPartitionColumn) {
        this.isPartitionColumn = isPartitionColumn;
    }

    public boolean isPartitionColumn() {
        return isPartitionColumn;
    }

    public TypeDef getTypeDef() {
        return typeDef;
    }

    public Type getType() {
        return typeDef.getType();
    }

    public AggStateDesc getAggStateDesc() {
        return aggStateDesc;
    }

    public String getComment() {
        return comment;
    }

    public String getDefaultCharset() {
        return defaultCharset;
    }

    @Override
    public String toSql() {
        StringBuilder sb = new StringBuilder();
        sb.append("`").append(name).append("` ");
        sb.append(typeDef.toSql()).append(" ");

        if (aggregateType != null) {
            sb.append(aggregateType.name()).append(" ");
        }

        if (!isAllowNull) {
            sb.append("NOT NULL ");
        } else {
            // should append NULL to make result can be executed right.
            sb.append("NULL ");
        }

        if (isAutoIncrement) {
            sb.append("AUTO_INCREMENT ");
        }

        if (isGeneratedColumn()) {
            sb.append("AS " + generatedColumnExpr.toSql() + " ");
        }

        if (defaultValueDef.isSet) {
            sb.append("DEFAULT ").append(toDefaultExpr(defaultValueDef.expr)).append(" ");
        }
        sb.append("COMMENT \"").append(comment).append("\"");

        return sb.toString();
    }

    @Override
    public NodePosition getPos() {
        return pos;
    }

    private String toDefaultExpr(Expr expr) {
        if (expr instanceof StringLiteral) {
            return "\"" + ((StringLiteral) expr).getValue() + "\"";
        } else if (expr instanceof NullLiteral) {
            return "NULL";
        } else if (expr instanceof FunctionCallExpr) {
            FunctionCallExpr functionCallExpr = (FunctionCallExpr) expr;
            return functionCallExpr.getFnName() + "()";
        }
        return "";
    }

    public boolean defaultValueIsNull() {
        return defaultValueDef.expr instanceof NullLiteral;
    }

    @Override
    public String toString() {
        return toSql();
    }
}
