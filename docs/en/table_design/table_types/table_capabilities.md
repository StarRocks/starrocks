---
displayed_sidebar: docs
---

# Capabilities of different table types

## Key columns and sort key

<table>
<thead>
<tr><th width= "10"> </th><th><strong>Primary Key</strong> <strong>table</strong></th><th><strong>Duplicate Key table</strong></th><th><strong>Aggregate table</strong></th><th><strong>Unique Key table</strong></th></tr>
</thead>
<tbody><tr><td><strong>Key columns and UNIQUE constraints</strong> </td><td>The primary key has the UNIQUE constraint and NOT NULL constraint. </td><td>The duplicate key does not have the UNIQUE constraint. </td><td>The aggregate key has the UNIQUE constraint. </td><td>The unique key has the UNIQUE constraint. </td></tr><tr><td><strong>Logical relationships between key columns and data changes</strong> <strong></strong> </td><td>If the primary key value of a new data row is the same as that of an existing data row in the table, unique constraint violation occurs. Then the new data row will replace the existing data row.<br />Compared to the Unique Key table, the Primary Key table has an enhanced underlying storage engine and therefore can replace the Unique Key table.</td><td>The duplicate key does not have the UNIQUE constraint. So, if the duplicate Key value of a new data row is the same as that of an existing data row in the table, both the new and old data rows are retained in the table. </td><td>If the aggregate Key value of a new data row is the same as that of an existing data row in the table, the new and old data rows will be aggregated based on the aggregate key and the aggregate functions of value columns. </td><td>If the unique key value of a new data row is the same as that of an existing data row in the table, the new data row will replace the existing data row.<br />The Unique Key table can be seen as an Aggregate table whose aggregate function is replace.</td></tr><tr><td><strong>Relationship between key columns and sort key</strong></td><td>Since v3.0.0, the sort key is decoupled from the primary key in the Primary Key table.</td><td>Since v3.3.0, the Duplicate Key tables support specifying sort keys using `ORDER BY`. If both `ORDER BY` and `DUPLICATE KEY` are used, then `ORDER BY` takes precedence.</td><td>Since v3.3.0, the sort key is decoupled from the aggregate key in the Aggregate table. The Aggregate table supports specifying the sort key using `ORDER BY` and specifying the aggregate key using `AGGREGATE KEY`. The columns in the sort key and the aggregate key need to be the same, but the order of the columns does not need to be the same.</td><td>Since v3.3.0, the sort key is decoupled from the unique key in the Unique Key table. The Unique Key table supports specifying the sort key using `ORDER BY` and specifying the unique key using `UNIQUE KEY`. The columns in the sort key and the unique key need to be the same, but the order of the columns does not need to be the same.</td></tr><tr><td><strong>Data types supported by key columns and sort key</strong>  </td><td>Numeric (including integers and BOOLEAN), string, and date (DATE and DATETIME). </td><td colspan="3">Numeric (including integers, BOOLEAN, and DECIMAL), string, and date (DATE and DATETIME).</td></tr><tr><td><strong>Relationship between key columns and partitioning/bucketing columns</strong> </td><td>Partitioning columns and bucketing columns must be in the primary key. </td><td>None </td><td>Partitioning columns and bucketing columns must be in the aggregate key. </td><td>Partitioning columns and bucketing columns must be in the unique key. </td></tr></tbody>
</table>

## Data types of key and value columns

The key columns support the following data types: numeric (including integers, BOOLEAN, and DECIMAL), string, and date (DATE and DATETIME).

:::note
The key columns of a Primary Key table do not support the DECIMAL data type.
:::

On the other hand, the value columns support basic data types, including numeric, string, and date (DATE and DATETIME). The support for BITMAP, HLL, and semi-structured types varies for value columns of different types of tables, as detailed below:
<table>
<thead>
<tr><th> </th><th><strong>Primary Key</strong> <strong>table</strong></th><th><strong>Duplicate Key table</strong></th><th><strong>Aggregate table</strong></th><th><strong>Unique Key table</strong></th></tr>
</thead>
<tbody><tr><td><strong>BITMAP</strong></td><td>Supported</td><td>Not supported   </td><td>Supported. The aggregate functions  must be bitmap_union, replace, or replace_if_not_null. </td><td>Supported </td></tr><tr><td><strong>HLL</strong></td><td>Supported </td><td>Not supported  </td><td>Supported. The aggregate functions must be hll_union, replace, or replace_if_not_null. </td><td>Supported </td></tr><tr><td><strong>PERCENTILE</strong></td><td>Supported </td><td>Not supported  </td><td>Supported. The aggregate functions must be percentile_union, replace, or replace_if_not_null. </td><td>Supported</td></tr><tr><td><strong>semi-structured data typesï¼šJSON/ARRAY/MAP/STRUCT</strong></td><td>Supported </td><td>Supported</td><td>Supported. The aggregate functions  must be replace or replace_if_not_null. </td><td>Supported</td></tr></tbody>
</table>

## Data change

<table>
<thead>
<tr><th> </th><th><strong>Primary Key</strong> <strong>Table</strong></th><th><strong>Duplicate Key table</strong></th><th><strong>Aggregate table</strong></th><th><strong>Unique Key table</strong></th></tr>
</thead>
<tbody><tr><td><strong>INSERT through data loading</strong> </td><td  rowspan="2">Supported. [Configure <code>__op=0</code> in the load job to achieve INSERT](../../loading/Load_to_Primary_Key_tables.md). <br /> In the internal implementation, StarRocks considers both INSERT and UPDATE operations as UPSERT operations.</td><td>Supported</td><td>Supported (Data rows with the same aggregate Key value will be aggregated.)</td><td>Supported (Data rows with the same unique key value will be updated.) </td></tr><tr><td><strong>UPDATE through data loading</strong> </td><td>Not supported </td><td>Supported (This can be achieved by using replace as the aggregate function.) </td><td>Supported (The Unique Key table itself can be considered as an Aggregate table using the replace aggregate function.) </td></tr><tr><td><strong>DELETE through data loading</strong> </td><td>Supported. [Configure <code>__op=1</code> in the load job to achieve DELETE](../../loading/Load_to_Primary_Key_tables.md). </td><td colspan="3">Not supported </td></tr><tr><td><strong>Integrity of data column values to be loaded</strong> </td><td>By default, all column values need to be loaded. However, if partial column update (<code>partial_update</code>) is enabled, or a column has a default value, not all column values need to be loaded.</td><td>By default, all column values need to be loaded. However, if a column has a default value, not all column values need to be loaded. </td><td>By default, all column values need to be loaded. However, Aggregate tables can achieve partial column update by specifying the aggregate functions for value columns as REPLACE_IF_NOT_NULL. For details, see [aggr_type](../../sql-reference/sql-statements/table_bucket_part_index/CREATE_TABLE.md#column_definition). Also, if a column has a default value, not all column values need to be loaded.</td><td>By default, all column values need to be loaded. However, if a column has a default value, not all column values need to be loaded.</td></tr><tr><td><strong>[DML INSERT](../../sql-reference/sql-statements/loading_unloading/INSERT.md)</strong></td><td colspan="4">Supported</td></tr><tr><td><strong>[DML UPDATE](../../sql-reference/sql-statements/table_bucket_part_index/UPDATE.md)</strong> </td><td><ul><li>Key columns as filter conditions: Supported</li><li>Value columns as filter conditions: Supported </li></ul></td><td colspan="3">Not supported</td></tr><tr><td><strong>[DML DELETE](../../sql-reference/sql-statements/table_bucket_part_index/DELETE.md)</strong></td><td><ul><li>Key columns as filter conditions: Supported</li><li>Value columns as filter conditions: Supported</li></ul></td><td><ul><li>Key columns as filter conditions: Supported</li><li>Value columns as filter conditions: Supported</li></ul>Note that only simple filter conditions based on key or value columns themselves are supported, such as =, &lt;, &gt;. Complex filter conditions, such as functions or subqueries, are not supported.</td><td colspan="2"><ul><li>Key columns as filter conditions: Supported. Note that only simple filter conditions based on key columns themselves are supported, such as =, &lt;, &gt;. Complex filter conditions, such as functions or subqueries, are not supported.</li><li>Value columns as filter conditions: Not supported.</li></ul> </td></tr></tbody>
</table>

## Compatibility with other features

<table>
<thead>
<tr><th colspan="2"></th><th><strong>Primary Key table</strong></th><th><strong>Duplicate Key table</strong></th><th><strong>Aggregate table</strong></th><th><strong>Unique Key table</strong></th></tr>
</thead>
<tbody><tr><td rowspan="2"><strong>Bitmap index/bloom filter index</strong></td><td><strong>Build indexes on key columns</strong></td><td colspan="4">Supported</td></tr><tr><td><strong>Build indexes on value columns</strong></td><td>Supported</td><td>Supported</td><td>Not supported</td><td>Not supported</td></tr><tr><td rowspan="2"><strong>Partitioning/bucketing</strong></td><td><strong>Expression partitioning/list partitioning</strong></td><td colspan="4">Supported</td></tr><tr><td><strong>Random bucketing</strong></td><td>Not supported</td><td>Supported from v3.1 onwards</td><td>Not supported</td><td>Not supported</td></tr><tr><td  rowspan="2"><strong>Materialized views</strong></td><td ><strong>Asynchronous materialized views</strong></td><td colspan="4">Supported</td></tr><tr><td><strong>Synchronous materialized views</strong></td><td>Not supported</td><td>Supported</td><td>Supported</td><td>Supported</td></tr><tr><td rowspan="2"><strong>Other features</strong></td><td><strong>CTAS</strong></td><td>Supported</td><td>Supported</td><td>Not supported </td><td>Not supported </td></tr><tr><td><strong>Backup &amp; restore</strong></td><td>Supported from v2.5 onwards</td><td colspan="3">Supported</td></tr></tbody>
</table>
