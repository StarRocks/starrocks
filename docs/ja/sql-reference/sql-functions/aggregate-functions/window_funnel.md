---
displayed_sidebar: docs
---

# window_funnel

スライディングウィンドウ内でイベントチェーンを検索し、イベントチェーン内の連続するイベントの最大数を計算します。この関数は、コンバージョン率の分析によく使用されます。v2.3からサポートされています。

この関数は以下のルールに従って動作します。

- イベントチェーンの最初のイベントからカウントを開始します。最初のイベントが見つかった場合、イベントカウンターは1に設定され、スライディングウィンドウが開始されます。最初のイベントが見つからない場合、0が返されます。

- スライディングウィンドウ内で、イベントチェーンのイベントが順番に発生した場合、カウンターが増加します。スライディングウィンドウを超えた場合、イベントカウンターは増加しません。

- 複数のイベントチェーンが指定された条件に一致する場合、最も長いイベントチェーンが返されます。

## 構文

```Plain
BIGINT window_funnel(BIGINT window, DATE|DATETIME time, INT mode, array[cond1, cond2, ..., condN])
```

## パラメータ

- `window`: スライディングウィンドウの長さ。サポートされるデータ型は BIGINT です。単位は `time` パラメータに依存します。`time` のデータ型が DATE の場合、単位は日です。`time` のデータ型が DATETIME の場合、単位は秒です。

- `time`: タイムスタンプを含む列。DATE と DATETIME 型がサポートされています。

- `mode`: イベントチェーンがフィルタリングされるモード。サポートされるデータ型は INT です。値の範囲: 0, 1, 2。
  - `0` はデフォルト値で、一般的なファネル計算を示します。
  - `1` は `DEDUPLICATION` モードを示し、フィルタリングされたイベントチェーンには重複したイベントが含まれません。`array` パラメータが `[event_type = 'A', event_type = 'B', event_type = 'C', event_type = 'D']` で、元のイベントチェーンが "A-B-C-B-D" の場合、イベント B は重複しており、フィルタリングされたイベントチェーンは "A-B-C" です。
  - `2` は `FIXED` モードを示し、フィルタリングされたイベントチェーンには指定された順序を乱すイベントが含まれません。前述の `array` パラメータが使用され、元のイベントチェーンが "A-B-D-C" の場合、イベント D は順序を乱し、フィルタリングされたイベントチェーンは "A-B" です。
  - `4` は `INCREASE` モードを示し、フィルタリングされたイベントは厳密に増加するタイムスタンプを持たなければなりません。重複するタイムスタンプはイベントチェーンを乱します。このモードはバージョン 2.5 からサポートされています。

- `array`: 定義されたイベントチェーン。配列でなければなりません。

## 戻り値

BIGINT 型の値を返します。

## 例

**例 1**: `uid` に基づいて連続するイベントの最大数を計算します。スライディングウィンドウは 1800 秒で、フィルタリングモードは `0` です。

この例では、データが `uid` でソートされたテーブル `action` を使用します。

```Plaintext
mysql> select * from action;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Order      | 2020-01-02 11:20:00 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Order      | 2020-01-02 11:00:00 |
| 2    | Pay        | 2020-01-02 11:10:00 |
| 3    | Browse     | 2020-01-02 11:20:00 |
| 3    | Click      | 2020-01-02 12:00:00 |
| 4    | Browse     | 2020-01-02 11:50:00 |
| 4    | Click      | 2020-01-02 12:00:00 |
| 5    | Browse     | 2020-01-02 11:50:00 |
| 5    | Click      | 2020-01-02 12:00:00 |
| 5    | Order      | 2020-01-02 11:10:00 |
| 6    | Browse     | 2020-01-02 11:50:00 |
| 6    | Click      | 2020-01-02 12:00:00 |
| 6    | Order      | 2020-01-02 12:10:00 |
+------+------------+---------------------+
17 rows in set (0.01 sec)
```

次のステートメントを実行します。

```Plaintext
select uid,
       window_funnel(1800,time,0,[event_type='Browse', event_type='Click', 
        event_type='Order', event_type='Pay']) AS level
from action
group by uid
order by uid; 
+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     0 |
| 3    |     1 |
| 4    |     2 |
| 5    |     2 |
| 6    |     3 |
+------+-------+
```

結果の説明:

- `uid = 1` の一致するイベントチェーンは "Browse-Click-Order-Pay" で、`4` が返されます。最後の "Browse" イベント (2020-01-02 11:00:00) の時間は条件を満たさず、カウントされません。

- `uid = 2` のイベントチェーンは最初のイベント "Browse" から始まらず、`0` が返されます。

- `uid = 3` の一致するイベントチェーンは "Browse" で、`1` が返されます。"Click" イベントは 1800 秒の時間ウィンドウを超えており、カウントされません。

- `uid = 4` の一致するイベントチェーンは "Browse-Click" で、`2` が返されます。

- `uid = 5` の一致するイベントチェーンは "Browse-Click" で、`2` が返されます。"Order" イベント (2020-01-02 11:10:00) はイベントチェーンに属さず、カウントされません。

- `uid = 6` の一致するイベントチェーンは "Browse-Click-Order" で、`3` が返されます。

**例 2**: `uid` に基づいて連続するイベントの最大数を計算します。スライディングウィンドウは 1800 秒で、フィルタリングモードは `0` と `1` を使用します。

この例では、データが `time` でソートされたテーブル `action1` を使用します。

```Plaintext
mysql> select * from action1 order by time;
+------+------------+---------------------+ 
| uid  | event_type | time                |     
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Browse     | 2020-01-02 11:00:01 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Order      | 2020-01-02 11:29:00 |
| 1    | Click      | 2020-01-02 11:29:50 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Click      | 2020-01-02 11:40:00 |
+------+------------+---------------------+
7 rows in set (0.03 sec)
```

次のステートメントを実行します。

```Plaintext
select uid,
       window_funnel(1800,time,0,[event_type='Browse', 
        event_type='Click', event_type='Order', event_type='Pay']) AS level
from action1
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

`uid = 1` の場合、"Click" イベント (2020-01-02 11:29:50) は重複したイベントですが、モード `0` が使用されているためカウントされます。したがって、`4` が返されます。

`mode` を `1` に変更してステートメントを再実行します。

```Plaintext
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 rows in set (0.05 sec)
```

重複排除後にフィルタリングされた最長のイベントチェーンは "Browse-Click-Order" で、`3` が返されます。

**例 3**: `uid` に基づいて連続するイベントの最大数を計算します。スライディングウィンドウは 1900 秒で、フィルタリングモードは `0` と `2` を使用します。

この例では、データが `time` でソートされたテーブル `action2` を使用します。

```Plaintext
mysql> select * from action2 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Browse     | 2020-01-02 11:00:01 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Order      | 2020-01-02 11:31:00 |
+------+------------+---------------------+
5 rows in set (0.01 sec)
```

次のステートメントを実行します。

```Plaintext
select uid,
       window_funnel(1900,time,0,[event_type='Browse', event_type='Click', 
        event_type='Order', event_type='Pay']) AS level
from action2
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

`uid = 1` には `3` が返されます。なぜなら、モード `0` が使用されており、"Pay" イベント (2020-01-02 11:30:00) がイベントチェーンを乱さないからです。

`mode` を `2` に変更してステートメントを再実行します。

```Plaintext
select uid,
       window_funnel(1900,time,2,[event_type='Browse', event_type='Click', 
        event_type='Order', event_type='Pay']) AS level
from action2
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     2 |
| 2    |     1 |
+------+-------+
2 rows in set (0.06 sec)
```

`2` が返されます。なぜなら、"Pay" イベントがイベントチェーンを乱し、イベントカウンターが停止するからです。フィルタリングされたイベントチェーンは "Browse-Click" です。

**例 4**: `uid` に基づいて連続するイベントの最大数を計算します。スライディングウィンドウは 1900 秒で、フィルタリングモードは `0` と `4` を使用します。

この例では、データが `time` でソートされたテーブル `action3` を使用します。

```Plaintext
select * from action3 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 1    | Click      | 2020-01-02 11:00:01 |
| 2    | Browse     | 2020-01-02 11:00:03 |
| 1    | Order      | 2020-01-02 11:00:31 |
| 2    | Click      | 2020-01-02 11:00:03 |
| 2    | Order      | 2020-01-02 11:01:03 |
+------+------------+---------------------+
3 rows in set (0.02 sec)
```

次のステートメントを実行します。

```Plaintext
select uid,
       window_funnel(1900,time,0,[event_type='Browse', event_type='Click',
        event_type='Order']) AS level
from action3
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
|    1 |     3 |
|    2 |     3 |
+------+-------+
```

`uid = 1` と `uid = 2` には `3` が返されます。

`mode` を `4` に変更してステートメントを再実行します。

```Plaintext
select uid,
       window_funnel(1900,time,4,[event_type='Browse', event_type='Click',
        event_type='Order']) AS level
from action3
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
|    1 |     3 |
|    2 |     1 |
+------+-------+
1 row in set (0.02 sec)
```

`uid = 2` には `1` が返されます。なぜなら、モード `4` (厳密に増加) が使用されているためです。"Click" は "Browse" と同じ秒に発生します。したがって、"Click" と "Order" はカウントされません。

## キーワード

window funnel, funnel, window_funnel