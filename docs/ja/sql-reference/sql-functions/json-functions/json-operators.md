---
displayed_sidebar: docs
---

# JSON operators

StarRocks は次の JSON 比較演算子をサポートしています: `<`, `<=`, `>`, `>=`, `=`, および `!=`。これらの演算子を使用して JSON データをクエリできます。ただし、StarRocks では `IN` を使用して JSON データをクエリすることはできません。

- > 演算子のオペランドは両方とも JSON 値でなければなりません。

- > 演算子のオペランドの一方が JSON 値であり、他方がそうでない場合、演算中に JSON 値でないオペランドは JSON 値に変換されます。変換ルールの詳細については、 [CAST](./json-query-and-processing-functions/cast.md) を参照してください。

:::tip
すべての JSON 関数と演算子はナビゲーションと [overview page](./overview-of-json-functions-and-operators.md) にリストされています。

クエリを高速化するには、 [generated columns](../../sql-statements/generated_columns.md) を使用してください。
:::

## 算術ルール

JSON 演算子は次の算術ルールに従います:

- 演算子のオペランドが同じデータ型の JSON 値である場合:
  - 両方のオペランドが NUMBER、STRING、BOOLEAN などの基本データ型の JSON 値である場合、演算子は基本データ型の算術ルールに従って算術演算を行います。

> Note: 両方のオペランドが数値であるが、一方が DOUBLE 値で他方が INT 値である場合、演算子は INT 値を DOUBLE 値に変換します。

- 両方のオペランドが OBJECT または ARRAY などの複合データ型の JSON 値である場合、演算子は最初のオペランドのキーの順序に基づいてオペランド内のキーを辞書順にソートし、オペランド間でキーの値を比較します。

例 1:

最初のオペランドが `{"a": 1, "c": 2}` で、2 番目のオペランドが `{"b": 1, "a": 2}` である場合、この例では演算子はオペランド間のキー `a` の値を比較します。最初のオペランドのキー `a` の値は `1` であり、2 番目のオペランドのキー `a` の値は `2` です。値 `1` は値 `2` より大きいです。したがって、演算子は最初のオペランド `{"a": 1, "c": 2}` が 2 番目のオペランド `{"b": 1, "a": 2}` より小さいと結論付けます。

```plaintext
mysql> SELECT PARSE_JSON('{"a": 1, "c": 2}') < PARSE_JSON('{"b": 1, "a": 2} ');

       -> 1
```

例 2:

最初のオペランドが `{"a": 1, "c": 2}` で、2 番目のオペランドが `{"b": 1, "a": 1}` である場合、この例では演算子はまずオペランド間のキー `a` の値を比較します。オペランドのキー `a` の値は両方とも `1` です。次に、演算子はオペランドのキー `c` の値を比較します。2 番目のオペランドにはキー `c` が含まれていません。したがって、演算子は最初のオペランド `{"a": 1, "c": 2}` が 2 番目のオペランド `{"b": 1, "a": 1}` より大きいと結論付けます。

```plaintext
mysql> SELECT PARSE_JSON('{"a": 1, "c": 2}') < PARSE_JSON('{"b": 1, "a": 1}');

       -> 0
```

- 演算子のオペランドが異なるデータ型の JSON 値である場合、演算子は次の算術ルールに従ってオペランドを比較します: NULL < BOOLEAN < ARRAY < OBJECT < DOUBLE < INT < STRING.

```plaintext
mysql> SELECT PARSE_JSON('"a"') < PARSE_JSON('{"a": 1, "c": 2}');

       -> 0
```