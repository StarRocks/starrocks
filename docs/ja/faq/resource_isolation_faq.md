---
displayed_sidebar: docs
---

# リソース分離のトラブルシューティング

このトピックでは、リソース分離に関するよくある質問への回答を提供します。

## リソースグループ

### リソースグループで設定する必要があるリソースは何ですか？

CPUリソースの制限を設定する必要があります。`cpu_weight` または `exclusive_cpu_core` のいずれかを設定し、その値は0より大きくなければなりません。

### StarRocksはハードリソース制限をサポートしていますか？

はい。StarRocksはメモリのハード制限をサポートしています。v3.3.5以降、StarRocksは `exclusive_cpu_cores` を使用してCPUのハード制限をサポートしています。

### リソースグループ間でCPUはどのように割り当てられますか？

複数のリソースグループが同時にクエリを実行する場合、CPU使用率は各グループの `cpu_core_limit` に比例します。通常のグループがスケジューリングサイクル内で `BE vCPU cores - short_query.cpu_core_limit` を超えると、そのサイクル内でさらにスケジュールされることはありません。

### `short_query` リソースグループのリソースはどのように計算されますか？

`short_query` リソースグループがクエリを実行している場合、すべての通常グループのCPU制限は `BE vCPU cores − short_query.cpu_core_limit` になります。`short_query` リソースグループがアイドル状態の場合、そのリソースは通常グループによって使用されることができます。

### マッチしないリソースグループがあるクエリはどのように処理されますか？

それらはデフォルトのリソースグループ `default_wg` を使用し、以下のリソース制限とプロパティを持ちます：

- `cpu_core_limit` = vCPU cores
- `mem_limit` = 100%
- `type` = `normal`

### リソースグループ `rg3` にクエリがなく、すべてのリソースがリソースグループ `rg1` と `rg2` に割り当てられている場合、`rg3` が大規模クエリを受け取ったときにそれらのリソースは再割り当てされますか？

はい。再取得は徐々に行われ、数十ミリ秒から数秒以内に安定します。

### クラシファイア（分類器）の役割は何ですか？マッチしない場合や、2つのクラシファイアが重複する場合はどうなりますか？

クラシファイアがマッチしない場合、クエリはデフォルトのリソースグループ `default_wg` にフォールバックします。クラシファイアには重みがあり、クエリが複数のクラシファイアにマッチする場合、最も高い重みを持つものが選択されます。

### BEがデフォルトで90%のメモリを使用する場合、なぜリソースグループに `mem_limit` が必要なのですか？

`mem_limit` はリソースグループレベルでメモリを制限します。それはそのリソースグループにマッチするクエリにのみ適用されます。

### リソースグループの `query_type` が `insert` に設定されている場合、INSERT INTO SELECT はINSERTのみを制限するのか、それともSELECTも制限するのか？

SELECT部分のみがリソースグループによって制限されます。INSERT操作は制限されません。

### リソースグループの `mem_limit` が `20%` に設定されている場合、使用可能なメモリは `BE_memory * 90% * 20%` と計算されますか？複数のリソースグループがある場合、合計 `mem_limit` が100%を超えたらどうなりますか？

グループ間の合計 `mem_limit` は100%を超えることがあります。しかし、クエリがそのリソースグループの制限を超えると、失敗します。

### クエリにリソースグループが適用されているかどうかを確認するにはどうすればよいですか？

`fe.audit.log` を確認するか、`EXPLAIN VERBOSE <SQL>` を実行してマッチしたリソースグループを表示します。

### リソースグループはクラスターごとに定義されているのですか、それともBEノードごとに定義されているのですか？

リソースはBEノードごとに分割され、リソースグループの設定はクラスター内のすべてのBEノードに適用されます。

### リソースグループの使用状況や監視メトリクスを確認するにはどうすればよいですか？

FE/BEメトリクスエンドポイントを使用して、特定のリソースグループに関連するメトリクスを表示します。

- FEの場合、`fe_host:8030/metrics?type=json` から以下のメトリクスを収集します：
  - `starrocks_fe_query_resource_group`: このリソースグループで過去に実行されたクエリの数（現在実行中のものを含む）。
  - `starrocks_fe_query_resource_group_latency`: このリソースグループのクエリ遅延パーセンタイル。ラベルタイプは `mean`、`75_quantile`、`95_quantile`、`98_quantile`、`99_quantile`、`999_quantile` を含む特定のパーセンタイルを示します。
  - `starrocks_fe_query_resource_group_err`: このリソースグループでエラーが発生したクエリの数。

- BEの場合、`be_host:8040/metrics?type=json` から以下のメトリクスを収集します：
  - `starrocks_be_resource_group_cpu_limit_ratio`: このリソースグループの `cpu_core_limit` とすべてのリソースグループの合計 `cpu_core_limit` の比率。
  - `starrocks_be_resource_group_mem_limit_bytes`: このリソースグループのメモリ制限。

### `short_query` と通常のリソースグループの違いは何ですか？複数の `short_query` リソースグループを作成できますか？

`short_query` リソースグループは1つだけ許可されます。`short_query` リソースグループでクエリが実行されている場合、実際のBEコアを使用し、通常のグループは残りのリソースを比例配分します。

### StarRocksはクエリの優先順位や大規模クエリに基づく優先順位付けを提供していますか？

優先順位システムは存在しません。クエリが設定されたリソースのしきい値を超えると「大規模クエリ」となります。

### リソースグループは特定のBEノードに属するのですか、それともクエリを実行しているBEに属するのですか？

リソースグループはクラスター内のすべてのBEに均一に適用されます。

### `concurrency_limit` をどのように設定すればよいですか？

クエリの複雑さ、クラスターのサイズ、ワークロードのパターンに依存します。

### クラシファイアベースのマッチングはどのように機能しますか？ユーザーやデータベースに関連していますか？

マッチングは、IP、ユーザー、db、ロール、または `query_type` などのクラシファイア属性に依存します。

### リソースグループはセッション変数を通じてどのように指定されますか？

変数として設定できます：

```SQL
SET resource_group = '<resource_group_name>';
```

または、ヒントを使用してクエリ内で指定します：

```SQL
SELECT /*+ SET_VAR(SET resource_group = '<resource_group_name>') */ * FROM tbl;
```

### 同時実行制御はグローバルに、ユーザーごとに、またはBEごとに効果がありますか？

`concurrency_limit` はリソースグループごとに同時実行を制限し、`pipeline_dop` は単一のパイプラインインスタンスの並行性を制御します。

### メモリ制限はグローバルに、ユーザーごとに、またはBEごとに効果がありますか？

`mem_limit` はBEごとのリソースグループに適用されます。インスタンスごとのメモリは `exec_mem_limit` によって制御されます。

### 同時実行とメモリ制限はリソースグループが有効な場合にのみ効果がありますか？

同時実行はリソースグループによってのみ制御されます。クエリの並行性は `pipeline_dop` などのセッション変数によって制御されます。

### `query_type` が `INSERT` に設定されている場合、CTASタスクはリソースグループにマッチしますか？

はい。リソースグループはCTASタスクのSELECT部分のリソースを制限します。SELECT部分がしきい値を超えると、大規模クエリの制限も適用されます。

### なぜ `short_query` リソースグループのクエリはすべてのCPUを消費できないのですか？

`short_query` リソースグループは通常のグループのために少なくとも1つのCPUコアを残しておく必要があります。

### クエリキューとリソースグループがない場合、同時クエリは制限されますか？

いいえ。オーバーロードはクエリのタイムアウトやメモリ制限エラーを引き起こします。

### リソースグループが有効でクエリキューが無効な場合、同時実行はリソースグループによって制限されますか？

はい。リソースグループの `concurrency_limit` を超える新しいクエリは失敗します。

### クエリが「大規模クエリ」と認識されるのはいつですか？

クエリが以下のいずれかを超えると、大規模クエリと見なされます：

- `big_query_cpu_second_limit`
- `big_query_scan_rows_limit`
- `big_query_mem_limit`

### `default_wg` のリソース制限を変更できますか？

いいえ。回避策として、すべてのクエリにマッチする一般的なリソースグループを作成します。

例：

```SQL
CREATE RESOURCE GROUP general_group TO (
    query_type IN ('select', 'insert') 
)
WITH (
    'cpu_core_limit' = '6', 
    'mem_limit' = '0.0000000000001'
);
```

### なぜ「query_resource_group」メトリックは新しく作成されたグループを表示しないのですか？

メトリックは遅延初期化され、クエリがそのグループにヒットした後にのみ表示されます。

### 多くのクエリがBEで実行され、1つがCPU制限に達した場合、すべてが失敗しますか？

制限に達したクエリのみが失敗します。

### BEノードが異なるメモリ/CPUサイズを持っている場合、`mem_limit` または `cpu_core_limit` は結果に影響しますか？

メモリ制限はハードであり、メモリサイズが少ないBEで先に失敗する可能性があります。CPUはソフトであり、エラーを引き起こしません。

### `big_query_` パラメータはノードごとに適用されるのですか、それともグローバルに適用されるのですか？

それらはBEノードごとに適用されます。

### Broker Load のためにリソースグループをどのように設定しますか？

例のクラシファイア：`query_type="insert", user="alice"`。

### `exec_mem_limit` に関連する質問

Q: クエリのためにいくつのインスタンスが生成されますか？

A: 予測不可能です。異なるクエリは異なる数のフラグメントを生成する可能性があります。

Q: インスタンスの数を確認する方法はありますか？

A: インスタンスの数を確認することはできません。

Q: クエリが合計で128 GBのメモリを消費し、60のインスタンスを生成し、`query_mem_limit=0` および `exec_mem_limit=2G` の場合、クエリは失敗しますか？

A: いずれかのインスタンスが2 GB（`exec_mem_limit`）以上のメモリを消費すると、クエリは失敗します。

### 特定のリソースグループのみでグローバルクエリキューを無効にする方法は？

1. リソースグループレベルのクエリキューを有効にします：

   ```SQL
   SET GLOBAL enable_show_all_variables = true;
   SET enable_group_level_query_queue = true;
   ```

2. 現在のセッションまたはユーザーレベルでクエリキューを無効にします：

   ```SQL
   -- 現在のセッションでクエリキューを無効にする
   SET enable_query_queue = false;
   -- ユーザーレベルでクエリキューを無効にする
   ALTER USER 'xxx' SET PROPERTIES ("session.enable_query_queue" = "false");
   ```

### どのリソースグループにもマッチしないクエリを強制的に失敗させることができますか？

いいえ。それらは常にデフォルトのリソースグループ `default_wg` にフォールバックします。

## クエリキュー

### クエリキューのメモリトリガーはどのように計算されますか？

クエリキュートリガー = BEの利用可能なメモリサイズ * `query_queue_mem_used_pct_limit`。

### リソースグループの同時実行とクエリキューの同時実行のどちらが優先されますか？

`enable_group_level_query_queue` が設定されている場合：

- `false`: グローバルまたはグループの制限が先にトリガーされる可能性があります。
- `true`: 両方が適用され、小さい方の制限がキューイングをトリガーします。

### キューサイズまたはタイムアウトに達した場合、クエリは即座に失敗しますか？

- `query_queue_max_queued_queries` に達した場合、クエリは即座に失敗します。
- `query_queue_concurrency_limit` に達した場合、クエリはキューで待機します。

### リソースグループの制限とクエリキューの制限の違いは何ですか？

リソースグループは、BEノードごとにグループごとのリソース使用を制限します。

クエリキューは、すべてのクエリに対してBEレベルの制限を使用します。

`concurrency_limit` と `max_cpu_cores` は、リソースグループレベルのクエリキューが有効な場合に両方適用されます。

### `pipeline_dop`、`exec_mem_limit`、リソースグループの同時実行制限の違いは何ですか？

`pipeline_dop` はクエリ内の並行性を制御します。

リソースグループ/クエリキューはクラスター全体の同時クエリを制御します。

`query_mem_limit` はクエリごと、BEごとのメモリを制御します。