---
displayed_sidebar: docs
keywords: ['profile', 'query']
---

# クエリチューニングレシピ

> 実用的なプレイブック: **症状 → 根本原因 → 実証済みの修正**。  
> プロファイルを開いて問題のあるメトリクスを見つけたが、「_次はどうする？_」という質問に答える必要があるときに使用します。

---

## 1 · 迅速な診断ワークフロー

1. **実行概要をざっと見る**  
   `QueryPeakMemoryUsagePerNode > 80 %` または `QuerySpillBytes > 1 GB` の場合、メモリとスピルのレシピに直接進みます。

2. **最も遅いパイプライン / オペレーターを見つける**  
   ⟶ *Query Profile UI* で **Sort by OperatorTotalTime %** をクリックします。  
   最も負荷の高いオペレーターが次に読むべきレシピブロックを示します（スキャン、ジョイン、集計など）。

3. **ボトルネックのサブタイプを確認する**  
   各レシピはその*シグネチャ*メトリックパターンで始まります。それらを一致させてから修正を試みます。

---

## 2 · オペレーター別レシピ

### 2.1 OLAP / コネクタースキャン  [[metrics]](./query_profile_operator_metrics.md#scan-operator)

Scan Operator 内のさまざまなメトリクスをよりよく理解するために、以下の図はこれらのメトリクスとストレージ構造との関連を示しています。

![profile_scan_relationship](../../_assets/Profile/profile_scan_relationship.jpeg)

ディスクからデータを取得し、述語を適用するために、ストレージエンジンはいくつかの技術を利用します:
1. **データストレージ**: エンコードおよび圧縮されたデータがセグメントに分けてディスクに保存され、さまざまなインデックスが付随します。
2. **インデックスフィルタリング**: エンジンは BitmapIndex、BloomfilterIndex、ZonemapIndex、ShortKeyIndex、NGramIndex などのインデックスを活用して不要なデータをスキップします。
3. **プッシュダウン述語**: `a > 1` のような単純な述語が特定の列で評価されるようにプッシュダウンされます。
4. **後期実体化**: 必要な列とフィルタリングされた行のみがディスクから取得されます。
5. **非プッシュダウン述語**: プッシュダウンできない述語が評価されます。
6. **プロジェクション式**: `SELECT a + 1` のような式が計算されます。

Scan Operator は IO タスクを実行するために追加のスレッドプールを利用します。したがって、このノードの時間メトリクス間の関係は以下に示されています。

![profile_scan_time_relationship](../../_assets/Profile/profile_scan_time_relationship.jpeg)

#### 一般的なパフォーマンスボトルネック

**コールドまたは遅いストレージ** – `BytesRead`、`ScanTime`、または `IOTaskExecTime` が支配的で、ディスク I/O が 80‑100 % の範囲にある場合、スキャンはコールドまたは過小プロビジョニングされたストレージにヒットしています。ホットデータを NVMe/SSD に移動し、ストレージキャッシュを有効にするか、S3/HDFS をスキャンしている場合は `remote_cache_capacity` を増やします。

**フィルタープッシュダウンが欠如** – `PushdownPredicates` が 0 に近いままで `ExprFilterRows` が高い場合、述語がストレージ層に到達していません。単純な比較として書き直す（`%LIKE%` や広範な `OR` チェーンを避ける）か、ゾーンマップ/Bloom インデックスやマテリアライズドビューを追加してプッシュダウンできるようにします。

**スレッドプールの枯渇** – 高い `IOTaskWaitTime` と低い `PeakIOTasks` は、I/O スレッドプールが飽和していることを示します。BE の `max_io_threads` を増やすか、キャッシュを拡大して、より多くのタスクを同時に実行できるようにします。

**タブレット間のデータスキュー** – 最大と最小の `OperatorTotalTime` の間に大きなギャップがある場合、一部のタブレットが他よりも多くの作業を行っています。高いカーディナリティキーで再バケット化するか、負荷を分散するためにバケット数を増やします。

**Rowset/セグメントの断片化** – `RowsetsReadCount`/`SegmentsReadCount` の急増と長い `SegmentInitTime` は、多くの小さな rowset を示します。手動での Compaction をトリガーし、小さなロードをバッチ処理してセグメントを事前にマージします。

**累積されたソフトデリート** – 大きな `DeleteFilterRows` は、ソフトデリートの使用が多いことを示します。BE の Compaction を実行してトゥームストーンを削除し、削除ビットマップを統合します。

### 2.2 集計  [[metrics]](./query_profile_operator_metrics.md#aggregate-operator)

![aggregation_operator](../../_assets/Profile/aggregation_operator.png)  
Aggregate Operator は集計関数、`GROUP BY`、および `DISTINCT` の実行を担当します。

**集計アルゴリズムの多様な形式**

| 形式 | プランナーが選択する条件 | 内部データ構造 | 特徴 / 注意点 |
|------|------------------------|----------------|---------------|
| ハッシュ集計 | キーがメモリに収まり、カーディナリティが極端でない | SIMD プロービングを備えたコンパクトなハッシュテーブル | デフォルトパス、適度なキー数に最適 |
| ソート集計 | 入力がすでに GROUP BY キーで順序付けされている | 単純な行比較 + 実行状態 | ハッシュテーブルコストゼロ、プロービングが重いスキューで通常 2-3 倍速い |
| スピル可能な集計 (3.2+) | ハッシュテーブルがメモリ制限を超える | ディスクスピルパーティションを持つハイブリッドハッシュ/マージ | OOM を防ぎ、パイプライン並行性を維持 |

**多段階分散集計**

StarRocks では、集計は分散方式で実装されており、クエリパターンとオプティマイザの決定に応じて多段階になることがあります。

```
┌─────────┐        ┌──────────┐        ┌────────────┐        ┌────────────┐
│ Stage 0 │ local  │ Stage 1  │ shard/ │ Stage 2    │ gather/│ Stage 3    │ final
│ Partial │───►    │ Update   │ hash   │ Merge      │ shard  │ Finalize   │ output
└─────────┘        └──────────┘        └────────────┘        └────────────┘
```

| ステージ | 使用される条件 | 実行内容 |
|--------|------------|--------------|
| ワンステージ | `DISTRIBUTED BY` が `GROUP BY` のサブセットで、パーティションがコロケートされている | 部分集計が即座に最終結果になります。 |
| ツーステージ (ローカル + グローバル) | 典型的な分散 `GROUP BY` | 各 BE 内の Stage 0 が重複を適応的に圧縮し、Stage 1 が `GROUP BY` に基づいてデータをシャッフルし、その後グローバル集計を実行します。 |
| スリーステージ (ローカル + シャッフル + ファイナル) | 重い `DISTINCT` と高カーディナリティの `GROUP BY` | 上記のように Stage 0; Stage 1 が `GROUP BY` に基づいてシャッフルし、その後 `GROUP BY` と `DISTINCT` に基づいて集計; Stage 2 が部分状態を `GROUP BY` としてマージします。 |
| フォーステージ (ローカル + パーシャル + インターミディエイト + ファイナル) | 重い `DISTINCT` と低カーディナリティの `GROUP BY` | `GROUP BY` と `DISTINCT` に基づいてシャッフルするための追加ステージを導入し、単一ポイントのボトルネックを回避します。 |

#### 一般的なパフォーマンスボトルネック

**高カーディナリティの GROUP BY** – `HashTableSize` または `HashTableMemoryUsage` がメモリ制限に向かって膨らむ場合、グループ化キーが広すぎるか、または非常にユニークです。ソートされたストリーミング集計 (`enable_streaming_preaggregation = true`) を有効にし、ロールアップマテリアライズドビューを作成するか、広い文字列キーを `INT` にキャストします。

**シャッフルスキュー** – フラグメント間で `HashTableSize` または `InputRowCount` に大きな違いがある場合、シャッフルが不均衡です。キーにソルトカラムを追加するか、`DISTINCT [skew]` ヒントを使用して行を均等に分配します。

**状態が重い集計関数** – `AggregateFunctions` が実行時間を支配し、関数に `HLL_`、`BITMAP_`、または `COUNT(DISTINCT)` が含まれる場合、巨大な状態オブジェクトが移動されています。HLL/ビットマップスケッチをインジェスト中に事前計算するか、近似バリアントに切り替えます。

**部分集計の劣化** – 大きな `InputRowCount` と控えめな `AggComputeTime`、さらに上流の EXCHANGE での大量の `BytesSent` は、事前集計がバイパスされたことを意味します。`SET streaming_preaggregation_mode = "force_preaggregation"` を使用して強制的にオンに戻します。

**高価なキー式** – `ExprComputeTime` が `AggComputeTime` に匹敵する場合、GROUP BY キーが行ごとに計算されています。これらの式をサブクエリで実体化するか、生成列に昇格させます。

### 2.3 ジョイン  [[metrics]](./query_profile_operator_metrics.md#join-operator)

![join_operator](../../_assets/Profile/join_operator.png)

Join Operator は明示的なジョインまたは暗黙のジョインを実装する役割を担っています。

実行中、ジョインオペレーターはパイプラインエンジン内で並行して実行される Build (ハッシュテーブル構築) と Probe フェーズに分割されます。ベクターチャンク（最大 4096 行）は SIMD でバッチハッシュされ、消費されたキーはランタイムフィルター（Bloom または IN フィルター）を生成し、プローブ入力を早期に削減するために上流のスキャンにプッシュバックされます。

**ジョイン戦略**

StarRocks は、ベクトル化され、パイプラインに適したハッシュジョインコアに依存しており、コストベースオプティマイザがプラン時に検討する4つの物理戦略に接続できます。

| 戦略 | オプティマイザが選択する条件 | 高速化の要因 |
|----------|-----------------------------|---------------------|
| Colocate Join | 両方のテーブルが同じコロケーショングループに属している（同一のバケットキー、バケット数、レプリカレイアウト）。  | ネットワークシャッフルなし: 各 BE はローカルバケットのみをジョインします。 |
| Bucket-Shuffle Join | ジョインテーブルの一つがジョインキーと同じバケットキーを持っている | ジョインテーブルの一つだけをシャッフルする必要があり、ネットワークコストを削減できます |
| Broadcast Join | ビルド側が非常に小さい（行/バイトのしきい値または明示的なヒント）。  | 小さなテーブルがすべてのプローブノードに複製され、大きなテーブルのシャッフルを回避します。 |
| Shuffle (Hash) Join | 一般的なケースで、キーが一致しない。 | 各行をジョインキーでハッシュ分割し、プローブを BEs 間で均等にします。 |

#### 一般的なパフォーマンスボトルネック

**ビルド側のサイズオーバー** – `BuildHashTableTime` と `HashTableMemoryUsage` のスパイクは、ビルド側がメモリを超えていることを示します。プローブ/ビルドテーブルを入れ替え、ビルドテーブルを事前フィルタリングするか、ハッシュスピリングを有効にします。

**キャッシュに優しくないプローブ** – `SearchHashTableTime` が支配的な場合、プローブ側がキャッシュ効率が悪いです。プローブ行をジョインキーでソートし、ランタイムフィルターを有効にします。

**シャッフルスキュー** – 単一のフラグメントの `ProbeRows` が他のすべてを圧倒する場合、データがスキューしています。より高いカーディナリティのキーに切り替えるか、`key || mod(id, 16)` のようなソルトを追加します。

**意図しないブロードキャスト** – ジョインタイプ **BROADCAST** で巨大な `BytesSent` は、小さいと思っていたテーブルが実際にはそうでないことを示します。`broadcast_row_limit` を下げるか、`SHUFFLE` ヒントでシャッフルを強制します。

**ランタイムフィルターの欠如** – 小さな `JoinRuntimeFilterEvaluate` とフルテーブルスキャンは、ランタイムフィルターが伝播されなかったことを示唆します。ジョインを純粋な等式として書き直し、カラムタイプが一致していることを確認します。

**非等式フォールバック** – オペレータータイプが `CROSS` または `NESTLOOP` の場合、不等式または関数がハッシュジョインを妨げています。真の等式述語を追加するか、大きなテーブルを事前にフィルタリングします。

### 2.4 Exchange (ネットワーク)  [[metrics]](./query_profile_operator_metrics.md#exchange-operator)

**オーバーサイズのシャッフルまたはブロードキャスト** – `NetworkTime` が 30 % を超え、`BytesSent` が大きい場合、クエリは過剰なデータを送信しています。ジョイン戦略を再評価するか、Exchange Compaction (`pipeline_enable_exchange_compaction`) を有効にします。

**レシーバーのバックログ** – 送信者キューが常に満杯であるシンクでの高い `WaitTime` は、レシーバーが追いつけないことを示します。レシーバースレッドプール (`brpc_num_threads`) を増やし、NIC の帯域幅と QoS 設定を確認します。

### 2.5 ソート / マージ / ウィンドウ

さまざまなメトリクスを理解しやすくするために、マージは以下の状態メカニズムとして表現できます。

```plaintext
               ┌────────── PENDING ◄──────────┐
               │                              │
               │                              │
               ├──────────────◄───────────────┤
               │                              │
               ▼                              │
   INIT ──► PREPARE ──► SPLIT_CHUNK ──► FETCH_CHUNK ──► FINISHED
               ▲
               |
               | one traverse from leaf to root
               |
               ▼
            PROCESS
```

**ソートスピリング** – `MaxBufferedBytes` が約 2 GB を超えるか、`SpillBytes` がゼロでない場合、ソートフェーズがディスクにスピルしています。`LIMIT` を追加し、上流で事前集計するか、マシンに十分なメモリがある場合は `sort_spill_threshold` を引き上げます。

**マージの枯渇** – 高い `PendingStageTime` は、マージが上流のチャンクを待っていることを示します。プロデューサーオペレーターを最適化するか、パイプラインバッファを拡大します。

**広いウィンドウパーティション** – ウィンドウオペレーター内の巨大な `PeakBufferedRows` は、非常に広いパーティションまたはフレーム制限のない ORDER BY を示します。より細かくパーティション化し、`RANGE BETWEEN` 境界を追加するか、中間集計を実体化します。

---

## 3 · メモリ & スピル チートシート

| しきい値 | 注視すべき点 | 実際のアクション |
| --- | --- | --- |
| **80 %** の BE メモリ | `QueryPeakMemoryUsagePerNode` | セッションの `exec_mem_limit` を下げるか、BE RAM を追加 |
| スピル検出 (`SpillBytes` > 0) | `QuerySpillBytes`, 各オペレーターの `SpillBlocks` | メモリ制限を増やす; SR 3.2+ にアップグレードしてハイブリッドハッシュ/マージスピルを使用 |

---

## 4 · ポストモーテムのテンプレート

```text
1. 症状
   – 遅いステージ: 集計 (OperatorTotalTime 68 %)
   – 問題のある点: HashTableMemoryUsage 9 GB (> exec_mem_limit)
2. 根本原因
   – GROUP BY 高カーディナリティ UUID
3. 適用した修正
   – ソートされたストリーミング集計 + ロールアップ MV を追加
4. 結果
   – クエリ実行時間が 95 秒から 8 秒に短縮; メモリピーク 0.7 GB
```