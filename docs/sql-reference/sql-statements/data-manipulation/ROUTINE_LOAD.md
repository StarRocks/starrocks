# CREATE ROUTINE LOAD

## Description

Routine Load can stream Apache Kafka® events into StarRocks. It is an asynchronuous loading submitted by using MySQL protocol.

Currently, Routine Load supports to load CSV and JSON data from Kafka. As for security measures, Routine Load can connect to Kafka without authenticationen, cryption and authentication using SSL, as well as authentication using SASL.

This topic introduces CREATE ROUTINE LOAD‘s syntax, parameters and examples.

> For scenarios, principle and basic steps, please see [Continuously load data from Apache Kafka®](/loading/RoutineLoad.md) .

## Syntax

```SQL
CREATE ROUTINE LOAD [db.]job_name ON tbl_name

[load_properties]

[job_properties]

FROM data_source

[data_source_properties]
```

## Parameters

### [db.]job_name

The name of the import job, within the same database, can only have one job running with the same name.

### tbl_name

This specify the name of the table you want to import.

### load_properties

It is used to describe imported data. Syntax:

```SQL
[COLUMNS TERMINATED BY '<terminator>'],

[COLUMNS ([<column_name> [, ...] ] [, column_assignment [, ...] ] )],

[WHERE <expr>],

[PARTITION (<partition1_name>[, <partition2_name>, ...])]

[TEMPORARY PARTITION (<temporary_partition1_name>[, <temporary_partition2_name>, ...])]


column_assignment:

<column_name> = column_expression
```

- column_separator:

You can specify a column separator for the data in the CSV format. For example, specify a comma (,) as a column separator. Default to: \t.

```SQL
COLUMNS TERMINATED BY ","
```

- columns_mapping:

Specifies the mapping relationships of columns in the source data and define how derived columns are generated.

- Mapped column:

It specifies in order which columns in the source data correspond to which columns in the destination table. For columns you want to skip, you can specify a column name that does not exist. Suppose the destination table has three columns, k1, k2, v1. Source data has four columns, of which columns 1, 2, and 4 correspond to k2, k1, and v1, respectively. Write as follows:

```Plain_Text
COLUMNS (k2, k1, xxx, v1)
```

Here, xxx s a non-existent column used to skip the third column in the source data.

- Derived columns:

A column in the form of col_name = expr, we call a derived column. That is, expr is used to calculate the values of the corresponding columns in the destination table. Derived columns are usually queued after mapped columns, although this is not mandatory, StarRocks always parses the mapped columns before the derived columns. In the next example, suppose the destination table also has column 4, v2, which is generated by the sum of K1 and k2. Can be written as follows:

```Plain_Text
COLUMNS (k2, k1, xxx, v1, v2 = k1 + k2);
```

For the data in the CSV format, the number of mapping columns in `COLUMNS` must be consistent with the number of columns in the source data.

- where_predicates

It is used to specify filter conditions to filter out unnecessary columns. Filter columns can be mapped or derived columns. For example, if we only want to import columns with k1 greater than 100 and k2 equal to 1000, write as follows:

```Plain_Text
WHERE k1 > 100 and k2 = 1000
```

- partitions

It specifies which partitions to import into the destination table. If not specified, it is automatically imported into the corresponding partition.Example:

```Plain_Text
PARTITION(p1, p2, p3)
```

- `TEMPORARY PARTITION`

The name of the [temporary partition](../../../table_design/Temporary_partition.md) into which you want to load data. You can specify multiple temporary partitions, which must be separated by commas (,).

### job_properties

General parameters used to specify routine import jobs.

Syntax:

```SQL
PROPERTIES (

| **Property**              | **Required** | **Description**                                              |
| ------------------------- | ------------ | ------------------------------------------------------------ |
| desired_concurrent_number | No           | The expected task parallelism of a single Routine Load job. Default value: `3`. The actual task parallelism is determined by the minimum value of the multiple parameters: `min(alive_be_number, partition_number, desired_concurrent_number, max_routine_load_task_concurrent_num)`. <ul><li>`alive_be_number`: the number of alive BE nodes.</li><li>`partition_number`: the number of partitions to be consumed.</li><li>`desired_concurrent_number`: the expected task parallelism of a single Routine Load  job. Default value: `3`.</li><li>`max_routine_load_task_concurrent_num`: the default maximum task parallelism of a Routine Load job, which is `5`. See [FE dynamic parameter](../../../administration/Configuration.md#configure-fe-dynamic-parameters).</li></ul>The maximum actual task parallelism is determined by either the number of alive BE nodes or the number of partitions to be consumed.|
| max_batch_interval        | No           | The scheduling interval for a task, that is, how often a task is executed. Unit: seconds. Value range: `5` ~ `60`. Default value: `10`. It is recommended to set a value larger than `10`. If the scheduling is shorter than 10 seconds, too many tablet versions are generated due to an excessively high loading frequency. |
| max_batch_rows            | No           | This property is only used to define the window of error detection. The window is the number of rows of data consumed by a single Routine Load task. The value is `10 * max_batch_rows`. The default value is `10 * 200000 = 200000`. The Routine Load task detects error data in the error detection window. Error data refers to data that StarRocks cannot parse, such as invalid JSON-formatted data. |
| max_error_number          | No           | The maximum number of error data rows allowed within an error detection window. If the number of error data rows exceeds this value, the load job will pause. You can execute [SHOW ROUTINE LOAD](./SHOW_ROUTINE_LOAD.md)  and view the error logs by using `ErrorLogUrls`.  After that, you can correct the error in Kafka according to the error logs. The default value is `0`, which means error rows are not allowed.<br>**NOTE** <br>Error data rows do not include data rows that are filtered out by the WHERE clause. |
| strict_mode               | No           | Specifies whether to enable the [strict mode](../../../loading/load_concept/strict_mode.md). Valid values: `true` and `false`. Default value: `false`. When the strict mode is enabled, if the value for a column in the loaded data is `NULL` but the target table does not allow a `NULL` value for this column, the data row will be filtered out. |
| timezone                  | No           | The time zone used by the load job. Default value: `Asia/Shanghai`. The value of this parameter affects the results returned by functions such as strftime(), alignment_timestamp(), and from_unixtime(). The time zone specified by this parameter is a session-level time zone. For more information, see [Configure a time zone](../../../administration/timezone.md). |
| merge_condition           | No           | Specifies the name of the column you want to use as the condition to determine whether to update data. Data will be updated only when the value of the data to be loaded into this column is greater than or equal to the current value of this column. For more information, see [Change data through loading](../../../loading/Load_to_Primary_Key_tables.md).<br>**NOTE**<br>Only tables that use the Primary Key model support conditional updates. The column that you specify cannot be a primary key column. |
| format                    | No           | The format of the data to be loaded. Valid values: `CSV` and `JSON`. Default value: `CSV`. |
| strip_outer_array         | No           | Specifies whether to strip the outermost array structure of the JSON-formatted data. Valid values: `true` and `false`. Default value: `false`. In real-world business scenarios, JSON-formatted data may have an outermost array structure as indicated by a pair of square brackets `[]`. In this situation, we recommend that you set this parameter to `true`, so StarRocks removes the outermost square brackets `[]` and loads each inner array as a separate data record. If you set this parameter to `false`, StarRocks parses the entire JSON-formatted data into one array and loads the array as a single data record. Use the JSON-formatted data `[{"category" : 1, "author" : 2}, {"category" : 3, "author" : 4} ]` as an example. If you set this parameter to `true`, `{"category" : 1, "author" : 2}` and `{"category" : 3, "author" : 4}` are parsed as two separate data records and are loaded into two StarRocks data rows. |
| jsonpaths                 | No           | The names of the fields that you want to load from JSON-formatted data. The value of this parameter is a valid JsonPath expression. For more information, see [Configure column mapping for loading JSON-formatted data](#configure-column-mapping-for-loading-json-formatted-data) in this topic. |
| json_root                 | No           | The root element of the JSON-formatted data to load. StarRocks extracts the elements of the root node through `json_root` for parsing. By default, the value of this parameter is empty, indicating that all JSON-formatted data will be loaded. For more information, see [Specify the root element of the JSON-formatted data to be loaded](#specify-the-root-element-of-the-json-formatted-data-to-be-loaded) in this topic. |

### `data_source`, `data_source_properties`

Required. The data source and relevant properties.

```sql
FROM <data_source>
 ("<key1>" = "<value1>"[, "<key2>" = "<value2>" ...])
```

We currently support the following parameters:

- `desired_concurrent_number`

Expected concurrency. A routine import job is divided into subtasks to execute. This parameter specifies the maximum number of tasks a job can perform simultaneously. Must be greater than 0. Default is 3. This concurrency degree is not the actual concurrency degree. The actual concurrency degree is considered by the number of nodes in the cluster, the load, and the data source. Example:

"desired_concurrent_number" = "3"

- `max_batch_interval`

Task scheduling time, which is how often a task executes, defaults to 10s. Task consumption data time is routine*in fe.conf Load_Task_Consume_Second, defaults to 3s. Task execution timeout is routine_in fe.conf Load* Task_Timeout_Second, defaults to 15s. Example:

"max_batch_interval" = "20"

- `max_error_number/max_batch_rows`

Maximum number of error rows allowed in the sampling window. Must be greater than or equal to 0. The default is 0, which means no error lines are allowed. Sampling window is max*Batch_Rows 10, defaulted to `(200000 10 = 2000000)`. That is, if the number of error rows is greater than max_within the sampling window Error* Number causes routine operations to be suspended and requires manual intervention to check for data quality issues. Rows filtered by where criteria are not erroneous rows.

- `strict_mode`

Whether strict mode is on or off by default. If turned on, column type transformations for non-empty raw data are filtered if the result is NULL. Specify "strict_mode" = "true"

- `timezone`

Specify the time zone used by the import job. The default is to use the timezone parameter of Session. This parameter affects the results of all time zone related functions involved in importing.

- `format`

Specify the time zone used by the import job. The default is to use the timezone parameter of Session. This parameter affects the results of all time zone related functions involved in importing.

- `jsonpaths`

Jsonpaths: There are two ways to import json: simple mode and matching mode. If jsonpath is set, it is a matching mode import, otherwise it is a simple mode import, you can refer to an example.

- `strip_outer_array`

Boolean type, true, indicates that the JSON data starts with an array object and flattens it in the array object, defaulting to false.

- `json_root`

Json_ Root is a legal jsonpath string that specifies the root node of the JSON document with a default value of''.

### data_source

Type of data source. It currently supports: Apache Kafka

### data_source_properties

It specifies information about the data source.

Syntax:

```SQL
(

"key1" = "val1",

"key2" = "val2"

)
```

- Apache Kafka
  - `kafka_broker_list`

```Plain_Text
kafka's broker connection information. The format is ip:host. Multiple brokers are separated by commas.

Example:



"kafka_broker_list" = "broker1:9092,broker2:9092"
```

- `kafka_topic`

```Plain_Text
Specify a topic for Kafka to subscribe to.

Example:



"kafka_topic" = "my_topic"
```

- `kafka_partitions/kafka_offsets`

```Plain_Text
Specify the kafka partition you want to subscribe to, and the starting offset for each of the corresponding partitions.

offset can specify a specific offset greater than or equal to 0, or:



1. OFFSET_BEGINNING: Subscribe from a location with data.

2. OFFSET_END: Subscribe from the end.



Default from OFFSET_if not specified END starts subscribing to all partitions under top.

Example:



"kafka_partitions" = "0,1,2,3",

"kafka_offsets" = "101,0,OFFSET_BEGINNING,OFFSET_END"
```

- `property`

```Plain_Text
specify custom kafka parameters.

The function is equivalent to the"--property" parameter in the kafka shell.

When the value of a parameter is a file, the keyword "FILE:" needs to be added before the value.

For information on how to create a file, see CREATE FILE.

For more supported custom parameters, see the client-side configuration item in librdkafka's official CONFIGURATION document.

Example:

"property.client.id" = "12345",

"property.ssl.ca.location" = "FILE:ca-cert"



1.When connecting to Kafka using SSL, the following parameters need to be specified:

"property.security.protocol" = "ssl",

"property.ssl.ca.location" = "FILE:ca-cert",



Where:

"property.security.protocol" is used to indicate that the connection is SSL.

"property.ssl.ca.location" is used when be accesses kafka, specifying the location of the CA certificate.

If client authentication is turned on on at the Kafka server side, settings are also required:

"property.ssl.certificate.location" = "FILE:client.pem",

"property.ssl.key.location" = "FILE:client.key",

"property.ssl.key.password" = "abcdefg",



Where:

"property.ssl.certificate.location" specifies the location of public key of client.

"property.ssl.key.location" specifies the location of private key of client.

"property.ssl.key.password" specifies the password of private key of client.



2.When connecting Kafka using SASL, the following parameters need to be specified:

"property.security.protocol"="SASL_PLAINTEXT",

"property.sasl.mechanism"="PLAIN",

"property.sasl.username"="admin",

"property.sasl.password"="admin"



Where:

"property.security.protocol" specifies that the protocol is SASL_ PLAINTEXT.

"property.sasl.mechanism" specifies that the authentication method for SASL is PLAIN.

"property.sasl.username" specifies the user name of sasl.

"property.sasl.password" specifies the password for sasl.



3.Specify the default starting offset for Kafka partition

If kafka_is not specified Partitions/kafka_ Offsets, consumes all partitions by default, at which point kafka_can be specified Default_ Offsets specify the starting offset. Default to OFFSET_ END, subscribe from the end.

Value is: 

1.OFFSET_BEGINNING: Subscribe from a location with data.

2.OFFSET_END: Subscribe from the end.

Example:

"property.kafka_default_offsets" = "OFFSET_BEGINNING
```

Sample Import Data Format

- Integer Type (TINYINT/SMALLINT/INT/BIGINT/LARGEINT): 1, 1000, 1234
- Floating Point Type (FLOAT/DOUBLE/DECIMAL): 1.1, 0.23, .356
- Date and Time Type (DATE/DATETIME): 2017-10-03, 2017-06-13 12:34:03
- String Type (CHAR/VARCHAR) without quotation marks: I am a student, a
- NULL Value: \N

## Examples

- Create a kafka routine import task named test1 for example_tbl in example_db. Specify the column separator, group.id and client.id, automatically consume all partitions by default, and subscribe from a location with data (OFFSET_BEGINNING).

```SQL
CREATE ROUTINE LOAD example_db.test1 ON example_tbl

COLUMNS TERMINATED BY ",",

COLUMNS(k1, k2, k3, v1, v2, v3 = k1 * 100)

PROPERTIES

(

    "desired_concurrent_number"="3",

    "max_batch_interval" = "20",

    "strict_mode" = "false"

)

FROM KAFKA

(

    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",

    "kafka_topic" = "my_topic",

    "property.group.id" = "xxx",

    "property.client.id" = "xxx",

    "property.kafka_default_offsets" = "OFFSET_BEGINNING"

);
```

- Create a kafka routine import task named test1 for example_tbl in example_db. The import task is in strict mode.

```SQL
CREATE ROUTINE LOAD example_db.test1 ON example_tbl

COLUMNS(k1, k2, k3, v1, v2, v3 = k1 * 100),

WHERE k1 > 100 and k2 like "%starrocks%"

PROPERTIES

(

    "desired_concurrent_number"="3",

    "max_batch_interval" = "20",

    "strict_mode" = "true"

)

FROM KAFKA

(

    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",

    "kafka_topic" = "my_topic",

    "kafka_partitions" = "0,1,2,3",

    "kafka_offsets" = "101,0,0,200"

);
```

- Import data from the Kafka cluster using SSL authentication. The client.id parameter is also set. Import task is in non-strict mode and time zone is Africa/Abidjan.

```SQL
CREATE ROUTINE LOAD example_db.test1 ON example_tbl

COLUMNS(k1, k2, k3, v1, v2, v3 = k1 * 100),

WHERE k1 > 100 and k2 like "%starrocks%"

PROPERTIES

(

    "desired_concurrent_number"="3",

    "max_batch_interval" = "20",

    "strict_mode" = "false",

    "timezone" = "Africa/Abidjan"

)

FROM KAFKA

(

    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",

    "kafka_topic" = "my_topic",

    "property.security.protocol" = "ssl",

    "property.ssl.ca.location" = "FILE:ca.pem",

    "property.ssl.certificate.location" = "FILE:client.pem",

    "property.ssl.key.location" = "FILE:client.key",

    "property.ssl.key.password" = "abcdefg",

    "property.client.id" = "my_client_id"

);
```

- Import JSON in simple mode.

```SQL
CREATE ROUTINE LOAD example_db.test_json_label_1 ON table1

COLUMNS(category,price,author)

PROPERTIES

(

    "desired_concurrent_number"="3",

    "max_batch_interval" = "20",

    "strict_mode" = "false",

    "format" = "json"

)

FROM KAFKA

(

    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",

    "kafka_topic" = "my_topic",

    "kafka_partitions" = "0,1,2",

    "kafka_offsets" = "0,0,0"

);

Two JSON data formats are supported:

- {"category":"a9jadhx","author":"test","price":895}

- [

{"category":"a9jadhx","author":"test","price":895},

{"category":"axdfa1","author":"EvelynWaugh","price":1299}

]
```

- Precise import of JSON data format:

```SQL
CREATE TABLE `example_tbl` (

`category` varchar(24) NULL COMMENT "",

`author` varchar(24) NULL COMMENT "",

`timestamp` bigint(20) NULL COMMENT "",

`dt` int(11) NULL COMMENT "",

`price` double REPLACE

) ENGINE=OLAP

AGGREGATE KEY(`category`,`author`,`timestamp`,`dt`)

COMMENT "OLAP"

PARTITION BY RANGE(`dt`)

(PARTITION p0 VALUES [("-2147483648"), ("20200509")),

PARTITION p20200509 VALUES [("20200509"), ("20200510")),

PARTITION p20200510 VALUES [("20200510"), ("20200511")),

PARTITION p20200511 VALUES [("20200511"), ("20200512")))

DISTRIBUTED BY HASH(`category`,`author`,`timestamp`) BUCKETS 4

PROPERTIES (

    "storage_type" = "COLUMN",

    "replication_num" = "1"

);



CREATE ROUTINE LOAD example_db.test1 ON example_tbl

COLUMNS(category, author, price, timestamp, dt=from_unixtime(timestamp, '%Y%m%d'))

PROPERTIES

(

    "desired_concurrent_number"="3",

    "max_batch_interval" = "20",

    "strict_mode" = "false",

    "format" = "json",

    "jsonpaths" = "[\"$.category\",\"$.author\",\"$.price\",\"$.timestamp\"]",

    "strip_outer_array" = "true"

)

FROM KAFKA

(

    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",

    "kafka_topic" = "my_topic",

    "kafka_partitions" = "0,1,2",

    "kafka_offsets" = "0,0,0"

);

JSON data format:

[

{"category":"11","title":"SayingsoftheCentury","price":895,"timestamp":1589191587},

{"category":"22","author":"2avc","price":895,"timestamp":1589191487},

{"category":"33","author":"3avc","title":"SayingsoftheCentury","timestamp":1589191387}

]
```

Note:

- If the JSON data starts with an array and each object in the array is a record, strip*is required Outer* Array is set to true to flatten the array.
- If the JSON data starts with an array and each object in the array is a record, our ROOT node is actually an object in the array when setting jsonpath.

- Users specify root node json_ root.

```SQL
CREATE ROUTINE LOAD example_db.test1 ON example_tbl

COLUMNS(category, author, price, timestamp, dt=from_unixtime(timestamp, '%Y%m%d'))

PROPERTIES

(

    "desired_concurrent_number"="3",

    "max_batch_interval" = "20",

    "strict_mode" = "false",

    "format" = "json",

    "jsonpaths" = "[\"$.category\",\"$.author\",\"$.price\",\"$.timestamp\"]",

    "strip_outer_array" = "true",

    "json_root" = "$.RECORDS"

)

FROM KAFKA

(

    "kafka_broker_list" = "broker1:9092,broker2:9092,broker3:9092",

    "kafka_topic" = "my_topic",

    "kafka_partitions" = "0,1,2",

    "kafka_offsets" = "0,0,0"

);

JSON data format:

{

"RECORDS":[

{"category":"11","title":"SayingsoftheCentury","price":895,"timestamp":1589191587},

{"category":"22","author":"2avc","price":895,"timestamp":1589191487},

{"category":"33","author":"3avc","title":"SayingsoftheCentury","timestamp":1589191387}

]

}
```
