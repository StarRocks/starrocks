# AUTO_INCREMENT

Since version 3.0, StarRocks supports the `AUTO_INCREMENT` attribute, which can simplify data management. This topic introduces the application scenario, usage and features of the `AUTO_INCREMENT` attribute.

## Introduction

When a new data record is inserted, StarRocks automatically assigns a globally unique integer value for the record's `AUTO_INCREMENT` column as its unique ID, and the subsequent values for the `AUTO_INCREMENT` column automatically increase at a specific step starting from the ID of the record. `AUTO_INCREMENT` columns can be used to simplify data management and speed up some queries. Here are some application scenarios of `AUTO_INCREMENT` columns:

- Serve as primary keys: `AUTO_INCREMENT` columns can be used as primary keys to ensure that each record has a unique ID and make it easy to query and manage data.
- Join tables: When multiple tables are joined, `AUTO_INCREMENT` columns can be used as Join Keys, which can expedite queries compared to using columns whose data types are UUID and STRING.
- Count the number of distinct values in a high-cardinality column: An `AUTO_INCREMENT` column can be used to represent the unique value column in a dictionary. Compared to directly counting distinct STRING values, counting distinct integer values of the`AUTO_INCREMENT` column can sometimes improve the query speed by several times or even tens of times.

You need to specify `AUTO_INCREMENT` columns in the CREATE TABLE statement. The data types of `AUTO_INCREMENT` columns must be BIGINT. The values for an AUTO_INCREMENT column can be [implicitly assigned](#Assign values implicitly) or [explicitly specified](#Specify values explicitly). They start from 1, and increment by 1 for each new record.

## Basic operations

### Specify `AUTO_INCREMENT` column at table creation

Create a table named `t` with two columns, `id` and `number`. Specify the column `number` as the `AUTO_INCREMENT` column.

```SQL
CREATE TABLE t
(
    id BIGINT NOT NULL, 
    number BIGINT NOT NULL AUTO_INCREMENT
) 
PRIMARY KEY (id) 
DISTRIBUTED BY HASH(id)
PROPERTIES("replicated_storage" = "true");
```

### Assign values for `AUTO_INCREMENT` column

#### Assign values implicitly

When data is loaded into a StarRocks table, you do not need to specify the values or specify the values as `DEFAULT` for the `AUTO_INCREMENT` column. StarRocks automatically assigns unique integer values for that column and inserts them into the table.

```SQL
INSERT INTO t (id) VALUES (1);
INSERT INTO t (id, number) VALUES (2, DEFAULT);

-- view table data
SELECT * FROM t;
+------+--------+
| id   | number |
+------+--------+
|    1 |      1 |
|    2 |      2 |
+------+--------+
2 rows in set (0.08 sec)
```

> **NOTE**
>
> When you use this feature, it is not guaranteed that the values for the `AUTO_INCREMENT` column are strictly monotonic. It can only be ensured that the values roughly increase in chronological order. For more information, see [Monotonicity](#monotonicity).

#### Specify values explicitly

You can also explicitly specify the values for the `AUTO_INCREMENT` column and insert them into the table.

```SQL
INSERT INTO t (id, number) VALUES (3, 100);

-- view table
SELECT * FROM t;
+------+--------+
| id   | number |
+------+--------+
|    1 |      1 |
|    2 |      2 |
|    3 |    100 |
+------+--------+
3 rows in set (0.01 sec)
```

Moreover, explicitly specifying values does not affect the subsequent values generated by StarRocks for newly inserted data rows.

```SQL
INSERT INTO t (id) VALUES (4);

-- view table
SELECT * FROM t;
+------+--------+
| id   | number |
+------+--------+
|    1 |      1 |
|    2 |      2 |
|    3 |    100 |
|    4 |      3 |
+------+--------+
4 rows in set (0.02 sec)
```

## Basic features

### Uniqueness

In general, StarRocks guarantees that the values for the `AUTO_INCREMENT` columns are globally unique. We recommend that you do not explicitly assign and implicitly specify the values for the `AUTO_INCREMENT` columns at the same time. If you do so, it may break the global uniqueness of auto-incremented IDs. Here is a simple example: Create a table named `t` with two columns, `id` and `number`. Specify the column `number` as the `AUTO_INCREMENT` column.

```SQL
CREATE TABLE t
(
    id BIGINT NOT NULL,
    number BIGINT NOT NULL AUTO_INCREMENT
 ) 
PRIMARY KEY (id) 
DISTRIBUTED BY HASH(id)
PROPERTIES("replicated_storage" = "true");
```

Explicitly assign and implicitly specify the values for the `AUTO_INCREMENT` column `number` in the table `t`ã€‚

```SQL
INSERT INTO t (id, number) VALUES (1, DEFAULT);
INSERT INTO t (id, number) VALUES (2, 2);
INSERT INTO t (id, number) VALUES (3);
```

Query the table `t`.

```SQL
SELECT * FROM t;
+------+--------+
| id   | number |
+------+--------+
|    1 |      1 |
|    2 |      2 |
|    3 |      2 |
+------+--------+
3 rows in set (0.08 sec)
```

### Monotonicity

In order to improve the performance of allocating auto-incremented IDs, the BEs cache some auto-incremented IDs locally. In this situation, StarRocks cannot guarantee that the values for the `AUTO_INCREMENT` column are strictly monotonic. It can only be ensured that the values roughly increase in chronological order.

> **NOTE**
>
> The number of auto-incremented IDs cached by the BEs is determined by the FE dynamic parameter `auto_increment_cache_size`, which defaults to `100,000`. You can modify the value by using `ADMIN SET FRONTEND CONFIG ("auto_increment_cache_size" = "xxx");`

For example, a StarRocks cluster has one FE node and two BE nodes. Create a table named `t` and insert five rows of data as follows:

```SQL
CREATE TABLE t
(
    id BIGINT NOT NULL,
    number BIGINT NOT NULL AUTO_INCREMENT
) 
PRIMARY KEY (id)
DISTRIBUTED BY HASH(id)
PROPERTIES("replicated_storage" = "true");

INSERT INTO t VALUES (1, DEFAULT);
INSERT INTO t VALUES (2, DEFAULT);
INSERT INTO t VALUES (3, DEFAULT);
INSERT INTO t VALUES (4, DEFAULT);
INSERT INTO t VALUES (5, DEFAULT);
```

The auto-incremented IDs in the table `t` do not monotonically increase, because the two BE nodes cache auto-incremented IDs, [1, 100000] and [100001, 200000], respectively. When data is loaded by using multiple INSERT statements, the data is sent to different BE nodes which allocate auto-incremented IDs independently. Therefore, it cannot be guaranteed that auto-incremented IDs are strictly monotonic.

```SQL
SELECT * FROM t;
+------+--------+
| id   | number |
+------+--------+
|    1 |      1 |
|    2 | 100001 |
|    3 |      2 |
|    4 | 100002 |
|    5 |      3 |
+------+--------+
5 rows in set (0.07 sec)
```

## Partial updates and `AUTO_INCREMENT` columns

This section explains how to update only a few specified columns in a table that contains an `AUTO_INCREMENT` column.

> **NOTE**
>
> Currently, only primary key tables support partial updates.

### `AUTO_INCREMENT` column is primary key

You need to specify the primary key during partial updates. Therefore, if the `AUTO_INCREMENT` column is the primary key or part of the primary key, the user behavior for partial updates is exactly the same as when the `AUTO_INCREMENT` column is not defined.

1. Create a table `t` in the database `example_db` and insert one data row.

    ```SQL
    -- Create a table.
    CREATE TABLE t
    (
        id BIGINT AUTO_INCREMENT,
        name BIGINT NOT NULL,
        job1 BIGINT NOT NULL,
        job2 BIGINT NOT NULL
    ) 
    PRIMARY KEY (id, name)
    DISTRIBUTED BY HASH(id)
    PROPERTIES("replicated_storage" = "true");

    -- Prepared data.
    INSERT INTO t (id, name, job1, job2) VALUES (0, 0, 1, 1);
    Query OK, 1 row affected (0.04 sec)
    {'label':'insert_6af28e77-7d2b-11ed-af6e-02424283676b', 'status':'VISIBLE', 'txnId':'152'}

    -- Query the table.
    SELECT * FROM t ORDER BY name;
    +------+------+------+------+
    | id   | name | job1 | job2 |
    +------+------+------+------+
    |    0 |    0 |    1 |    1 |
    +------+------+------+------+
    1 row in set (0.01 sec)
    ```

2. Prepare the CSV file **my_data.csv** to update table `t`. The CSV file includes values for the `AUTO_INCREMENT` column and does not include values for the column `job1`. The primary key of the first row already exists in table `t`, while the primary key of the second row does not exist in the table.

    ```Plaintext
    0,0,99
    1,1,99
    ```

3. Run a Stream Load job and use the CSV file to update table `t`.

    ```Bash
    curl --location-trusted -u root: -H "label:123" \
        -H "column_separator:," \
        -H "partial_update:true" \
        -H "columns:id,name,job2" \
        -T my_data.csv -XPUT \
        http://<fe_host>:<fe_http_port>/api/example_db/t/_stream_load
    ```

4. Query the updated table. The first row of data already exists in table `t`, and the value for the column `job1` remains unchanged. The second row of data is newly inserted, and because the default value for the column `job1` is not specified, the partial update framework directly sets the value for this column to `0`.

    ```SQL
    SELECT * FROM t ORDER BY name;
    +------+------+------+------+
    | id   | name | job1 | job2 |
    +------+------+------+------+
    |    0 |    0 |    1 |   99 |
    |    1 |    1 |    0 |   99 |
    +------+------+------+------+
    2 rows in set (0.01 sec)
    ```

### `AUTO_INCREMENT` column is not primary key

If the `AUTO_INCREMENT` column is not a primary key or a part of the primary key, and auto-incremented IDs are not provided in a Stream Load job, the following situations occur:

- If the row already exists in the table, StarRocks does not update the auto-incremented ID.
- If the row is newly loaded into the table, StarRocks generates a new auto-incremented ID.

This feature can be used to build a dictionary table for accelerating the counting of distinct STRING values.

1. In the database `example_db`, create a table `t` and specify the column `job1` as the `AUTO_INCREMENT` column and insert a data row into the table `t`.

    ```SQL
    -- Create a table.
    CREATE TABLE t
    (
        id BIGINT NOT NULL,
        name BIGINT NOT NULL,
        job1 BIGINT NOT NULL AUTO_INCREMENT,
        job2 BIGINT NOT NULL
    )
    PRIMARY KEY (id, name)
    DISTRIBUTED BY HASH(id)
    PROPERTIES("replicated_storage" = "true");

    -- Prepare data.
    INSERT INTO t VALUES (0, 0, -1, -1);
    Query OK, 1 row affected (0.04 sec)
    {'label':'insert_458d9487-80f6-11ed-ae56-aa528ccd0ebf', 'status':'VISIBLE', 'txnId':'94'}

    -- Query the table.
    SELECT * FROM t ORDER BY name;
    +------+------+------+------+
    | id   | name | job1 | job2 |
    +------+------+------+------+
    |    0 |    0 |   -1 |   -1 |
    +------+------+------+------+
    1 row in set (0.01 sec)
    ```

2. Prepare a CSV file **my_data.csv** to update table `t`. The CSV file does not contain values for the `AUTO_INCREMENT` column `job1`. The primary key of the first row already exists in the table while the primary keys of the second and third rows do not.

    ```Plaintext
    0,0,99
    1,1,99
    2,2,99
    ```

3. Run a Stream Load job to load data from the CSV file into table `t`.

    ```Bash
    curl --location-trusted -u root: -H "label:123" \
        -H "column_separator:," \
        -H "partial_update:true" \
        -H "columns: id,name,job2" \
        -T my_data.csv -XPUT \
        http://<fe_host>:<fe_http_port>/api/example_db/t/_stream_load
    ```

4. Query the updated table. The first row of data already exists in table `t`, so the `AUTO_INCREMENT` column `job1` retains its original value. The second and third rows of data are newly inserted, so StarRocks generate new values for the `AUTO_INCREMENT` column `job1`.

    ```SQL
    SELECT * FROM t ORDER BY name;
    +------+------+--------+------+
    | id   | name | job1   | job2 |
    +------+------+--------+------+
    |    0 |    0 |     -1 |   99 |
    |    1 |    1 |      1 |   99 |
    |    2 |    2 | 100001 |   99 |
    +------+------+--------+------+
    3 rows in set (0.01 sec)
    ```

## Limits

- When a table with an `AUTO_INCREMENT` column is created, `"replicated_storage" = "true"` must be set to ensure that all replicas have the same auto-incremented IDs.
- Each table can have only one `AUTO_INCREMENT` column.
- The data type of the `AUTO_INCREMENT` column must be BIGINT.
- The `AUTO_INCREMENT` column must be `NOT NULL` and does not have a default value.
- If the `AUTO_INCREMENT` column is the primary key or part of the primary key, you can delete data in the Primary Key table. Otherwise, you cannot delete data in the Primary Key table.
- Adding the `AUTO_INCREMENT` attribute by using ALTER TABLE is not supported.
- Currently, StarRocks's shared-data mode does not support the `AUTO_INCREMENT` attribute.
- Setting the starting value and increment of the `AUTO_INCREMENT` column is not supported.
