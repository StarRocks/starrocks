// Copyright 2021-present StarRocks, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <memory>
#include <tuple>

#include "common/statusor.h"
#include "fs/fs.h"
#include "gen_cpp/persistent_index.pb.h"
#include "storage/edit_version.h"
#include "storage/pindex_common.h"
#include "storage/pindex_immutable_index.h"
#include "storage/pindex_mutable_index.h"
#include "storage/rowset/bloom_filter.h"
#include "storage/rowset/rowset.h"
#include "storage/storage_engine.h"
#include "util/phmap/phmap.h"
#include "util/phmap/phmap_dump.h"

namespace starrocks {

class Tablet;
class Schema;
class Column;
class PrimaryKeyDump;

class TabletLoader {
public:
    virtual ~TabletLoader() = default;
    virtual starrocks::Schema generate_pkey_schema() = 0;
    virtual DataDir* data_dir() = 0;
    virtual TTabletId tablet_id() = 0;
    // return latest applied (publish in cloud native) version
    virtual StatusOr<EditVersion> applied_version() = 0;
    // Do some special setting if need
    virtual void setting() = 0;
    // iterator all rowset and get their iterator and basic stat
    virtual Status rowset_iterator(
            const Schema& pkey_schema,
            const std::function<Status(const std::vector<ChunkIteratorPtr>&, uint32_t)>& handler) = 0;

    size_t total_data_size() const { return _total_data_size; }
    size_t total_segments() const { return _total_segments; }
    size_t rowset_num() const { return _rowset_num; };

protected:
    size_t _total_data_size = 0;
    size_t _total_segments = 0;
    size_t _rowset_num = 0;
};

namespace lake {
class LakeLocalPersistentIndex;
}

struct EditVersionWithMerge {
    EditVersionWithMerge(const EditVersion& ver, bool m) : version(ver), merged(m) {}
    EditVersionWithMerge(int64_t major, int64_t minor, bool m) : version(major, minor), merged(m) {}
    bool operator<(const EditVersionWithMerge& rhs) {
        if (version == rhs.version) {
            // version with .merged is bigger
            if (!merged && rhs.merged) {
                return true;
            } else {
                return false;
            }
        } else {
            return version < rhs.version;
        }
    }
    EditVersion version;
    // if this version is generated by major merge compaction
    bool merged{false};
};

struct IndexPage;
struct ImmutableIndexShard;
class PersistentIndex;
class ImmutableIndexWriter;
class ShardByLengthMutableIndex;

// A persistent primary index contains an in-memory L0 and an on-SSD/NVMe L1,
// this saves memory usage comparing to the orig all-in-memory implementation.
// This is a internal class and is intended to be used by PrimaryIndex internally.
//
// Currently primary index is only modified in TabletUpdates::apply process, it's
// typical use pattern in apply:
//   pi.prepare(version)
//   if (pi.upsert(upsert_keys, values, old_values))
//   pi.erase(delete_keys, old_values)
//   pi.commit()
//   pi.on_commited()
// If any error occurred between prepare and on_commited, abort should be called, the
// index maybe corrupted, currently for simplicity, the whole index is cleared and rebuilt.
class PersistentIndex {
public:
    // |path|: directory that contains index files
    PersistentIndex(std::string path);
    virtual ~PersistentIndex();

    bool loaded() const { return (bool)_l0; }

    std::string path() const { return _path; }

    size_t key_size() const { return _key_size; }

    size_t size() const { return _size; }
    size_t memory_usage() const { return _memory_usage.load(); }

    EditVersion version() const { return _version; }

    // create new empty index
    Status create(size_t key_size, const EditVersion& version);

    // load required states from underlying file
    Status load(const PersistentIndexMetaPB& index_meta);

    // build PersistentIndex from pre-existing tablet data
    Status load_from_tablet(Tablet* tablet);

    // start modification with intended version
    // | version |: intended commit version
    // | n |: deprecated
    Status prepare(const EditVersion& version, size_t n);

    // abort modification
    Status abort();

    // commit modification
    Status commit(PersistentIndexMetaPB* index_meta, IOStat* stat = nullptr);

    // apply modification
    Status on_commited();

    // batch index operations

    // batch get
    // |n|: size of key/value array
    // |keys|: key array as raw buffer
    // |values|: value array for return values
    virtual Status get(size_t n, const Slice* keys, IndexValue* values);

    Status get_from_one_immutable_index(ImmutableIndex* immu_index, size_t n, const Slice* keys, IndexValue* values,
                                        std::map<size_t, KeysInfo>* keys_info_by_key_size, KeysInfo* found_keys_info);

    // batch upsert
    // |n|: size of key/value array
    // |keys|: key array as raw buffer
    // |values|: value array
    // |old_values|: return old values for updates, or set to NullValue for inserts
    // |stat|: used for collect statistic
    virtual Status upsert(size_t n, const Slice* keys, const IndexValue* values, IndexValue* old_values,
                          IOStat* stat = nullptr);

    // batch insert, return error if key already exists
    // |n|: size of key/value array
    // |keys|: key array as raw buffer
    // |values|: value array
    // |check_l1|: also check l1 for insertion consistency(key must not exist previously), may imply heavy IO costs
    Status insert(size_t n, const Slice* keys, const IndexValue* values, bool check_l1);

    // batch erase
    // |n|: size of key/value array
    // |keys|: key array as raw buffer
    // |old_values|: return old values if key exist, or set to NullValue if not
    virtual Status erase(size_t n, const Slice* keys, IndexValue* old_values);

    // TODO(qzc): maybe unused, remove it or refactor it with the methods in use by template after a period of time
    // batch replace
    // |n|: size of key/value array
    // |keys|: key array as raw buffer
    // |values|: value array
    // |src_rssid|: rssid array
    // |failed|: return not match rowid
    [[maybe_unused]] Status try_replace(size_t n, const Slice* keys, const IndexValue* values,
                                        const std::vector<uint32_t>& src_rssid, std::vector<uint32_t>* failed);

    // batch replace
    // |n|: size of key/value array
    // |keys|: key array as raw buffer
    // |values|: value array
    // |max_src_rssid|: maximum of rssid array
    // |failed|: return not match rowid
    virtual Status try_replace(size_t n, const Slice* keys, const IndexValue* values, const uint32_t max_src_rssid,
                               std::vector<uint32_t>* failed);

    Status flush_advance();

    std::vector<int8_t> test_get_move_buckets(size_t target, const uint8_t* bucket_packs_in_page);

    Status test_flush_varlen_to_immutable_index(const std::string& dir, const EditVersion& version, size_t num_entry,
                                                const Slice* keys, const IndexValue* values);

    bool is_error() { return _error; }

    // just for unit test
    bool has_bf() { return _l1_vec.empty() ? false : _l1_vec[0]->has_bf(); }

    Status major_compaction(DataDir* data_dir, int64_t tablet_id, std::timed_mutex* mutex);

    Status TEST_major_compaction(PersistentIndexMetaPB& index_meta);

    static double major_compaction_score(const PersistentIndexMetaPB& index_meta);

    // not thread safe, just for unit test
    size_t kv_num_in_immutable_index() {
        size_t res = 0;
        for (int i = 0; i < _l1_vec.size(); i++) {
            res += _l1_vec[i]->total_size();
        }
        for (int i = 0; i < _l2_vec.size(); i++) {
            res += _l2_vec[i]->total_size();
        }
        return res;
    }

    Status reset(Tablet* tablet, EditVersion version, PersistentIndexMetaPB* index_meta);

    void reset_cancel_major_compaction();

    static void modify_l2_versions(const std::vector<EditVersion>& input_l2_versions,
                                   const EditVersion& output_l2_version, PersistentIndexMetaPB& index_meta);

    Status pk_dump(PrimaryKeyDump* dump, PrimaryIndexMultiLevelPB* dump_pb);

protected:
    Status _delete_expired_index_file(const EditVersion& l0_version, const EditVersion& l1_version,
                                      const EditVersionWithMerge& min_l2_version);

    uint64_t _l2_file_size() const;

    Status _load_by_loader(TabletLoader* loader);

private:
    size_t _dump_bound();

    void _set_error(bool error, const string& msg) {
        _error = error;
        _error_msg = msg;
    }
    // check _l0 should dump as snapshot or not
    bool _can_dump_directly();
    bool _need_flush_advance();
    bool _need_merge_advance();
    Status _flush_advance_or_append_wal(size_t n, const Slice* keys, const IndexValue* values,
                                        std::vector<size_t>* replace_idxes);
    Status _delete_major_compaction_tmp_index_file();
    Status _delete_tmp_index_file();

    Status _flush_l0();

    Status _merge_compaction_internal(ImmutableIndexWriter* writer, int l1_start_idx, int l1_end_idx,
                                      std::map<uint32_t, std::pair<int64_t, int64_t>>& usage_and_size_stat,
                                      bool keep_delete);
    Status _merge_compaction_advance();
    // merge l0 and l1 into new l1, then clear l0
    Status _merge_compaction();

    Status _load(const PersistentIndexMetaPB& index_meta, bool reload = false);
    Status _reload(const PersistentIndexMetaPB& index_meta);

    // commit index meta
    Status _build_commit(TabletLoader* loader, PersistentIndexMetaPB& index_meta);

    // insert rowset data into persistent index
    Status _insert_rowsets(TabletLoader* loader, const Schema& pkey_schema, std::unique_ptr<Column> pk_column);

    Status _get_from_immutable_index(size_t n, const Slice* keys, IndexValue* values,
                                     std::map<size_t, KeysInfo>& keys_info_by_key_size, IOStat* stat);

    Status _get_from_immutable_index_parallel(size_t n, const Slice* keys, IndexValue* values,
                                              std::map<size_t, KeysInfo>& keys_info_by_key_size);

    Status _update_usage_and_size_by_key_length(std::vector<std::pair<int64_t, int64_t>>& add_usage_and_size);

    void _get_stat_from_immutable_index(ImmutableIndex* immu_index, uint32_t key_size, size_t& total_size,
                                        size_t& total_usage);

    Status _minor_compaction(PersistentIndexMetaPB* index_meta);

    uint64_t _l1_l2_file_size() const;

    void _get_l2_stat(const std::vector<std::unique_ptr<ImmutableIndex>>& l2_vec,
                      std::map<uint32_t, std::pair<int64_t, int64_t>>& usage_and_size_stat);

    StatusOr<EditVersion> _major_compaction_impl(const std::vector<EditVersion>& l2_versions,
                                                 const std::vector<std::unique_ptr<ImmutableIndex>>& l2_vec);

    bool _enable_minor_compaction();

    size_t _get_tmp_l1_count();

    bool _l0_is_full(int64_t l1_l2_size = 0);

    bool _need_rebuild_index(const PersistentIndexMetaPB& index_meta);

    Status _reload_usage_and_size_by_key_length(size_t l1_idx_start, size_t l1_idx_end, bool contain_l2);

    // Calculate total memory usage after index been modified.
    void _calc_memory_usage();

protected:
    // index storage directory
    std::string _path;
    size_t _key_size = 0;
    size_t _size = 0;
    size_t _usage = 0;
    EditVersion _version;
    // _l1_version is used to get l1 file name, update in on_committed
    EditVersion _l1_version;
    std::unique_ptr<ShardByLengthMutableIndex> _l0;
    bool _has_l1 = false;
    std::shared_ptr<FileSystem> _fs;
    bool _dump_snapshot = false;
    bool _flushed = false;
    // add all l1 into vector
    std::vector<std::unique_ptr<ImmutableIndex>> _l1_vec;
    // The usage and size is not exactly accurate after reload persistent index from disk becaues
    // we ignore the overlap kvs between l0 and l1. The general accuracy can already be used as a
    // reference to estimate nshard and npages We don't persist the overlap kvs info to reduce the
    // write cost of PersistentIndexMeta
    std::map<uint32_t, std::pair<int64_t, int64_t>> _usage_and_size_by_key_length;
    std::vector<int> _l1_merged_num;
    // l2 files's version
    std::vector<EditVersionWithMerge> _l2_versions;
    // all l2
    std::vector<std::unique_ptr<ImmutableIndex>> _l2_vec;

    bool _cancel_major_compaction = false;

private:
    bool _need_bloom_filter = false;

    mutable std::mutex _get_lock;
    std::condition_variable _get_task_finished;
    size_t _running_get_task = 0;
    std::atomic<bool> _error{false};
    std::string _error_msg;
    std::vector<KeysInfo> _found_keys_info;
    // save bloom filter of l1 after merge compaction in order to skip read bloom filter file
    // std::vector<std::unique_ptr<BloomFilter>> _bf_vec;
    // set if major compaction is running
    std::atomic<bool> _major_compaction_running{false};
    // Latest major compaction time. In second.
    int64_t _latest_compaction_time = 0;
    // Re-calculated when commit end
    std::atomic<size_t> _memory_usage{0};
};

} // namespace starrocks
