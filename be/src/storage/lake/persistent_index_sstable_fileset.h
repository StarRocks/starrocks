// Copyright 2021-present StarRocks, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <map>
#include <memory>
#include <string>
#include <vector>

#include "base/string/slice.h"
#include "common/status.h"
#include "gen_cpp/lake_types.pb.h"
#include "storage/lake/types_fwd.h"
#include "storage/sstable/comparator.h"
#include "util/uid_util.h"

namespace starrocks {

class IndexValue;

namespace lake {
class PersistentIndexSstable;

// A fileset contains one or more sstables.
// And all sstables in a fileset have non-overlapping key ranges.
// Standalone sstable is used for old version persistent index without key range info.
class PersistentIndexSstableFileset {
public:
    PersistentIndexSstableFileset() = default;
    ~PersistentIndexSstableFileset() = default;

    Status init(std::vector<std::unique_ptr<PersistentIndexSstable>>& sstables);
    Status init(std::unique_ptr<PersistentIndexSstable>& sstable);
    // append a new sstable into this fileset.
    // Return false if the sstable overlaps with existing sstables.
    bool append(std::unique_ptr<PersistentIndexSstable>& sstable);
    UniqueId fileset_id() const { return _fileset_id; }
    bool is_standalone_sstable() const { return _standalone_sstable != nullptr; }
    // Check whether it's standalone sstable before call function.
    const std::string& standalone_sstable_filename() const;

    // multi get from sstable fileset
    Status multi_get(const Slice* keys, const KeyIndexSet& key_indexes, int64_t version, IndexValue* values,
                     KeyIndexSet* found_key_indexes) const;

    void get_all_sstable_pbs(PersistentIndexSstableMetaPB* sstable_pbs) const;

    size_t memory_usage() const;

    void print_debug_info(std::stringstream& ss);

private:
    struct KeyComparator {
        using is_transparent = void;

        // Compare two pairs by their first element (start_key)
        bool operator()(const std::pair<std::string, std::string>& a,
                        const std::pair<std::string, std::string>& b) const {
            return sstable::BytewiseComparator()->Compare(Slice(a.first), Slice(b.first)) < 0;
        }
        // Compare Slice with pair by comparing with pair's first element
        bool operator()(const Slice& a, const std::pair<std::string, std::string>& b) const {
            return sstable::BytewiseComparator()->Compare(a, Slice(b.first)) < 0;
        }
        // Compare pair with Slice by comparing pair's first element with Slice
        bool operator()(const std::pair<std::string, std::string>& a, const Slice& b) const {
            return sstable::BytewiseComparator()->Compare(Slice(a.first), b) < 0;
        }
    };

    bool is_inited() const { return !_sstable_map.empty() || _standalone_sstable != nullptr; }

    // From <start_key, end_key> to sstable_ptr
    std::map<std::pair<std::string, std::string>, std::unique_ptr<PersistentIndexSstable>, KeyComparator> _sstable_map;
    // standalone sstable, it was generated by old version persistent index without key range info
    std::unique_ptr<PersistentIndexSstable> _standalone_sstable;
    UniqueId _fileset_id;
};

} // namespace lake
} // namespace starrocks