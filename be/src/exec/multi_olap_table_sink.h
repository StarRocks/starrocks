// Copyright 2021-present StarRocks, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include "exec/async_data_sink.h"
#include "exec/tablet_sink.h"

namespace starrocks {

/**
 * @brief The MultiOlapTableSink class is a data sink that can handle multiple OLAP table sinks.
 * 
 * This class inherits from the DataSink class and provides methods for preparing, opening, adding chunks, closing
 */
class MultiOlapTableSink : public AsyncDataSink {
public:
    /**
     * @brief Constructs a MultiOlapTableSink object.
     * 
     * This constructor is used to construct the object from a thrift struct generated by the FE.
     */
    MultiOlapTableSink(ObjectPool* pool, const std::vector<TExpr>& texprs);

    /**
     * @brief Initializes the multi_olap_table_sink with the given TDataSink and RuntimeState.
     * 
     * @param sink The TDataSink object containing the configuration for the multi_olap_table_sink.
     * @param state The RuntimeState object representing the current runtime state.
     * @return The status of the initialization process.
     */
    Status init(const TDataSink& sink, RuntimeState* state) override;

    /**
     * @brief Destructor for the MultiOlapTableSink object.
     */
    ~MultiOlapTableSink() override = default;

    /**
     * @brief Prepares the MultiOlapTableSink for execution.
     * 
     * This method is called to perform any necessary preparations before executing the sink.
     * 
     * @param state The runtime state.
     * @return The status of the preparation.
     */
    Status prepare(RuntimeState* state) override;

    /**
     * @brief Opens the MultiOlapTableSink for writing.
     * 
     * This method is called to open the sink for writing data.
     * 
     * @param state The runtime state.
     * @return The status of the open operation.
     */
    Status open(RuntimeState* state) override;

    /**
     * @brief Tries to open the MultiOlapTableSink asynchronously.
     * 
     * This method is called to try opening the sink asynchronously.
     * call order: try_open() -> [is_open_done()] -> open_wait()
     * if is_open_done() return true, open_wait() will not block
     * otherwise open_wait() will block
     * 
     * @param state The runtime state.
     * @return The status of the try open operation.
     */
    Status try_open(RuntimeState* state) override;

    /**
     * @brief Checks if the MultiOlapTableSink is open.
     * 
     * This method is called to check if the sink is open.
     * 
     * @return True if the sink is open, false otherwise.
     */
    bool is_open_done() override;

    /**
     * @brief Waits for the MultiOlapTableSink to open.
     * 
     * This method is called to wait for the sink to finish opening.
     * 
     * @return The status of the open wait operation.
     */
    Status open_wait() override;

    /**
     * @brief Sends a chunk of data to the MultiOlapTableSink.
     * 
     * This method is called to send a chunk of data to the sink.
     * if is_full() return false, send_chunk() will not block
     * 
     * @param state The runtime state.
     * @param chunk The chunk of data to send.
     * @return The status of the send operation.
     */
    Status send_chunk_nonblocking(RuntimeState* state, Chunk* chunk) override;

    /**
     * @brief Checks if the MultiOlapTableSink is full.
     * 
     * This method is called to check if the sink is full and cannot accept more data.
     * 
     * @return True if the sink is full, false otherwise.
     */
    bool is_full() override;

    /**
     * @brief Tries to close the MultiOlapTableSink asynchronously.
     * 
     * This method is called to try closing the sink asynchronously.
     * call order: try_close() -> [is_close_done()] -> close_wait()
     * if is_close_done() return true, close_wait() will not block
     * otherwise close_wait() will block
     * 
     * @param state The runtime state.
     * @return The status of the try close operation.
     */
    Status try_close(RuntimeState* state) override;

    /**
     * @brief Waits for the MultiOlapTableSink to close.
     * 
     * This method is called to wait for the sink to finish closing.
     * 
     * @param state The runtime state.
     * @param close_status The status of the close operation.
     * @return The status of the close wait operation.
     */
    Status close_wait(RuntimeState* state, Status close_status) override;

    /**
     * @brief Checks if the MultiOlapTableSink is closed.
     * 
     * This method is called to check if the sink is closed.
     * 
     * @return True if the sink is closed, false otherwise.
     */
    bool is_close_done() override;

    /**
     * @brief Closes the MultiOlapTableSink.
     * 
     * This method is called to close the sink.
     * 
     * @param state The runtime state.
     * @param close_status The status of the close operation.
     * @return The status of the close operation.
     */
    Status close(RuntimeState* state, Status close_status) override;

    /**
     * @brief Returns the runtime profile for the MultiOlapTableSink.
     * 
     * This method is called to get the runtime profile for the sink.
     * 
     * @return The runtime profile for the sink.
     */
    RuntimeProfile* profile() override;

    /**
     * @brief Resets the epoch of the MultiOlapTableSink.
     * 
     * This method is called to reset the epoch of the sink.
     * 
     * @param state The runtime state.
     * @return The status of the epoch reset operation.
     */
    Status reset_epoch(RuntimeState* state);

    void set_profile(RuntimeProfile* profile) override;

private:
    friend class MultiOlapTableSinkTest;

    // for test
    void add_olap_table_sink(std::unique_ptr<OlapTableSink> sink);
    std::unique_ptr<OlapTableSink>& get_olap_table_sink(int index);

    ObjectPool* _pool;
    const std::vector<TExpr>& _texprs;
    std::vector<std::unique_ptr<OlapTableSink>> _sinks;
};

} // namespace starrocks