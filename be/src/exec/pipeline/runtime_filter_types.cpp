// Copyright 2021-present StarRocks, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "exec/pipeline/runtime_filter_types.h"

namespace starrocks::pipeline {

StatusOr<bool> PartialRuntimeFilterMerger::add_partial_filters(
        size_t idx, size_t ht_row_count, RuntimeInFilters&& partial_in_filters,
        OpTRuntimeBloomFilterBuildParams&& partial_bloom_filter_build_params,
        RuntimeMembershipFilters&& bloom_filter_descriptors) {
    DCHECK(idx < _partial_bloom_filter_build_params.size());
    // both _ht_row_counts, _partial_in_filters, _partial_bloom_filter_build_params are reserved beforehand,
    // each HashJoinBuildOperator mutates its corresponding slot indexed by driver_sequence, so concurrent
    // access need mutex to guard.
    _ht_row_counts[idx] = ht_row_count;
    _partial_in_filters[idx] = std::move(partial_in_filters);
    _partial_bloom_filter_build_params[idx] = std::move(partial_bloom_filter_build_params);

    return _try_do_merge(std::move(bloom_filter_descriptors));
}

Status PartialRuntimeFilterMerger::merge_local_in_filters() {
    bool can_merge_in_filters = true;
    size_t num_rows = 0;
    ssize_t k = -1;
    //squeeze _partial_in_filters and eliminate empty in-filter lists generated by empty hash tables.
    for (auto i = 0; i < _ht_row_counts.size(); ++i) {
        auto& in_filters = _partial_in_filters[i];
        // empty in-filter list is generated by empty hash tables, so skip it.
        if (_ht_row_counts[i] == 0) {
            continue;
        }
        // empty in-filter list is generated by non-empty hash tables(size>1024), in-filters can not be merged.
        if (in_filters.empty()) {
            can_merge_in_filters = false;
            break;
        }
        // move in-filter list indexed by i to slot indexed by k, eliminates holes in the middle.
        ++k;
        if (k < i) {
            _partial_in_filters[k] = std::move(_partial_in_filters[i]);
        }
        num_rows = std::max(num_rows, _ht_row_counts[i]);
    }

    can_merge_in_filters = can_merge_in_filters && (num_rows <= config::max_pushdown_conditions_per_column) && k >= 0;
    if (!can_merge_in_filters) {
        _partial_in_filters[0].clear();
        return Status::OK();
    }
    // only merge k partial in-filter list
    _partial_in_filters.resize(k + 1);

    auto& total_in_filters = _partial_in_filters[0];
    const auto num_in_filters = total_in_filters.size();
    for (auto i = 0; i < num_in_filters; ++i) {
        auto& total_in_filter = total_in_filters[i];
        if (total_in_filter == nullptr) {
            continue;
        }
        auto can_merge = std::all_of(_partial_in_filters.begin() + 1, _partial_in_filters.end(),
                                     [i](auto& in_filters) { return in_filters[i] != nullptr; });
        if (!can_merge) {
            total_in_filter = nullptr;
            continue;
        }
        for (int j = 1; j < _partial_in_filters.size(); ++j) {
            auto& in_filter = _partial_in_filters[j][i];
            DCHECK(in_filter != nullptr);
            auto* total_in_filter_pred = down_cast<Predicate*>(total_in_filter->root());
            auto* in_filter_pred = down_cast<Predicate*>(in_filter->root());
            RETURN_IF_ERROR(total_in_filter_pred->merge(in_filter_pred));
        }
    }
    total_in_filters.erase(std::remove(total_in_filters.begin(), total_in_filters.end(), nullptr),
                           total_in_filters.end());
    return Status::OK();
}

Status PartialRuntimeFilterMerger::merge_local_bloom_filters() {
    if (_bloom_filter_descriptors.empty()) {
        return Status::OK();
    }
    auto multi_partitioned = _bloom_filter_descriptors[0]->layout().pipeline_level_multi_partitioned();
    if (multi_partitioned) {
        return merge_multi_partitioned_local_bloom_filters();
    } else {
        return merge_singleton_local_bloom_filters();
    }
}

Status PartialRuntimeFilterMerger::merge_singleton_local_bloom_filters() {
    if (_partial_bloom_filter_build_params.empty() || _bloom_filter_descriptors.empty()) {
        return Status::OK();
    }

    // remove empty params that generated in two cases:
    // 1. the corresponding HashJoinProbeOperator is finished in short-circuit style because HashJoinBuildOperator
    // above this operator has constructed an empty hash table.
    // 2. the HashJoinBuildOperator is finished in advance because the fragment instance is canceled
    std::erase_if(_partial_bloom_filter_build_params, [](auto& opt_params) { return opt_params.empty(); });
    // there is no non-empty params, set all runtime filter to nullptr
    if (_partial_bloom_filter_build_params.empty()) {
        for (auto& desc : _bloom_filter_descriptors) {
            desc->set_runtime_filter(nullptr);
        }
        return Status::OK();
    }

    const size_t row_count = std::accumulate(_ht_row_counts.begin(), _ht_row_counts.end(), size_t{0});

    const auto join_mode = _bloom_filter_descriptors[0]->join_mode();
    const bool is_version_v3 = _func_version >= RF_VERSION_V3;
    const bool maybe_use_bitset_filter =
            _enable_join_runtime_bitset_filter && is_version_v3 && row_count <= _global_rf_limit &&
            join_mode == TRuntimeFilterBuildJoinMode::BORADCAST && _partial_bloom_filter_build_params.size() == 1;

    const auto& num_bloom_filters = _bloom_filter_descriptors.size();
    // all params must have the same size as num_bloom_filters
    DCHECK(std::ranges::all_of(_partial_bloom_filter_build_params, [&num_bloom_filters](auto& opt_params) {
        return opt_params.size() == num_bloom_filters;
    }));

    for (size_t i = 0; i < num_bloom_filters; ++i) {
        auto& desc = _bloom_filter_descriptors[i];
        desc->set_is_pipeline(true);

        // skip if it does not have consumer.
        if (!desc->has_consumer()) continue;
        // skip if ht.size() > limit, and it's only for local.
        if (!desc->has_remote_targets() && row_count > _local_rf_limit) continue;

        const LogicalType build_type = desc->build_expr_type();
        RuntimeFilter* rf = nullptr;
        if (maybe_use_bitset_filter && _partial_bloom_filter_build_params[0][i].has_value()) {
            const auto& param = _partial_bloom_filter_build_params[0][i].value();
            rf = RuntimeFilterHelper::create_join_runtime_filter(_pool, build_type, desc->join_mode(), param,
                                                                 kHashJoinKeyColumnOffset, row_count);
        } else {
            rf = RuntimeFilterHelper::create_runtime_bloom_filter(_pool, build_type, desc->join_mode());
        }
        if (rf == nullptr) continue;

        // set BF paramaters
        if (desc->has_remote_targets() && row_count > _global_rf_limit) {
            if (!is_version_v3) {
                rf->get_membership_filter()->clear_bf();
            } else {
                rf = RuntimeFilterHelper::transmit_to_runtime_empty_filter(_pool, rf);
                rf->get_membership_filter()->init(row_count);
            }
        } else {
            rf->get_membership_filter()->init(row_count);
        }

        desc->set_runtime_filter(rf);
    }

    for (auto i = 0; i < num_bloom_filters; ++i) {
        auto& desc = _bloom_filter_descriptors[i];
        if (desc->runtime_filter() == nullptr) {
            continue;
        }

        const auto can_merge = std::ranges::all_of(_partial_bloom_filter_build_params,
                                                   [i](auto& opt_params) { return opt_params[i].has_value(); });
        if (!can_merge) {
            desc->set_runtime_filter(nullptr);
            continue;
        }

        for (auto& opt_params : _partial_bloom_filter_build_params) {
            auto& opt_param = opt_params[i];
            DCHECK(opt_param.has_value());
            auto& param = opt_param.value();
            auto status = RuntimeFilterHelper::fill_runtime_filter(param, desc->build_expr_type(),
                                                                   desc->runtime_filter(), kHashJoinKeyColumnOffset);
            if (!status.ok()) {
                desc->set_runtime_filter(nullptr);
                break;
            }
        }
    }
    return Status::OK();
}

Status PartialRuntimeFilterMerger::merge_multi_partitioned_local_bloom_filters() {
    if (_partial_bloom_filter_build_params.empty()) {
        return Status::OK();
    }

    size_t row_count = 0;
    for (auto count : _ht_row_counts) {
        row_count += count;
    }

    const bool is_version_v3 = _func_version >= RF_VERSION_V3;

    for (auto& desc : _bloom_filter_descriptors) {
        desc->set_is_pipeline(true);
        // skip if it does not have consumer.
        if (!desc->has_consumer()) continue;
        // skip if ht.size() > limit, and it's only for local.
        if (!desc->has_remote_targets() && row_count > _local_rf_limit) continue;
        LogicalType build_type = desc->build_expr_type();
        auto rf = RuntimeFilterHelper::create_runtime_bloom_filter(_pool, build_type, desc->join_mode());
        if (rf == nullptr) continue;
        // set BF paramaters
        if (desc->has_remote_targets() && row_count > _global_rf_limit) {
            if (!is_version_v3) {
                rf->get_membership_filter()->clear_bf();
            } else {
                rf = RuntimeFilterHelper::transmit_to_runtime_empty_filter(_pool, rf);
                rf->get_membership_filter()->init(row_count);
            }
        } else {
            rf->get_membership_filter()->init(row_count);
        }

        desc->set_runtime_filter(rf);
    }

    const auto& num_bloom_filters = _bloom_filter_descriptors.size();

    // remove empty params that generated in two cases:
    // 1. the corresponding HashJoinProbeOperator is finished in short-circuit style because HashJoinBuildOperator
    // above this operator has constructed an empty hash table.
    // 2. the HashJoinBuildOperator is finished in advance because the fragment instance is canceled
    _partial_bloom_filter_build_params.erase(
            std::remove_if(_partial_bloom_filter_build_params.begin(), _partial_bloom_filter_build_params.end(),
                           [](auto& opt_params) { return opt_params.empty(); }),
            _partial_bloom_filter_build_params.end());

    // there is no non-empty params, set all runtime filter to nullptr
    if (_partial_bloom_filter_build_params.empty()) {
        for (auto& desc : _bloom_filter_descriptors) {
            desc->set_runtime_filter(nullptr);
        }
        return Status::OK();
    }

    // all params must have the same size as num_bloom_filters
    DCHECK(std::all_of(_partial_bloom_filter_build_params.begin(), _partial_bloom_filter_build_params.end(),
                       [&num_bloom_filters](auto& opt_params) { return opt_params.size() == num_bloom_filters; }));

    for (auto i = 0; i < num_bloom_filters; ++i) {
        auto& desc = _bloom_filter_descriptors[i];
        if (desc->runtime_filter() == nullptr) {
            continue;
        }
        auto can_merge =
                std::all_of(_partial_bloom_filter_build_params.begin(), _partial_bloom_filter_build_params.end(),
                            [i](auto& opt_params) { return opt_params[i].has_value(); });
        if (!can_merge) {
            desc->set_runtime_filter(nullptr);
            continue;
        }
        auto* rf = desc->runtime_filter();
        for (auto& opt_params : _partial_bloom_filter_build_params) {
            auto& opt_param = opt_params[i];
            DCHECK(opt_param.has_value());
            auto& param = opt_param.value();
            if (param.is_empty) {
                continue;
            }
            rf->concat(param.runtime_filter.get());
        }
    }
    return Status::OK();
}

StatusOr<bool> PartialRuntimeFilterMerger::_try_do_merge(RuntimeMembershipFilters&& bloom_filter_descriptors) {
    if (1 == _num_active_builders--) {
        if (_always_true) {
            _partial_in_filters.clear();
            _bloom_filter_descriptors.clear();
            return true;
        }
        _bloom_filter_descriptors = std::move(bloom_filter_descriptors);
        RETURN_IF_ERROR(merge_local_in_filters());
        RETURN_IF_ERROR(merge_local_bloom_filters());
        return true;
    }
    return false;
}

} // namespace starrocks::pipeline