// Copyright 2021-present StarRocks, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "exprs/utility_functions.h"

#include "column/column_visitor_adapter.h"
#include "gen_cpp/FrontendService_types.h"
#include "runtime/client_cache.h"

#ifdef __SSE4_2__
#include <emmintrin.h>
#endif
#include <unistd.h>

#include <algorithm>
#include <atomic>
#include <cstdint>
#include <cstdlib>
#include <limits>
#include <random>

#include "column/binary_column.h"
#include "column/column_builder.h"
#include "column/column_helper.h"
#include "column/column_viewer.h"
#include "column/vectorized_fwd.h"
#include "common/config.h"
#include "common/version.h"
#include "exec/pipeline/fragment_context.h"
#include "exprs/function_context.h"
#include "gutil/casts.h"
#include "runtime/runtime_state.h"
#include "service/backend_options.h"
#include "storage/key_coder.h"
#include "storage/primary_key_encoder.h"
#include "types/logical_type.h"
#include "util/cidr.h"
#include "util/monotime.h"
#include "util/network_util.h"
#include "util/thrift_rpc_helper.h"
#include "util/time.h"

namespace starrocks {

StatusOr<ColumnPtr> UtilityFunctions::version(FunctionContext* context, const Columns& columns) {
    return ColumnHelper::create_const_column<TYPE_VARCHAR>("5.1.0", 1);
}

StatusOr<ColumnPtr> UtilityFunctions::current_version(FunctionContext* context, const Columns& columns) {
    static std::string version = std::string(STARROCKS_VERSION) + "-" + STARROCKS_COMMIT_HASH;
    return ColumnHelper::create_const_column<TYPE_VARCHAR>(version, 1);
}

StatusOr<ColumnPtr> UtilityFunctions::sleep(FunctionContext* context, const Columns& columns) {
    ColumnViewer<TYPE_INT> data_column(columns[0]);

    auto size = columns[0]->size();
    ColumnBuilder<TYPE_BOOLEAN> result(size);
    auto& cancelled = context->state()->cancelled_ref();
    for (int row = 0; row < size; ++row) {
        if (data_column.is_null(row)) {
            result.append_null();
            continue;
        }

        int32_t seconds = data_column.value(row);
        // TODO: don't use system sleep, which will block current thread
        while (seconds-- > 0) {
            RETURN_IF(cancelled.load(), Status::Cancelled("cancelled during sleep function"));
            SleepFor(MonoDelta::FromSeconds(1));
        }
        result.append(true);
    }

    return result.build(ColumnHelper::is_all_const(columns));
}

StatusOr<ColumnPtr> UtilityFunctions::last_query_id(FunctionContext* context, const Columns& columns) {
    starrocks::RuntimeState* state = context->state();
    const std::string& id = state->last_query_id();
    if (!id.empty()) {
        return ColumnHelper::create_const_column<TYPE_VARCHAR>(id, 1);
    } else {
        return ColumnHelper::create_const_null_column(1);
    }
}

// UUID fixed 33 bytes.
// 16bytes-16bytes
// UUIDs generated by 128 bit uuid_numeric()
// The first 48 bits are a timestamp, representing milliseconds since the chosen epoch.
// The next 16 bits represent a machine ID. (IP ^ PORT, later we will use a backend ID)
// The next 16 bits are random value.
// The next 16 bits are thread id.
// The next 32 bits are increasement value.
StatusOr<ColumnPtr> UtilityFunctions::uuid(FunctionContext* ctx, const Columns& columns) {
    int32_t num_rows = ColumnHelper::get_const_value<TYPE_INT>(columns.back());

    ASSIGN_OR_RETURN(auto col, UtilityFunctions::uuid_numeric(ctx, columns));
    const auto uuid_data = down_cast<const Int128Column*>(col.get())->immutable_data();

    auto res = BinaryColumn::create();
    auto& bytes = res->get_bytes();
    auto& offsets = res->get_offset();

    offsets.resize(num_rows + 1);
    bytes.resize(36 * num_rows);

    char* ptr = reinterpret_cast<char*>(bytes.data());

    for (int i = 0; i < num_rows; ++i) {
        offsets[i + 1] = offsets[i] + 36;
    }

#ifdef __SSE4_2__
    alignas(16) static constexpr const char hex_chars[16] = {'0', '1', '2', '3', '4', '5', '6', '7',
                                                             '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    const __m128i mask = _mm_set1_epi8(0xF);
    const __m128i chars = _mm_load_si128(reinterpret_cast<const __m128i*>(hex_chars));
#endif

    for (int i = 0; i < num_rows; ++i) {
        char buff[32];
        memset(ptr, '-', 36);
#ifdef __SSE4_2__
        // SIMD::to_hex
        __m128i value = _mm_loadu_si64(reinterpret_cast<const __m128i*>(&uuid_data[i]));
        // 0x1234
        //-> [0x34, 0x12]
        //-> [0x23, 0x01] right shift
        //-> [0x34, 0x23, 0x12, 0x01] pack
        //-> [0x04, 0x03, 0x02, 0x01] mask operator
        //-> shuffle
        value = _mm_and_si128(_mm_unpacklo_epi8(_mm_srli_epi64(value, 4), value), mask);
        value = _mm_shuffle_epi8(chars, value);
        _mm_storeu_si128(reinterpret_cast<__m128i*>(buff), value);

        value = _mm_loadu_si64(reinterpret_cast<const __m128i*>(reinterpret_cast<const int64_t*>(&uuid_data[i]) + 1));
        value = _mm_and_si128(_mm_unpacklo_epi8(_mm_srli_epi64(value, 4), value), mask);
        value = _mm_shuffle_epi8(chars, value);
        _mm_storeu_si128(reinterpret_cast<__m128i*>(buff + 16), value);
#else
        to_hex(uuid_data[i], buff);
        std::reverse(buff, buff + 32);
#endif

        // UUID format 8-4-4-4-12

        memcpy(ptr, buff, 8);
        memcpy(ptr + 8 + 1, buff + 8, 4);
        memcpy(ptr + 8 + 4 + 2, buff + 8 + 4, 4);
        memcpy(ptr + 8 + 4 + 4 + 3, buff + 8 + 4 + 4, 4);
        memcpy(ptr + 8 + 4 + 4 + 4 + 4, buff + 8 + 4 + 4 + 4, 12);

        ptr += 36;
    }

    return res;
}

inline int128_t next_uuid(int64_t timestamp, int16_t backendId, int16_t rand, int16_t tid, int32_t inc) {
    union {
        struct {
            int64_t timestamp : 48;
            int64_t instance : 16;
            int16_t rand;
            int16_t tid;
            int32_t inc;
        } data;
        int128_t res;
    } v;
    v.data.timestamp = timestamp;
    v.data.instance = backendId;
    v.data.rand = rand;
    v.data.tid = tid;
    v.data.inc = inc;
    return v.res;
}

static std::atomic<int32_t> s_counter{};
// thread ids
// The number of executor threads is fixed.
static std::atomic<int16_t> inc{};
//
static thread_local int uniq_tid = -1;

int16_t get_uniq_tid() {
    if (uniq_tid == -1) {
        uniq_tid = inc.fetch_add(1);
    }
    return uniq_tid;
}

StatusOr<ColumnPtr> UtilityFunctions::uuid_numeric(FunctionContext*, const Columns& columns) {
    int32_t num_rows = ColumnHelper::get_const_value<TYPE_INT>(columns.back());
    auto result = Int128Column::create(num_rows);

    static std::random_device rd;
    static std::mt19937 mt(rd());

    std::uniform_int_distribution<int16_t> dist(std::numeric_limits<int16_t>::min(),
                                                std::numeric_limits<int16_t>::max());

    auto& data = result->get_data();

    uint32_t intip;
    CIDR::ip_to_int(BackendOptions::get_localhost(), &intip);
    intip ^= config::brpc_port;
    // current thread id
    int tid = get_uniq_tid();
    int64_t timestamp = GetCurrentTimeMicros();

    int16_t rand = dist(mt);
    int32_t inc = s_counter.fetch_add(num_rows);

    for (int i = 0; i < num_rows; ++i) {
        data[i] = next_uuid(timestamp, intip, rand, tid, inc - i);
    }

    return result;
}

StatusOr<ColumnPtr> UtilityFunctions::assert_true(FunctionContext* context, const Columns& columns) {
    auto column = columns[0];
    std::string msg = "assert_true failed due to false value";
    if (columns.size() > 1 && columns[1]->is_constant()) {
        msg = ColumnHelper::get_const_value<TYPE_VARCHAR>(columns[1]).to_string();
    }

    const auto size = column->size();

    if (column->has_null()) {
        throw std::runtime_error("assert_true failed due to null value");
    }

    if (column->is_constant()) {
        bool const_value = ColumnHelper::get_const_value<TYPE_BOOLEAN>(column);
        if (!const_value) {
            throw std::runtime_error(msg);
        }
    } else {
        if (column->is_nullable()) {
            column = FunctionHelper::get_data_column_of_nullable(column);
        }
        auto bool_column = ColumnHelper::cast_to<TYPE_BOOLEAN>(column);
        const auto data = bool_column->immutable_data();
        for (size_t i = 0; i < size; ++i) {
            if (!data[i]) {
                throw std::runtime_error(msg);
            }
        }
    }
    return ColumnHelper::create_const_column<TYPE_BOOLEAN>(true, size);
}

StatusOr<ColumnPtr> UtilityFunctions::host_name(FunctionContext* context, const Columns& columns) {
    std::string host_name;
    auto status = get_hostname(&host_name);
    if (status.ok()) {
        return ColumnHelper::create_const_column<TYPE_VARCHAR>(host_name, 1);
    } else {
        host_name = "error";
        return ColumnHelper::create_const_column<TYPE_VARCHAR>(host_name, 1);
    }
}

StatusOr<ColumnPtr> UtilityFunctions::get_query_profile(FunctionContext* context, const Columns& columns) {
    RETURN_IF_COLUMNS_ONLY_NULL(columns);
    ColumnViewer<TYPE_VARCHAR> viewer(columns[0]);
    auto* state = context->state();
    if (state->fragment_ctx() == nullptr) {
        return Status::NotSupported("unsupport get_query_profile for no-pipeline");
    }

    const auto& fe_addr = state->fragment_ctx()->fe_addr();
    TGetProfileResponse res;
    TGetProfileRequest req;

    std::vector<std::string> query_ids;
    for (size_t i = 0; i < columns[0]->size(); ++i) {
        query_ids.emplace_back(viewer.value(i));
    }
    req.__set_query_id(query_ids);

    RETURN_IF_ERROR(ThriftRpcHelper::rpc<FrontendServiceClient>(
            fe_addr.hostname, fe_addr.port,
            [&](FrontendServiceConnection& client) { client->getQueryProfile(res, req); }));

    ColumnBuilder<TYPE_VARCHAR> builder(state->chunk_size());
    for (const auto& result : res.query_result) {
        builder.append(result);
    }

    return builder.build(false);
}

StatusOr<ColumnPtr> UtilityFunctions::bar(FunctionContext* context, const Columns& columns) {
    static std::u8string kBar = u8"\u2593";
    RETURN_IF(columns.size() != 4, Status::InvalidArgument("expect 4 arguments"));
    RETURN_IF(!columns[1]->is_constant(), Status::InvalidArgument("argument[min] must be constant"));
    RETURN_IF(!columns[2]->is_constant(), Status::InvalidArgument("argument[max] must be constant"));
    RETURN_IF(!columns[3]->is_constant(), Status::InvalidArgument("argument[width] must be constant"));

    ColumnViewer<TYPE_BIGINT> viewer_size(columns[0]);
    ColumnViewer<TYPE_BIGINT> viewer_min(columns[1]);
    ColumnViewer<TYPE_BIGINT> viewer_max(columns[2]);
    ColumnViewer<TYPE_BIGINT> viewer_width(columns[3]);
    size_t rows = columns[0]->size();
    ColumnBuilder<TYPE_VARCHAR> builder(rows);

    size_t min = viewer_min.value(0);
    size_t max = viewer_max.value(0);
    size_t width = viewer_width.value(0);
    RETURN_IF(min >= max, Status::InvalidArgument("requirement: min < max"));
    RETURN_IF(width <= 0, Status::InvalidArgument("requirement: width > 0"));

    for (size_t i = 0; i < rows; i++) {
        size_t size = viewer_size.value(i);
        RETURN_IF(size < min, Status::InvalidArgument("requirement: size >= min"));
        RETURN_IF(size > max, Status::InvalidArgument("requirement: size <= max"));

        double ratio = std::min<double>(1.0, 1.0 * (size - min) / (max - min));
        size_t result_width = ratio * width;
        std::string bar;
        for (size_t j = 0; j < result_width; j++) {
            bar.append(reinterpret_cast<const char*>(kBar.c_str()));
        }
        builder.append(bar);
    }
    return builder.build(false);
}

StatusOr<ColumnPtr> UtilityFunctions::equiwidth_bucket(FunctionContext* context, const Columns& columns) {
    RETURN_IF(columns.size() != 4, Status::InvalidArgument("expect 4 arguments"));
    RETURN_IF(!columns[1]->is_constant(), Status::InvalidArgument("argument[min] must be constant"));
    RETURN_IF(!columns[2]->is_constant(), Status::InvalidArgument("argument[max] must be constant"));
    RETURN_IF(!columns[3]->is_constant(), Status::InvalidArgument("argument[bucket] must be constant"));

    ColumnViewer<TYPE_BIGINT> viewer_size(columns[0]);
    ColumnViewer<TYPE_BIGINT> viewer_min(columns[1]);
    ColumnViewer<TYPE_BIGINT> viewer_max(columns[2]);
    ColumnViewer<TYPE_BIGINT> viewer_buckets(columns[3]);
    size_t rows = columns[0]->size();
    ColumnBuilder<TYPE_BIGINT> builder(rows);

    size_t min = viewer_min.value(0);
    size_t max = viewer_max.value(0);
    size_t buckets = viewer_buckets.value(0);
    RETURN_IF(min >= max, Status::InvalidArgument("requirement: min < max"));
    RETURN_IF(buckets <= 0, Status::InvalidArgument("requirement: buckets > 0"));

    for (size_t i = 0; i < rows; i++) {
        size_t size = viewer_size.value(i);
        RETURN_IF(size < min, Status::InvalidArgument("requirement: size >= min"));
        RETURN_IF(size > max, Status::InvalidArgument("requirement: size <= max"));

        size_t bucket = (size - min) / std::max<size_t>(1, ((max - min) / buckets));
        builder.append(bucket);
    }
    return builder.build(false);
}

// Helpers copied and adapted from storage/primary_key_encoder.cpp for order-preserving encoding
namespace detail {

inline void encode_float32(float v, std::string* dest) {
    uint32_t u;
    static_assert(sizeof(u) == sizeof(v), "size mismatch");
    memcpy(&u, &v, sizeof(u));
    // If negative, flip all bits; else flip sign bit only.
    u ^= (u & 0x80000000u) ? 0xFFFFFFFFu : 0x80000000u;
    u = starrocks::encoding_utils::to_bigendian(u);
    dest->append(reinterpret_cast<const char*>(&u), sizeof(u));
}

inline void encode_float64(double v, std::string* dest) {
    uint64_t u;
    static_assert(sizeof(u) == sizeof(v), "size mismatch");
    memcpy(&u, &v, sizeof(u));
    u ^= (u & 0x8000000000000000ull) ? 0xFFFFFFFFFFFFFFFFull : 0x8000000000000000ull;
    u = starrocks::encoding_utils::to_bigendian(u);
    dest->append(reinterpret_cast<char*>(&u), sizeof(u));
}

struct EncoderVisitor : public ColumnVisitorAdapter<EncoderVisitor> {
    bool is_last_field = false;
    std::vector<std::string>* buffs;
    const ImmBuffer<uint8_t>* null_mask = nullptr; // Track null rows to skip processing

    explicit EncoderVisitor() : ColumnVisitorAdapter(this) {}

    // Nullable wrapper: handle null values and data together
    Status do_visit(const NullableColumn& column) {
        const auto nulls = column.immutable_null_column_data();

        for (size_t i = 0; i < column.size(); i++) {
            if (nulls[i]) {
                (*buffs)[i].append("\0", 1);
            } else {
                (*buffs)[i].append("\1", 1);
            }
        }

        // Set the null mask so that subsequent visitor methods can skip null rows
        const ImmBuffer<uint8_t>* original_null_mask = null_mask;
        null_mask = &nulls;

        // Process the underlying data column
        Status status = column.data_column()->accept(this);

        // Restore the original null mask
        null_mask = original_null_mask;

        return status;
    }

    // Const: forward to data
    Status do_visit(const ConstColumn& column) {
        for (size_t i = 0; i < column.size(); i++) {
            RETURN_IF_ERROR(column.data_column()->accept(this));
        }
        return Status::OK();
    }

    // Strings/binary
    template <typename T>
    Status do_visit(const BinaryColumnBase<T>& column) {
        for (size_t i = 0; i < column.size(); i++) {
            // Skip processing for null rows
            if (null_mask && (*null_mask)[i]) {
                continue;
            }
            Slice s = column.get_slice(i);
            encoding_utils::encode_slice(s, &(*buffs)[i], is_last_field);
        }
        return Status::OK();
    }

    // Fixed-length numerics
    template <typename T>
    Status do_visit(const FixedLengthColumn<T>& column) {
        const auto data = column.immutable_data();
        for (size_t i = 0; i < column.size(); i++) {
            // Skip processing for null rows
            if (null_mask && (*null_mask)[i]) {
                continue;
            }
            if constexpr (std::is_same_v<T, float>) {
                encode_float32(data[i], &(*buffs)[i]);
            } else if constexpr (std::is_same_v<T, double>) {
                encode_float64(data[i], &(*buffs)[i]);
            } else if constexpr (std::is_integral_v<T> && sizeof(T) <= 8) {
                encoding_utils::encode_integral<T>(data[i], &(*buffs)[i]);
            } else if constexpr (std::is_same_v<T, DateValue>) {
                encoding_utils::encode_integral<int32_t>(data[i].julian(), &(*buffs)[i]);
            } else if constexpr (std::is_same_v<T, DateTimeValue>) {
                encoding_utils::encode_integral<int64_t>(data[i].to_int64(), &(*buffs)[i]);
            } else if constexpr (std::is_same_v<T, TimestampValue>) {
                encoding_utils::encode_integral<int64_t>(data[i].timestamp(), &(*buffs)[i]);
            } else {
                return Status::NotSupported(
                        fmt::format("encode_sort_key: unsupported argument type: {}", typeid(T).name()));
            }
        }
        return Status::OK();
    }

    // Unsupported complex types map/array/struct/json/hll/bitmap/percentile
    template <typename T>
    Status do_visit(const T& column) {
        // Even for unsupported types, we should check null mask to be consistent
        // but since we're returning an error anyway, we can skip the null check
        return Status::NotSupported("encode_sort_key: unsupported argument type");
    }
};
} // namespace detail

// The encoding strategy of encode_sort_key is as follows:
//
// - For each input column, each row's value is encoded into a binary buffer
//   using an order-preserving encoding. The encoding method depends on the
//   column's type:
//     * For integral types, values are converted to big-endian and, for signed
//       types, the sign bit is flipped to preserve order.
//     * For floating-point types, a custom encoding is used to ensure correct
//       sort order.
//     * For string types (Slice), a special encoding is used for non-last fields
//       to escape 0x00 bytes and append a 0x00 0x00 terminator, while the last
//       field is appended directly.
//     * For date/time types, the internal integer representation is encoded as
//       an integral value.
//     * Unsupported types return an error.
//
// - For each column, a NULL marker (byte value 0x00 or 0x01) is appended for every
//   row, regardless of the column's nullability, to ensure consistent encoding
//   even if the column's nullability metadata is lost during processing.
//
// - After encoding each column, a separator byte (0x00) is appended between
//   columns (except after the last column) to delimit fields in the composite
//   key.
//
// - The result is a composite binary key for each row, which preserves the
//   original sort order of the input columns when compared lexicographically.
StatusOr<ColumnPtr> UtilityFunctions::encode_sort_key(FunctionContext* context, const Columns& columns) {
    const char* NOT_NULL_MARKER = "\1";
    const char* COLUMN_SEPARATOR = "\0";
    int num_args = columns.size();
    RETURN_IF(num_args < 1, Status::InvalidArgument("encode_sort_key requires at least 1 argument"));

    size_t num_rows = columns[0]->size();
    auto result = ColumnBuilder<TYPE_VARBINARY>(num_rows);

    std::vector<std::string> buffs(num_rows);
    detail::EncoderVisitor visitor;
    visitor.buffs = &buffs;
    for (int j = 0; j < num_args; ++j) {
        // Insert NOT_NULL markers for all rows.
        // This is necessary because the function may receive columns whose nullability
        // does not accurately reflect the original data source.
        // For example, a nullable column that contains no null values may be converted
        // to a non-nullable column during processing. To ensure consistency in the sort key
        // encoding, we explicitly add NOT_NULL markers for every row.
        if (!columns[j]->is_nullable()) {
            for (auto& buff : buffs) {
                buff.append(NOT_NULL_MARKER, 1);
            }
        }
        visitor.is_last_field = (j + 1 == num_args);
        RETURN_IF_ERROR(columns[j]->accept(&visitor));

        // Add a separator between each column
        if (j < num_args - 1) {
            for (auto& buff : buffs) {
                buff.append(COLUMN_SEPARATOR, 1);
            }
        }
    }

    for (size_t i = 0; i < num_rows; i++) {
        result.append(std::move(buffs[i]));
    }
    return result.build(ColumnHelper::is_all_const(columns));
}

} // namespace starrocks

#include "gen_cpp/opcode/UtilityFunctions.inc"
