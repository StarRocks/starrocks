// Copyright 2021-present StarRocks, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <algorithm>
#include <queue>
#include <vector>

#include "column/array_column.h"
#include "column/column_helper.h"
#include "column/type_traits.h"
#include "column/nullable_column.h"
#include "exprs/agg/aggregate.h"
#include "exprs/agg/aggregate_traits.h"
#include "runtime/mem_pool.h"
#include "types/logical_type.h"
#include "util/raw_container.h"

namespace starrocks {

// IsMin: true for min_n, false for max_n
template <LogicalType LT, bool IsMin>
struct MinMaxNAggregateState {
    using CppType = RunTimeCppType<LT>;
    using ColumnType = RunTimeColumnType<LT>;

    // For min_n: use max-heap to maintain n smallest values
    // For max_n: use min-heap to maintain n largest values
    struct Comparator {
        bool operator()(const CppType& a, const CppType& b) const {
            if constexpr (IsSlice<CppType>) {
                // For min_n (max-heap): a < b means a has lower priority (keep larger values on top)
                // For max_n (min-heap): a > b means a has lower priority (keep smaller values on top)
                return IsMin ? (a.compare(b) < 0) : (a.compare(b) > 0);
            } else {
                return IsMin ? (a < b) : (a > b);
            }
        }
    };

    int32_t n = 0;
    bool is_init = false;
    std::priority_queue<CppType, std::vector<CppType>, Comparator> heap;

    void reset(int32_t n_value) {
        this->n = n_value;
        // Clear the heap
        while (!heap.empty()) {
            heap.pop();
        }
    }

    template <bool IsDeepCopy>
    void process(MemPool* mem_pool, const CppType& value) {
        if (heap.size() < static_cast<size_t>(n)) {
            // Heap not full, add directly
            auto copied_value = _copy<IsDeepCopy>(mem_pool, value);
            heap.push(copied_value);
        } else if (_should_replace(value, heap.top())) {
            // Heap full, replace if new value is better
            heap.pop();
            auto copied_value = _copy<IsDeepCopy>(mem_pool, value);
            heap.push(copied_value);
        }
    }

    void merge(MemPool* mem_pool, const std::vector<CppType>& other_values) {
        for (const auto& value : other_values) {
            process<true>(mem_pool, value);
        }
    }

    // Generate sorted result values from heap (thread-safe, no mutable cache)
    void get_sorted_values(std::vector<CppType>& values) const {
        values.clear();
        values.reserve(heap.size());
        
        // Extract all values from heap
        auto temp_heap = heap;
        while (!temp_heap.empty()) {
            values.push_back(temp_heap.top());
            temp_heap.pop();
        }
        
        // Sort: both min_n and max_n in ascending order
        std::sort(values.begin(), values.end(), [](const CppType& a, const CppType& b) {
            if constexpr (IsSlice<CppType>) {
                return a.compare(b) < 0;
            } else {
                return a < b;
            }
        });
    }

    bool check_overflow(FunctionContext* ctx) const {
        return false; // Size is limited by n parameter
    }

    static bool check_overflow(const Column& col, FunctionContext* ctx, const char* func_name) {
        Status st = col.capacity_limit_reached();
        if (!st.ok()) {
            std::string error_msg = fmt::format("The column generated by {} is overflow: {}", func_name, st.message());
            ctx->set_error(error_msg.c_str());
            return true;
        }
        return false;
    }

private:
    template <bool IsDeepCopy>
    CppType _copy(MemPool* mem_pool, const CppType& value) {
        // Always deep copy Slice types to avoid dangling pointers,
        // regardless of IsDeepCopy flag
        if constexpr (IsSlice<CppType>) {
            uint8_t* pos = mem_pool->allocate(value.size);
            std::memcpy(pos, value.data, value.size);
            return Slice{pos, value.size};
        } else {
            return value;
        }
    }

    bool _should_replace(const CppType& new_value, const CppType& heap_top) const {
        if constexpr (IsSlice<CppType>) {
            // For min_n: replace if new_value < heap_top (heap_top is the largest among n smallest)
            // For max_n: replace if new_value > heap_top (heap_top is the smallest among n largest)
            return IsMin ? (new_value.compare(heap_top) < 0) : (new_value.compare(heap_top) > 0);
        } else {
            return IsMin ? (new_value < heap_top) : (new_value > heap_top);
        }
    }
};

// Convenience aliases
template <LogicalType LT>
using MinNAggregateState = MinMaxNAggregateState<LT, true>;

template <LogicalType LT>
using MaxNAggregateState = MinMaxNAggregateState<LT, false>;

template <LogicalType LT, bool IsMin>
class MinMaxNAggregateFunction final
        : public AggregateFunctionBatchHelper<MinMaxNAggregateState<LT, IsMin>, MinMaxNAggregateFunction<LT, IsMin>> {
public:
    using CppType = RunTimeCppType<LT>;
    using InputColumnType = RunTimeColumnType<LT>;

    static constexpr int32_t DEFAULT_N = 5;
    static constexpr int32_t MAX_N = 10000;
    static constexpr const char* FUNC_NAME = IsMin ? "min_n" : "max_n";

    int32_t get_n_value(FunctionContext* ctx) const {
        int32_t n = DEFAULT_N;
        if (ctx->get_num_args() > 1) {
            const Column* const_col = ctx->get_constant_column(1);
            if (const_col != nullptr) {
            // Get the actual data column from ConstColumn
            const auto* const_column = ColumnHelper::as_raw_column<ConstColumn>(const_col);
            const Column* data_column = const_column->data_column().get();
            
            // Read the value directly from raw data based on type size
            const uint8_t* raw_data = data_column->raw_data();
            size_t type_size = data_column->type_size();
                
                switch (type_size) {
                    case 1: {
                        n = static_cast<int32_t>(*reinterpret_cast<const int8_t*>(raw_data));
                        break;
                    }
                    case 2: {
                        n = static_cast<int32_t>(*reinterpret_cast<const int16_t*>(raw_data));
                        break;
                    }
                    case 4: {
                        n = *reinterpret_cast<const int32_t*>(raw_data);
                        break;
                    }
                    case 8: {
                        n = static_cast<int32_t>(*reinterpret_cast<const int64_t*>(raw_data));
                        break;
                    }
                    default: {
                        n = ColumnHelper::get_const_value<TYPE_INT>(const_col);
                        break;
                    }
                }
            }
        }
        DCHECK_GT(n, 0);
        DCHECK_LE(n, MAX_N);
        return n;
    }

    void init_state_if_necessary(FunctionContext* ctx, AggDataPtr __restrict state) const {
        if (this->data(state).is_init) {
            return;
        }
        this->data(state).is_init = true;
        int32_t n = get_n_value(ctx);
        this->data(state).reset(n);
    }

    void reset(FunctionContext* ctx, const Columns& args, AggDataPtr state) const override {
        int32_t n = get_n_value(ctx);
        this->data(state).reset(n);
    }

    void update(FunctionContext* ctx, const Column** columns, AggDataPtr __restrict state,
                size_t row_num) const override {
        if (columns[0]->is_null(row_num)) {
            return;
        }

        init_state_if_necessary(ctx, state);

        const Column* data_col = ColumnHelper::get_data_column(columns[0]);
        const auto* column = down_cast<const InputColumnType*>(data_col);
        const auto& value = AggDataTypeTraits<LT>::get_row_ref(*column, row_num);
        
        this->data(state).template process<true>(ctx->mem_pool(), value);
    }

    void update_batch_single_state_with_frame(FunctionContext* ctx, AggDataPtr __restrict state, 
                                              const Column** columns, int64_t peer_group_start, 
                                              int64_t peer_group_end, int64_t frame_start, 
                                              int64_t frame_end) const override {
        for (size_t i = frame_start; i < frame_end; ++i) {
            update(ctx, columns, state, i);
        }
    }

    void merge(FunctionContext* ctx, const Column* column, AggDataPtr __restrict state, 
               size_t row_num) const override {
        DCHECK(column->is_binary());
        Slice bytes = column->get(row_num).get_slice();
        
        size_t start = 0;
        int32_t n_encoded;
        uint32_t count;
        
        // Read n value
        std::memcpy(&n_encoded, bytes.data + start, sizeof(int32_t));
        start += sizeof(int32_t);
        
        // Read element count
        std::memcpy(&count, bytes.data + start, sizeof(uint32_t));
        start += sizeof(uint32_t);

        init_state_if_necessary(ctx, state);
        
        std::vector<CppType> values;
        values.reserve(count);
        
        for (uint32_t i = 0; i < count; ++i) {
            CppType value;
            if constexpr (IsSlice<CppType>) {
                int64_t len;
                std::memcpy(&len, bytes.data + start, sizeof(int64_t));
                start += sizeof(int64_t);
                
                uint8_t* slice_data = ctx->mem_pool()->allocate(len);
                if (len > 0) {
                    std::memcpy(slice_data, bytes.data + start, len);
                }
                start += len;
                value = Slice{slice_data, static_cast<size_t>(len)};
            } else {
                std::memcpy(&value, bytes.data + start, sizeof(CppType));
                start += sizeof(CppType);
            }
            values.push_back(value);
        }
        
        this->data(state).merge(ctx->mem_pool(), values);
    }

    void serialize_to_column(FunctionContext* ctx, ConstAggDataPtr __restrict state, Column* to) const override {
        // Like approx_top_k: serialize_to_column outputs to BinaryColumn (for distributed aggregation)
        DCHECK(to->is_binary());
        serialize_state(this->data(state), down_cast<BinaryColumn*>(to));
    }

    void convert_to_serialize_format(FunctionContext* ctx, const Columns& src, size_t chunk_size,
                                     ColumnPtr* dst) const override {
        int32_t n = get_n_value(ctx);
        DCHECK((*dst)->is_binary());
        auto* dst_column = down_cast<BinaryColumn*>((*dst).get());

        if (src[0]->is_nullable()) {
            auto* src_nullable_column = down_cast<const NullableColumn*>(src[0].get());
            auto* src_column = down_cast<const InputColumnType*>(src_nullable_column->data_column().get());

            for (size_t i = 0; i < src_nullable_column->size(); ++i) {
                MinMaxNAggregateState<LT, IsMin> state;
                state.reset(n);
                if (!src_nullable_column->is_null(i)) {
                    const auto& value = AggDataTypeTraits<LT>::get_row_ref(*src_column, i);
                    state.template process<false>(ctx->mem_pool(), value);
                }
                serialize_state(state, dst_column);
            }
        } else {
            auto* src_column = down_cast<const InputColumnType*>(src[0].get());

            for (size_t i = 0; i < src_column->size(); ++i) {
                MinMaxNAggregateState<LT, IsMin> state;
                state.reset(n);
                const auto& value = AggDataTypeTraits<LT>::get_row_ref(*src_column, i);
                state.template process<false>(ctx->mem_pool(), value);
                serialize_state(state, dst_column);
            }
        }
    }

    void serialize_state(const MinMaxNAggregateState<LT, IsMin>& state, BinaryColumn* dst) const {
        Bytes& bytes = dst->get_bytes();
        const size_t old_size = bytes.size();
        
        // Get sorted values (no mutable cache)
        std::vector<CppType> values;
        state.get_sorted_values(values);
        size_t count = values.size();
        
        // Calculate total size needed
        size_t total_size = sizeof(int32_t) + sizeof(uint32_t); // n + count
        for (const auto& value : values) {
            if constexpr (IsSlice<CppType>) {
                total_size += sizeof(int64_t) + value.size; // len + data
            } else {
                total_size += sizeof(CppType);
            }
        }
        
        bytes.resize(old_size + total_size);
        size_t start = old_size;
        
        // Write n value
        std::memcpy(bytes.data() + start, &state.n, sizeof(int32_t));
        start += sizeof(int32_t);
        
        // Write element count
        uint32_t count_u32 = static_cast<uint32_t>(count);
        std::memcpy(bytes.data() + start, &count_u32, sizeof(uint32_t));
        start += sizeof(uint32_t);
        
        // Write elements
        for (const auto& value : values) {
            if constexpr (IsSlice<CppType>) {
                int64_t len = static_cast<int64_t>(value.size);
                std::memcpy(bytes.data() + start, &len, sizeof(int64_t));
                start += sizeof(int64_t);
                if (len > 0) {
                    std::memcpy(bytes.data() + start, value.data, len);
                    start += len;
                }
            } else {
                std::memcpy(bytes.data() + start, &value, sizeof(CppType));
                start += sizeof(CppType);
            }
        }
        
        dst->get_offset().emplace_back(old_size + total_size);
    }

    void batch_serialize(FunctionContext* ctx, size_t chunk_size, const Buffer<AggDataPtr>& agg_states,
                        size_t state_offset, Column* to) const override {
        auto* column = down_cast<BinaryColumn*>(to);
        for (size_t i = 0; i < chunk_size; i++) {
            serialize_state(this->data(agg_states[i] + state_offset), column);
        }
    }

    void batch_finalize(FunctionContext* ctx, size_t chunk_size, const Buffer<AggDataPtr>& agg_states,
                       size_t state_offset, Column* to) const override {
        for (size_t i = 0; i < chunk_size; i++) {
            finalize_to_column(ctx, agg_states[i] + state_offset, to);
        }
    }

    void finalize_to_column(FunctionContext* ctx, ConstAggDataPtr __restrict state, Column* to) const override {
        // Like approx_top_k: finalize_to_column outputs to ArrayColumn (final result)
        DCHECK(to->is_array());
        auto& state_impl = this->data(const_cast<AggDataPtr>(state));
        
        if (UNLIKELY(state_impl.check_overflow(ctx))) {
            return;
        }
        
        auto* array_column = down_cast<ArrayColumn*>(to);
        
        // Get sorted values from heap
        std::vector<CppType> values;
        state_impl.get_sorted_values(values);
        
        // Handle empty result
        if (values.empty()) {
            array_column->append_default();
            return;
        }
        
        // Create a temporary column to hold the array elements
        auto temp_column = InputColumnType::create();
        for (const auto& value : values) {
            if constexpr (IsSlice<CppType>) {
                temp_column->append(value);
            } else {
                AggDataTypeTraits<LT>::append_value(temp_column.get(), value);
            }
        }
        
        // Use the safe append_array_element method
        array_column->append_array_element(*temp_column, 0);

        if (UNLIKELY(state_impl.check_overflow(*to, ctx, FUNC_NAME))) {
            return;
        }
    }

    void get_values(FunctionContext* ctx, ConstAggDataPtr __restrict state, Column* dst, 
                    size_t start, size_t end) const override {
        DCHECK_GT(end, start);
        auto& state_impl = this->data(const_cast<AggDataPtr>(state));
        
        // NullableAggregateFunctionBase will handle unwrapping if needed
        DCHECK(dst->is_array());
        auto* array_column = down_cast<ArrayColumn*>(dst);
        
        // Get sorted values (only once for all rows)
        std::vector<CppType> values;
        state_impl.get_sorted_values(values);
        
        for (size_t i = start; i < end; ++i) {
            if (UNLIKELY(state_impl.check_overflow(ctx))) {
                return;
            }

            // Handle empty result
            if (values.empty()) {
                array_column->append_default();
            } else {
                // Create a temporary column to hold the array elements
                auto temp_column = InputColumnType::create();
                for (const auto& value : values) {
                    if constexpr (IsSlice<CppType>) {
                        temp_column->append(value);
                    } else {
                        AggDataTypeTraits<LT>::append_value(temp_column.get(), value);
                    }
                }
                
                // Use the safe append_array_element method
                array_column->append_array_element(*temp_column, 0);
            }

            if (UNLIKELY(state_impl.check_overflow(*dst, ctx, FUNC_NAME))) {
                return;
            }
        }
    }

    std::string get_name() const override { 
        return FUNC_NAME; 
    }
};

// Convenience aliases for min_n and max_n
template <LogicalType LT>
using MinNAggregateFunction = MinMaxNAggregateFunction<LT, true>;

template <LogicalType LT>
using MaxNAggregateFunction = MinMaxNAggregateFunction<LT, false>;

} // namespace starrocks

