// Copyright 2021-present StarRocks, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <algorithm>
#include <queue>
#include <vector>

#include "column/array_column.h"
#include "column/column_helper.h"
#include "column/nullable_column.h"
#include "column/type_traits.h"
#include "exprs/agg/aggregate.h"
#include "exprs/agg/aggregate_traits.h"
#include "runtime/mem_pool.h"
#include "types/logical_type.h"
#include "util/raw_container.h"

namespace starrocks {

// IsMin: true for min_n, false for max_n
template <LogicalType LT, bool IsMin>
struct MinMaxNAggregateState {
    using CppType = RunTimeCppType<LT>;
    using ColumnType = RunTimeColumnType<LT>;

    // For min_n: use max-heap to maintain n smallest values
    // For max_n: use min-heap to maintain n largest values
    struct Comparator {
        bool operator()(const CppType& a, const CppType& b) const {
            if constexpr (IsSlice<CppType>) {
                // For min_n (max-heap): a < b means a has lower priority (keep larger values on top)
                // For max_n (min-heap): a > b means a has lower priority (keep smaller values on top)
                return IsMin ? (a.compare(b) < 0) : (a.compare(b) > 0);
            } else {
                return IsMin ? (a < b) : (a > b);
            }
        }
    };

    int32_t n = 0;
    bool is_init = false;
    std::priority_queue<CppType, std::vector<CppType>, Comparator> heap;

    void reset(int32_t n_value) {
        this->n = n_value;
        // Clear the heap
        while (!heap.empty()) {
            heap.pop();
        }
    }

    template <bool IsDeepCopy>
    void process(MemPool* mem_pool, const CppType& value) {
        if (heap.size() < static_cast<size_t>(n)) {
            // Heap not full, add directly
            auto copied_value = _copy<IsDeepCopy>(mem_pool, value);
            heap.push(copied_value);
        } else if (Comparator()(value, heap.top())) {
            // Heap full, replace if new value is better
            heap.pop();
            auto copied_value = _copy<IsDeepCopy>(mem_pool, value);
            heap.push(copied_value);
        }
    }

    void merge(MemPool* mem_pool, const std::vector<CppType>& other_values) {
        for (const auto& value : other_values) {
            process<true>(mem_pool, value);
        }
    }

    // Generate sorted result values from heap
    void get_sorted_values(std::vector<CppType>& values) const {
        values.clear();
        values.reserve(heap.size());

        // Extract all values from heap
        auto temp_heap = heap;
        while (!temp_heap.empty()) {
            values.push_back(temp_heap.top());
            temp_heap.pop();
        }

        // Sort: both min_n and max_n in ascending order
        std::sort(values.begin(), values.end(), [](const CppType& a, const CppType& b) {
            if constexpr (IsSlice<CppType>) {
                return a.compare(b) < 0;
            } else {
                return a < b;
            }
        });
    }

    bool check_overflow(FunctionContext* ctx) const {
        return false; // Size is limited by n parameter
    }

    static bool check_overflow(const Column& col, FunctionContext* ctx, const char* func_name) {
        Status st = col.capacity_limit_reached();
        if (!st.ok()) {
            std::string error_msg = fmt::format("The column generated by {} is overflow: {}", func_name, st.message());
            ctx->set_error(error_msg.c_str());
            return true;
        }
        return false;
    }

private:
    template <bool IsDeepCopy>
    CppType _copy(MemPool* mem_pool, const CppType& value) {
        // Always deep copy Slice types to avoid dangling pointers,
        // regardless of IsDeepCopy flag
        if constexpr (IsSlice<CppType>) {
            uint8_t* pos = mem_pool->allocate(value.size);
            std::memcpy(pos, value.data, value.size);
            return Slice{pos, value.size};
        } else {
            return value;
        }
    }
};

// Convenience aliases
template <LogicalType LT>
using MinNAggregateState = MinMaxNAggregateState<LT, true>;

template <LogicalType LT>
using MaxNAggregateState = MinMaxNAggregateState<LT, false>;

template <LogicalType LT, bool IsMin>
class MinMaxNAggregateFunction final
        : public AggregateFunctionBatchHelper<MinMaxNAggregateState<LT, IsMin>, MinMaxNAggregateFunction<LT, IsMin>> {
public:
    using CppType = RunTimeCppType<LT>;
    using InputColumnType = RunTimeColumnType<LT>;

    static constexpr int32_t DEFAULT_N = 5;
    static constexpr const char* FUNC_NAME = IsMin ? "min_n" : "max_n";

    int32_t get_n_value(FunctionContext* ctx) const {
        int32_t n = DEFAULT_N;
        if (ctx->get_num_args() > 1) {
            const Column* const_col = ctx->get_constant_column(1);
            n = ColumnHelper::get_const_value<TYPE_INT>(const_col);
        }
        DCHECK_GT(n, 0);
        return n;
    }

    void init_state_if_necessary(FunctionContext* ctx, AggDataPtr __restrict state) const {
        if (this->data(state).is_init) {
            return;
        }
        this->data(state).is_init = true;
        int32_t n = get_n_value(ctx);
        this->data(state).reset(n);
    }

    void update(FunctionContext* ctx, const Column** columns, AggDataPtr __restrict state,
                size_t row_num) const override {
        DCHECK(!columns[0]->is_nullable());
        init_state_if_necessary(ctx, state);

        const Column* data_col = ColumnHelper::get_data_column(columns[0]);
        const auto* column = down_cast<const InputColumnType*>(data_col);
        const auto& value = AggDataTypeTraits<LT>::get_row_ref(*column, row_num);

        this->data(state).template process<true>(ctx->mem_pool(), value);
    }

    void merge(FunctionContext* ctx, const Column* column, AggDataPtr __restrict state, size_t row_num) const override {
        DCHECK(!column->is_nullable());

        DCHECK(column->is_binary());
        Slice bytes = column->get(row_num).get_slice();

        size_t start = 0;
        int32_t n_encoded;
        uint32_t count;

        // Read n value
        std::memcpy(&n_encoded, bytes.data + start, sizeof(int32_t));
        start += sizeof(int32_t);

        // Read element count
        std::memcpy(&count, bytes.data + start, sizeof(uint32_t));
        start += sizeof(uint32_t);

        init_state_if_necessary(ctx, state);

        std::vector<CppType> values;
        values.reserve(count);

        if constexpr (IsSlice<CppType>) {
            // Variable-length type (Slice): deserialize one by one
            for (uint32_t i = 0; i < count; ++i) {
                int64_t len;
                std::memcpy(&len, bytes.data + start, sizeof(int64_t));
                start += sizeof(int64_t);

                uint8_t* slice_data = ctx->mem_pool()->allocate(len);
                if (len > 0) {
                    std::memcpy(slice_data, bytes.data + start, len);
                }
                start += len;
                values.emplace_back(slice_data, static_cast<size_t>(len));
            }
        } else {
            // Fixed-length type: bulk copy for better performance
            values.resize(count);
            std::memcpy(values.data(), bytes.data + start, count * sizeof(CppType));
            start += count * sizeof(CppType);
        }

        this->data(state).merge(ctx->mem_pool(), values);
    }

    void serialize_to_column(FunctionContext* ctx, ConstAggDataPtr __restrict state, Column* to) const override {
        // Like approx_top_k: serialize_to_column outputs to BinaryColumn (for distributed aggregation)
        DCHECK(to->is_binary());
        serialize_state(this->data(state), down_cast<BinaryColumn*>(to));
    }

    void convert_to_serialize_format(FunctionContext* ctx, const Columns& src, size_t chunk_size,
                                     MutableColumnPtr& dst) const override {
        DCHECK(!src[0]->is_nullable());
        int32_t n = get_n_value(ctx);
        DCHECK(dst->is_binary());
        auto* dst_column = down_cast<BinaryColumn*>(dst.get());
        auto* src_column = down_cast<const InputColumnType*>(src[0].get());

        for (size_t i = 0; i < src_column->size(); ++i) {
            MinMaxNAggregateState<LT, IsMin> state;
            state.reset(n);
            const auto& value = AggDataTypeTraits<LT>::get_row_ref(*src_column, i);
            state.template process<false>(ctx->mem_pool(), value);
            serialize_state(state, dst_column);
        }
    }

    void serialize_state(const MinMaxNAggregateState<LT, IsMin>& state, BinaryColumn* dst) const {
        Bytes& bytes = dst->get_bytes();
        const size_t old_size = bytes.size();

        // Get sorted values (no mutable cache)
        std::vector<CppType> values;
        state.get_sorted_values(values);
        size_t count = values.size();

        // Calculate total size needed
        size_t total_size = sizeof(int32_t) + sizeof(uint32_t); // n + count
        for (const auto& value : values) {
            if constexpr (IsSlice<CppType>) {
                total_size += sizeof(int64_t) + value.size; // len + data
            } else {
                total_size += sizeof(CppType);
            }
        }

        bytes.resize(old_size + total_size);
        size_t start = old_size;

        // Write n value
        std::memcpy(bytes.data() + start, &state.n, sizeof(int32_t));
        start += sizeof(int32_t);

        // Write element count
        uint32_t count_u32 = static_cast<uint32_t>(count);
        std::memcpy(bytes.data() + start, &count_u32, sizeof(uint32_t));
        start += sizeof(uint32_t);

        // Write elements
        if constexpr (IsSlice<CppType>) {
            // Variable-length type (Slice): serialize one by one
            for (const auto& value : values) {
                int64_t len = static_cast<int64_t>(value.size);
                std::memcpy(bytes.data() + start, &len, sizeof(int64_t));
                start += sizeof(int64_t);
                if (len > 0) {
                    std::memcpy(bytes.data() + start, value.data, len);
                    start += len;
                }
            }
        } else {
            // Fixed-length type: bulk copy for better performance
            // std::vector memory is contiguous, copy all elements at once
            if (count > 0) {
                std::memcpy(bytes.data() + start, values.data(), count * sizeof(CppType));
                start += count * sizeof(CppType);
            }
        }

        dst->get_offset().emplace_back(old_size + total_size);
    }

    void batch_serialize(FunctionContext* ctx, size_t chunk_size, const Buffer<AggDataPtr>& agg_states,
                         size_t state_offset, Column* to) const override {
        auto* column = down_cast<BinaryColumn*>(to);
        for (size_t i = 0; i < chunk_size; i++) {
            serialize_state(this->data(agg_states[i] + state_offset), column);
        }
    }

    void finalize_to_column(FunctionContext* ctx, ConstAggDataPtr __restrict state, Column* to) const override {
        // Like approx_top_k: finalize_to_column outputs to ArrayColumn (final result)
        DCHECK(to->is_array());
        auto& state_impl = this->data(const_cast<AggDataPtr>(state));

        if (UNLIKELY(state_impl.check_overflow(ctx))) {
            return;
        }

        auto* array_column = down_cast<ArrayColumn*>(to);

        // Get sorted values from heap
        std::vector<CppType> values;
        state_impl.get_sorted_values(values);

        // Handle empty result
        if (values.empty()) {
            array_column->append_default();
            return;
        }

        // Create a temporary column to hold the array elements
        auto temp_column = InputColumnType::create();
        for (const auto& value : values) {
            if constexpr (IsSlice<CppType>) {
                temp_column->append(value);
            } else {
                AggDataTypeTraits<LT>::append_value(temp_column.get(), value);
            }
        }

        // Use the safe append_array_element method
        array_column->append_array_element(*temp_column, 0);

        if (UNLIKELY(state_impl.check_overflow(*to, ctx, FUNC_NAME))) {
            return;
        }
    }

    std::string get_name() const override { return FUNC_NAME; }
};

// Convenience aliases for min_n and max_n
template <LogicalType LT>
using MinNAggregateFunction = MinMaxNAggregateFunction<LT, true>;

template <LogicalType LT>
using MaxNAggregateFunction = MinMaxNAggregateFunction<LT, false>;

} // namespace starrocks
