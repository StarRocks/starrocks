-- name: test_fe_threads_basic @sequential
-- Test basic queries on information_schema.fe_threads table

-- Test 1: Basic select with limit
select count(*) > 0 from information_schema.fe_threads;

-- Test 2: Verify all columns exist and have valid data
select 
    fe_id is not null,
    thread_id > 0,
    thread_name is not null,
    thread_state is not null,
    is_daemon is not null,
    priority >= 0,
    cpu_time_ms >= -1,
    user_time_ms >= -1
from information_schema.fe_threads limit 1;

-- Test 3: Filter by thread state
select count(*) >= 0 from information_schema.fe_threads where thread_state = 'RUNNABLE';

-- Test 4: Filter by daemon threads
select count(*) >= 0 from information_schema.fe_threads where is_daemon = true;

-- Test 5: Filter by non-daemon threads
select count(*) >= 0 from information_schema.fe_threads where is_daemon = false;

-- Test 6: Group by thread state
select thread_state, count(*) as cnt 
from information_schema.fe_threads 
group by thread_state 
order by cnt desc 
limit 5;

-- Test 7: Verify FE_ID format (should be host:port)
select fe_id like '%:%' from information_schema.fe_threads limit 1;

-- Test 8: Check for common JVM thread names
select count(*) > 0 from information_schema.fe_threads 
where thread_name like '%main%' 
   or thread_name like '%GC%' 
   or thread_name like '%Finalizer%'
   or thread_name like '%Reference Handler%'
   or thread_name like '%RMI%';

-- Test 9: Verify thread priorities are in valid range (typically 1-10)
select count(*) >= 0 from information_schema.fe_threads 
where priority >= 1 and priority <= 10;

-- Test 10: Test aggregation functions
select 
    count(*) as total_threads,
    count(distinct thread_state) as distinct_states,
    count(distinct thread_name) as distinct_names,
    sum(case when is_daemon then 1 else 0 end) as daemon_count,
    sum(case when not is_daemon then 1 else 0 end) as non_daemon_count
from information_schema.fe_threads;
