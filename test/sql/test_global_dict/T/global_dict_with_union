-- name: test_global_dict_with_union

-- test_union_filter_after_union
-- expect: Filter -> Union -> Scan
CREATE TABLE test_table_1 (
    id INT,
    value VARCHAR(10)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');


CREATE TABLE test_table_2 (
    id INT,
    value VARCHAR(10)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');


INSERT INTO test_table_1 VALUES (1, 'a'), (2, 'b'), (3, 'c');
INSERT INTO test_table_2 VALUES (4, 'd'), (5, 'e'), (6, 'f');

[UC]analyze full table test_table_1;
[UC]analyze full table test_table_2;

function: wait_global_dict_ready('value', 'test_table_1')
function: wait_global_dict_ready('value', 'test_table_2')


SELECT * 
FROM (
    SELECT id, value FROM test_table_1
    UNION ALL
    SELECT id, value FROM test_table_2
) t
WHERE id > 3;

-- test_union_filter_before_union
-- expect: Union(Filter(Scan), Filter(Scan))
SELECT id, value FROM test_table_1 WHERE id < 3
UNION ALL
SELECT id, value FROM test_table_2 WHERE id > 4;

-- test_union_aggregate_after_union
-- expect: Aggregate -> Union -> Scan
SELECT value, COUNT(*) AS cnt
FROM (
    SELECT id, value FROM test_table_1
    UNION ALL
    SELECT id, value FROM test_table_2
) t
GROUP BY value;

-- test_union_aggregate_before_union
-- expect: Union(Aggregate(Scan), Aggregate(Scan))
SELECT value, COUNT(*) AS cnt
FROM test_table_1
GROUP BY value
UNION ALL
SELECT value, COUNT(*) AS cnt
FROM test_table_2
GROUP BY value;

-- test_union_order_and_limit
-- expect: Limit -> Sort -> Union
SELECT id, value
FROM (
    SELECT id, value FROM test_table_1
    UNION ALL
    SELECT id, value FROM test_table_2
) t
ORDER BY id DESC
LIMIT 4;

-- test_union_join_after_union
-- expect: Join -> Union -> Scan
CREATE TABLE join_table (
    id INT,
    detail VARCHAR(10)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO join_table VALUES (1, 'info1'), (5, 'info5');

[UC]analyze full table join_table;
function: wait_global_dict_ready('detail', 'join_table')

SELECT t1.id, t1.value, jt.detail
FROM (
    SELECT id, value FROM test_table_1
    UNION ALL
    SELECT id, value FROM test_table_2
) t1
JOIN join_table jt
ON t1.id = jt.id;

-- test_union_join_before_union
-- expect: Union(Join(Scan, Scan), Join(Scan, Scan))
SELECT a.id, a.value, b.detail 
FROM test_table_1 a
JOIN join_table b
ON a.id = b.id
UNION ALL
SELECT c.id, c.value, d.detail 
FROM test_table_2 c
JOIN join_table d
ON c.id = d.id;

-- test_nested_union
-- expect: Union(Union(Scan, Scan), Scan)
SELECT id, value
FROM (
    SELECT id, value FROM test_table_1
    UNION ALL
    SELECT id, value FROM test_table_2
    UNION ALL
    SELECT id, detail FROM join_table
) t;

-- test_union_with_alias_in_subquery
-- expect: Filter -> Union(Alias(Scan), Alias(Scan))
CREATE TABLE alias_table_1 (
    col1 INT,
    col2 VARCHAR(10)
) DUPLICATE KEY(col1)
DISTRIBUTED BY HASH(col1) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE alias_table_2 (
    col1 INT,
    col2 VARCHAR(10)
) DUPLICATE KEY(col1)
DISTRIBUTED BY HASH(col1) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO alias_table_1 VALUES (1, 'alpha'), (2, 'beta'), (3, 'gamma');
INSERT INTO alias_table_2 VALUES (4, 'delta'), (5, 'epsilon');

[UC]analyze full table alias_table_1;
[UC]analyze full table alias_table_2;


function: wait_global_dict_ready('col2', 'alias_table_1')
function: wait_global_dict_ready('col2', 'alias_table_2')


SELECT alias_col1, alias_col2 
FROM (
    SELECT col1 AS alias_col1, col2 AS alias_col2 FROM alias_table_1
    UNION ALL
    SELECT col1 AS alias_col1, col2 AS alias_col2 FROM alias_table_2
) t
WHERE alias_col1 > 2;

-- test_union_with_different_column_names
-- expect: Union(Rename(Scan), Rename(Scan))
CREATE TABLE diff_table_1 (
    a INT,
    b VARCHAR(10)
) DUPLICATE KEY(a)
DISTRIBUTED BY HASH(a) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE diff_table_2 (
    x INT,
    y VARCHAR(10)
) DUPLICATE KEY(x)
DISTRIBUTED BY HASH(x) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO diff_table_1 VALUES (1, 'one'), (2, 'two');
INSERT INTO diff_table_2 VALUES (3, 'three'), (4, 'four');

[UC]analyze full table diff_table_1;
[UC]analyze full table diff_table_2;

function: wait_global_dict_ready('b', 'diff_table_1')
function: wait_global_dict_ready('y', 'diff_table_2')

SELECT col1, col2
FROM (
    SELECT a AS col1, b AS col2 FROM diff_table_1
    UNION ALL
    SELECT x AS col1, y AS col2 FROM diff_table_2
) t;

-- test_union_with_distinct
-- expect: Aggregate(Distinct) -> Union -> Scan
SELECT DISTINCT id, value 
FROM (
    SELECT id, value FROM test_table_1
    UNION ALL
    SELECT id, value FROM test_table_2
) t;

-- test_union_with_having_clause
-- expect: Filter(Having) -> Aggregate -> Union -> Scan
SELECT id, COUNT(*) AS cnt 
FROM (
    SELECT id, value FROM test_table_1
    UNION ALL
    SELECT id, value FROM test_table_2
) t
GROUP BY id
HAVING cnt > 1;

-- test_union_with_complex_predicates
-- expect: Filter(ComplexPredicate) -> Union -> Scan
SELECT id, value 
FROM (
    SELECT id, value FROM test_table_1
    UNION ALL
    SELECT id, value FROM test_table_2
) t
WHERE id > 2 AND value LIKE 'a%' AND (id + 5 < 10 OR value = 'f');

-- test_union_chains_with_filters
-- expect: Filter -> Union(Filter(Scan), Filter(Scan), Filter(Scan))
SELECT id, value 
FROM (
    SELECT id, value FROM test_table_1 WHERE value = 'a'
    UNION ALL
    SELECT id, value FROM test_table_2 WHERE value = 'b'
    UNION ALL
    SELECT id, detail FROM join_table WHERE detail = 'info1'
) t
WHERE id < 5;

-- test_union_with_cross_join_after_union
-- expect: CrossJoin -> Union -> Scan
SELECT t1.id, t1.value, t2.id, t2.detail 
FROM (
    SELECT id, value FROM test_table_1
    UNION ALL
    SELECT id, value FROM test_table_2
) t1
CROSS JOIN join_table t2;

-- test_union_with_empty_branches
-- expect: Union(Empty, Scan)
SELECT id, value 
FROM (
    SELECT id, value FROM test_table_1 WHERE 1 = 0
    UNION ALL
    SELECT id, value FROM test_table_2
) t;

-- test_union_with_constant_projection
-- expect: Project(Constant) -> Union -> Scan
SELECT fixed_col, id 
FROM (
    SELECT 'Constant1' AS fixed_col, id FROM test_table_1
    UNION ALL
    SELECT 'Constant2' AS fixed_col, id FROM test_table_2
) t;

-- test_union_complex_with_multiple_levels
-- expect: Union(Union(Scan, Filter(Scan)), Union(Aggregate->Scan, Join->Scan))
SELECT col1, col2 
FROM (
    SELECT col1, col2 
    FROM (
        SELECT id AS col1, value AS col2 FROM test_table_1
        UNION ALL
        SELECT id AS col1, value AS col2 FROM test_table_2 WHERE id > 4
    ) subquery1
    UNION ALL
    SELECT id AS col1, detail AS col2 
    FROM (
        SELECT id, detail FROM join_table
        UNION ALL
        SELECT id, detail FROM join_table WHERE id = 1
    ) subquery2
) t;

-- test_union_with_alias_and_aggregate
-- expect: Aggregate -> Union -> Alias -> Scan
CREATE TABLE alias_agg_table_1 (
    c1 INT,
    c2 VARCHAR(10)
) DUPLICATE KEY(c1)
DISTRIBUTED BY HASH(c1) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE alias_agg_table_2 (
    c1 INT,
    c2 VARCHAR(10)
) DUPLICATE KEY(c1)
DISTRIBUTED BY HASH(c1) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO alias_agg_table_1 VALUES (1, 'x'), (2, 'y'), (3, 'z');
INSERT INTO alias_agg_table_2 VALUES (4, 'p'), (5, 'q'), (6, 'r');

[UC]analyze full table alias_agg_table_1;
[UC]analyze full table alias_agg_table_2;
function: wait_global_dict_ready('c2', 'alias_agg_table_1')
function: wait_global_dict_ready('c2', 'alias_agg_table_2')

SELECT alias_c1, COUNT(*) AS cnt
FROM (
    SELECT c1 AS alias_c1 FROM alias_agg_table_1
    UNION ALL
    SELECT c1 AS alias_c1 FROM alias_agg_table_2
) t
GROUP BY alias_c1;

SELECT c1, c2
FROM (
    SELECT c1, c2 FROM alias_agg_table_1
    UNION ALL
    SELECT c1, c2 FROM alias_agg_table_2
) t;

-- test_union_with_computed_columns
-- expect: Project(ComputedColumns) -> Union -> Scan
SELECT c1, computed_col 
FROM (
    SELECT c1, c2, c1 + 10 AS computed_col FROM alias_agg_table_1
    UNION ALL
    SELECT c1, c2, c1 * 2 AS computed_col FROM alias_agg_table_2
) t;

-- test_union_with_inner_ordering
-- expect: Union(Sort -> Scan, Sort -> Scan)
SELECT * 
FROM (
    SELECT c1, c2 FROM alias_agg_table_1 
    UNION ALL
    SELECT c1, c2 FROM alias_agg_table_2 
) t;

-- test_union_with_multiple_levels_and_limits
-- expect: Limit -> Sort -> Union(Limit -> Union(Scan, Scan), Limit -> Union(Scan, Scan))
SELECT c1, c2
FROM (
    SELECT c1, c2
    FROM (
        SELECT c1, c2 FROM alias_agg_table_1
        UNION ALL
        SELECT c1, c2 FROM alias_agg_table_2
        LIMIT 2
    ) subquery1
    UNION ALL
    SELECT c1, c2
    FROM (
        SELECT c1, c2 FROM alias_agg_table_1
        UNION ALL
        SELECT c1, c2 FROM alias_agg_table_2 LIMIT 1
    ) subquery2
) outer_query
ORDER BY c1, c2
LIMIT 4;

-- test_union_with_excluded_columns
-- expect: Filter -> Union(Filter(ExcludeColumns -> Scan), ExcludeColumns -> Scan)
CREATE TABLE exclude_col_table_1 (
    col1 INT,
    col2 INT,
    col3 VARCHAR(10)
) DUPLICATE KEY(col1)
DISTRIBUTED BY HASH(col1) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE exclude_col_table_2 (
    col1 INT,
    col2 INT,
    col3 VARCHAR(10)
) DUPLICATE KEY(col1)
DISTRIBUTED BY HASH(col1) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO exclude_col_table_1 VALUES (1, 10, 'foo'), (2, 20, 'bar'), (3, 30, 'baz');
INSERT INTO exclude_col_table_2 VALUES (4, 40, 'qux'), (5, 50, 'quux'), (6, 60, 'corge');

[UC]analyze full table exclude_col_table_1;
[UC]analyze full table exclude_col_table_2;
function: wait_global_dict_ready('col3', 'exclude_col_table_1')
function: wait_global_dict_ready('col3', 'exclude_col_table_2')

SELECT col1, col3
FROM (
    SELECT col1, col3 FROM exclude_col_table_1 WHERE col2 > 15
    UNION ALL
    SELECT col1, col3 FROM exclude_col_table_2
) t;

-- test_union_with_union_in_join_condition
-- expect: Join(Union -> Scan, Scan -> Union)
CREATE TABLE join_cond_table_1 (
    id INT,
    detail VARCHAR(10)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE join_cond_table_2 (
    id INT,
    detail VARCHAR(10)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO join_cond_table_1 VALUES (1, 'info1'), (3, 'info3');
INSERT INTO join_cond_table_2 VALUES (2, 'info2'), (4, 'info4');

[UC]analyze full table join_cond_table_1;
[UC]analyze full table join_cond_table_2;
function: wait_global_dict_ready('detail', 'join_cond_table_1')
function: wait_global_dict_ready('detail', 'join_cond_table_2')

SELECT jt1.id, t.id, jt2.detail
FROM (
    SELECT id FROM join_cond_table_1
    UNION ALL
    SELECT id FROM join_cond_table_2
) t
JOIN join_cond_table_1 jt1 ON t.id = jt1.id
JOIN join_cond_table_2 jt2 ON t.id = jt2.id;

-- test_union_with_different_key_distributions
-- expect: Union(Hash(Scan), Broadcast(Scan))
CREATE TABLE hash_dist_table (
    key1 INT,
    key2 VARCHAR(10)
) DUPLICATE KEY(key1)
DISTRIBUTED BY HASH(key1) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE broadcast_dist_table (
    key1 INT,
    key2 VARCHAR(10)
) DUPLICATE KEY(key1)
DISTRIBUTED BY HASH(key1) BUCKETS 1
PROPERTIES('replication_num' = '1');

INSERT INTO hash_dist_table VALUES (1, 'h1'), (2, 'h2');
INSERT INTO broadcast_dist_table VALUES (3, 'b1'), (4, 'b2');

[UC]analyze full table hash_dist_table;
[UC]analyze full table broadcast_dist_table;
function: wait_global_dict_ready('key2', 'hash_dist_table')
function: wait_global_dict_ready('key2', 'broadcast_dist_table')

SELECT key1, key2
FROM (
    SELECT key1, key2 FROM hash_dist_table
    UNION ALL
    SELECT key1, key2 FROM broadcast_dist_table
) t;

-- test_union_with_no_double_and_functions
-- expect: Project(Function) -> Union(Scan, Scan)
CREATE TABLE func_table_1 (
    id INT,
    name VARCHAR(20),
    value INT
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE func_table_2 (
    id INT,
    name VARCHAR(20),
    value INT
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO func_table_1 VALUES (1, 'A', 100), (2, 'B', 200), (3, 'C', NULL);
INSERT INTO func_table_2 VALUES (4, 'D', 50), (5, 'E', NULL), (6, 'F', 300);

[UC]analyze full table func_table_1;
[UC]analyze full table func_table_2;
function: wait_global_dict_ready('name', 'func_table_1')
function: wait_global_dict_ready('name', 'func_table_2')

SELECT id, name, value, value + 10 AS adjusted_value
FROM (
    SELECT id, name, value FROM func_table_1
    UNION ALL
    SELECT id, name, value FROM func_table_2
) t
WHERE value IS NOT NULL AND value > 100;

-- test_union_with_aggregates_and_integers_only
-- expect: Aggregate -> Union -> Scan
CREATE TABLE agg_table_1 (
    id INT,
    category VARCHAR(20),
    count INT
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE agg_table_2 (
    id INT,
    category VARCHAR(20),
    count INT
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO agg_table_1 VALUES (1, 'A', 10), (2, 'B', 20), (3, 'C', 30);
INSERT INTO agg_table_2 VALUES (4, 'A', 40), (5, 'B', 50), (6, 'C', 60);

[UC]analyze full table agg_table_1;
[UC]analyze full table agg_table_2;
function: wait_global_dict_ready('category', 'agg_table_1')
function: wait_global_dict_ready('category', 'agg_table_2')

SELECT category, SUM(count) AS total_count
FROM (
    SELECT id, category, count FROM agg_table_1
    UNION ALL
    SELECT id, category, count FROM agg_table_2
) t
GROUP BY category;

-- test_union_integer_computation_with_filters
-- expect: Filter -> Project(ComputedColumn) -> Union(Scan, Scan)
CREATE TABLE compute_table_1 (
    id INT,
    value INT
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE compute_table_2 (
    id INT,
    value INT
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO compute_table_1 VALUES (1, 100), (2, 200), (3, 300);
INSERT INTO compute_table_2 VALUES (4, 400), (5, 500), (6, 600);


SELECT id, value, value + id AS computed_value
FROM (
    SELECT id, value FROM compute_table_1
    UNION ALL
    SELECT id, value FROM compute_table_2
) t
WHERE value > 200;

-- test_union_with_filters_in_subqueries
-- expect: Filter -> Union(Filter -> Scan, Filter -> Scan)
CREATE TABLE filter_table_1 (
    id INT,
    type VARCHAR(20),
    amount INT
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE filter_table_2 (
    id INT,
    type VARCHAR(20),
    amount INT
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO filter_table_1 VALUES (1, 'electronics', 100), (2, 'furniture', 200), (3, 'fashion', 300);
INSERT INTO filter_table_2 VALUES (4, 'electronics', 400), (5, 'furniture', 500), (6, 'fashion', 600);

[UC]analyze full table filter_table_1;
[UC]analyze full table filter_table_2;
function: wait_global_dict_ready('type', 'filter_table_1')
function: wait_global_dict_ready('type', 'filter_table_2')

SELECT id, type, amount
FROM (
    SELECT id, type, amount FROM filter_table_1 WHERE amount < 300
    UNION ALL
    SELECT id, type, amount FROM filter_table_2 WHERE amount > 400
) t;

-- test_union_with_nested_combination_of_integers
-- expect: Union(Union(Filter -> Scan, Scan), Union(Filter -> Scan, Scan))
CREATE TABLE nested_int_table_1 (
    id INT,
    group_id string
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE nested_int_table_2 (
    id INT,
    group_id string
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO nested_int_table_1 VALUES (1, 10), (2, 20), (3, 30);
INSERT INTO nested_int_table_2 VALUES (4, 40), (5, 50), (6, 60);

[UC]analyze full table nested_int_table_1;
[UC]analyze full table nested_int_table_2;
function: wait_global_dict_ready('group_id', 'nested_int_table_1')
function: wait_global_dict_ready('group_id', 'nested_int_table_2')

SELECT id, group_id
FROM (
    SELECT id, group_id
    FROM (
        SELECT id, group_id FROM nested_int_table_1 WHERE group_id < 30
        UNION ALL
        SELECT id, group_id FROM nested_int_table_2
    ) t1
    UNION ALL
    SELECT id, group_id
    FROM (
        SELECT id, group_id FROM nested_int_table_1
        UNION ALL
        SELECT id, group_id FROM nested_int_table_2 WHERE group_id > 30
    ) t2
) t;

-- test_cte_union_with_join
-- expect: Join -> Union -> CTE -> Scan
CREATE TABLE cte_table_1 (
    id INT,
    value VARCHAR(20)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE cte_table_2 (
    id INT,
    value VARCHAR(20)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE join_table_1 (
    id INT,
    detail VARCHAR(20)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO cte_table_1 VALUES (1, 'A'), (2, 'B'), (3, 'C');
INSERT INTO cte_table_2 VALUES (4, 'D'), (5, 'E'), (6, 'F');
INSERT INTO join_table_1 VALUES (1, 'info1'), (5, 'info5');

[UC]analyze full table cte_table_1;
[UC]analyze full table cte_table_2;
[UC]analyze full table join_table_1;
function: wait_global_dict_ready('value', 'cte_table_1')
function: wait_global_dict_ready('value', 'cte_table_2')
function: wait_global_dict_ready('detail', 'join_table_1')

WITH cte_union AS (
    SELECT id, value FROM cte_table_1
    UNION ALL
    SELECT id, value FROM cte_table_2
)
SELECT cte_union.id, cte_union.value, jt.detail
FROM cte_union
JOIN join_table_1 jt ON cte_union.id = jt.id;

-- test_ctas_with_union_and_join
-- expect: Join -> Union -> CTAS -> Scan
CREATE TABLE source_table_1 (
    col1 INT,
    col2 VARCHAR(20)
) DUPLICATE KEY(col1)
DISTRIBUTED BY HASH(col1) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE source_table_2 (
    col1 INT,
    col2 VARCHAR(20)
) DUPLICATE KEY(col1)
DISTRIBUTED BY HASH(col1) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE join_table_2 (
    col1 INT,
    col2 VARCHAR(20)
) DUPLICATE KEY(col1)
DISTRIBUTED BY HASH(col1) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO source_table_1 VALUES (1, 'X'), (2, 'Y'), (3, 'Z');
INSERT INTO source_table_2 VALUES (4, 'P'), (5, 'Q'), (6, 'R');
INSERT INTO join_table_2 VALUES (1, 'J1'), (4, 'J4');

[UC]analyze full table source_table_1;
[UC]analyze full table source_table_2;
[UC]analyze full table join_table_2;
function: wait_global_dict_ready('col2', 'source_table_1')
function: wait_global_dict_ready('col2', 'source_table_2')
function: wait_global_dict_ready('col2', 'join_table_2')

CREATE TABLE ctas_result
DUPLICATE KEY(col1)
DISTRIBUTED BY HASH(col1) BUCKETS 3
PROPERTIES('replication_num' = '1') AS
SELECT st1.col1, jt.col2
FROM (
    SELECT col1 FROM source_table_1
    UNION ALL
    SELECT col1 FROM source_table_2
) st1
JOIN join_table_2 jt ON st1.col1 = jt.col1;

-- test_union_and_cte_with_aggregation
-- expect: Aggregate -> Union -> CTE -> Scan
CREATE TABLE agg_cte_table_1 (
    id INT,
    category VARCHAR(20),
    amount INT
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE agg_cte_table_2 (
    id INT,
    category VARCHAR(20),
    amount INT
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO agg_cte_table_1 VALUES (1, 'Electronics', 300), (2, 'Furniture', 200), (3, 'Fashion', 700);
INSERT INTO agg_cte_table_2 VALUES (4, 'Electronics', 500), (5, 'Furniture', 100), (6, 'Fashion', 300);

[UC]analyze full table agg_cte_table_1;
[UC]analyze full table agg_cte_table_2;
function: wait_global_dict_ready('category', 'agg_cte_table_1')
function: wait_global_dict_ready('category', 'agg_cte_table_2')

WITH aggregated_union AS (
    SELECT id, category, amount FROM agg_cte_table_1
    UNION ALL
    SELECT id, category, amount FROM agg_cte_table_2
)
SELECT category, SUM(amount) AS total_amount
FROM aggregated_union
GROUP BY category;

-- test_ctas_with_multiple_unions
-- expect: Union -> Union -> CTAS -> Scan
CREATE TABLE multi_union_table_1 (
    col1 INT,
    col2 VARCHAR(20)
) DUPLICATE KEY(col1)
DISTRIBUTED BY HASH(col1) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE multi_union_table_2 (
    col1 INT,
    col2 VARCHAR(20)
) DUPLICATE KEY(col1)
DISTRIBUTED BY HASH(col1) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE multi_union_table_3 (
    col1 INT,
    col2 VARCHAR(20)
) DUPLICATE KEY(col1)
DISTRIBUTED BY HASH(col1) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO multi_union_table_1 VALUES (1, 'Alpha'), (2, 'Beta');
INSERT INTO multi_union_table_2 VALUES (3, 'Gamma'), (4, 'Delta');
INSERT INTO multi_union_table_3 VALUES (5, 'Epsilon'), (6, 'Zeta');

[UC]analyze full table multi_union_table_1;
[UC]analyze full table multi_union_table_2;
[UC]analyze full table multi_union_table_3;
function: wait_global_dict_ready('col2', 'multi_union_table_1')
function: wait_global_dict_ready('col2', 'multi_union_table_2')
function: wait_global_dict_ready('col2', 'multi_union_table_3')

CREATE TABLE ctas_result_2
DUPLICATE KEY(col1)
DISTRIBUTED BY HASH(col1) BUCKETS 3
PROPERTIES('replication_num' = '1') AS
SELECT col1, col2 FROM (
    SELECT col1, col2 FROM multi_union_table_1
    UNION ALL
    SELECT col1, col2 FROM multi_union_table_2
    UNION ALL
    SELECT col1, col2 FROM multi_union_table_3
) t;

-- test_union_with_large_result_and_group_by
-- expect: Aggregate -> Union -> LargeResults -> Scan
CREATE TABLE large_table_1 (
    id INT,
    value VARCHAR(50)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE large_table_2 (
    id INT,
    value VARCHAR(50)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO large_table_1 VALUES
(1, 'val1'), (2, 'val2'), (3, 'val3'),
(4, 'val4'), (5, 'val5'), (6, 'val6'),
(7, 'val7'), (8, 'val8'), (9, 'val9'),
(10, 'val10'), (11, 'val11'), (12, 'val12'),
(13, 'val13'), (14, 'val14'), (15, 'val15');

-- Repeat similar data to ensure > 300 rows
INSERT INTO large_table_1
SELECT id + 15, CONCAT('val', id + 15) FROM large_table_1;

INSERT INTO large_table_2
SELECT id + 30, CONCAT('str', id + 30) FROM large_table_1;

[UC]analyze full table large_table_1;
[UC]analyze full table large_table_2;
function: wait_global_dict_ready('value', 'large_table_1')
function: wait_global_dict_ready('value', 'large_table_2')

-- UNION results exceed 300 rows
SELECT id, COUNT(*) AS cnt
FROM (
    SELECT id, value FROM large_table_1
    UNION ALL
    SELECT id, value FROM large_table_2
) t
GROUP BY id
HAVING cnt > 1;

-- test_union_with_large_dict_broadcast
-- expect: Broadcast -> Union -> Scan -> LargeDict
CREATE TABLE broadcast_table_1 (
    id INT,
    `key` VARCHAR(50)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE broadcast_table_2 (
    id INT,
    `key` VARCHAR(50)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO broadcast_table_1
SELECT id, CONCAT('dict_broad_', id) FROM large_table_1;

INSERT INTO broadcast_table_2
SELECT id + 300, CONCAT('dict_broad_', id + 300) FROM large_table_1;

[UC]analyze full table broadcast_table_1;
[UC]analyze full table broadcast_table_2;
function: wait_global_dict_ready('`key`', 'broadcast_table_1')
function: wait_global_dict_ready('`key`', 'broadcast_table_2')

WITH union_broadcast AS (
    SELECT id, `key` FROM broadcast_table_1
    UNION ALL
    SELECT id, `key` FROM broadcast_table_2
)
SELECT `key`, COUNT(*) AS appearances
FROM union_broadcast
GROUP BY `key`
HAVING appearances > 1;

-- test_union_exceeded_dict_with_filter
-- expect: Filter -> Union(Scan(LargeDict), Scan(LargeDict)) -> DictHandling
CREATE TABLE dict_filter_table_1 (
    id INT,
    `text` VARCHAR(100)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

CREATE TABLE dict_filter_table_2 (
    id INT,
    `text` VARCHAR(100)
) DUPLICATE KEY(id)
DISTRIBUTED BY HASH(id) BUCKETS 3
PROPERTIES('replication_num' = '1');

INSERT INTO dict_filter_table_1
SELECT id, CONCAT('filter_case_', id) FROM large_table_1;

INSERT INTO dict_filter_table_2
SELECT id + 150, CONCAT('filter_case_', id + 150) FROM large_table_1;

[UC]analyze full table dict_filter_table_1;
[UC]analyze full table dict_filter_table_2;

function: wait_global_dict_ready('`text`', 'dict_filter_table_1')
function: wait_global_dict_ready('`text`', 'dict_filter_table_2')

SELECT *
FROM (
    SELECT id, `text` FROM dict_filter_table_1
    UNION ALL
    SELECT id, `text` FROM dict_filter_table_2
) t
WHERE LENGTH(`text`) > 10;