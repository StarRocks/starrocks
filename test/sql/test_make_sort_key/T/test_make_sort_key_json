-- name: test_make_sort_key_json
CREATE DATABASE test_make_sort_key_json;
USE test_make_sort_key_json;

-- Create a table with JSON data types and a single generated sort key column
-- The sort key extracts specific fields from JSON and combines them for efficient sorting
CREATE TABLE `json_test_table` (
  `id` int(11) NOT NULL COMMENT "",
  `json_data` json NOT NULL COMMENT "",
  `json_array` json NOT NULL COMMENT "",
  `json_nested` json NOT NULL COMMENT "",
  `sort_key` varbinary(1024) AS (
    make_sort_key(
      get_json_int(json_data, '$.age'),
      get_json_string(json_data, '$.name'),
      get_json_string(json_data, '$.city'),
      get_json_string(json_array, '$[0]'),
      get_json_double(json_nested, '$.user.profile.score')
    )
  ) COMMENT "Auto-generated sort key from extracted JSON fields"
) ENGINE=OLAP 
DISTRIBUTED BY HASH(sort_key) BUCKETS 1 
ORDER BY (sort_key)
PROPERTIES ( "replication_num" = "1");

-- Insert test data with various JSON structures
-- The sort key will be automatically generated from extracted JSON fields
INSERT INTO json_test_table (id, json_data, json_array, json_nested) VALUES
(1, parse_json('{"name": "Alice", "age": 25, "city": "New York"}'), 
     parse_json('["apple", "banana", "cherry"]'),
     parse_json('{"user": {"id": 101, "profile": {"verified": true, "score": 95.5}}}')),
(2, parse_json('{"name": "Bob", "age": 30, "city": "Los Angeles"}'), 
     parse_json('["orange", "grape"]'),
     parse_json('{"user": {"id": 102, "profile": {"verified": false, "score": 87.2}}}')),
(3, parse_json('{"name": "Charlie", "age": 28, "city": "Chicago"}'), 
     parse_json('["mango", "pineapple", "kiwi", "strawberry"]'),
     parse_json('{"user": {"id": 103, "profile": {"verified": true, "score": 92.8}}}')),
(4, parse_json('{"name": "Diana", "age": 22, "city": "Miami"}'), 
     parse_json('["pear"]'),
     parse_json('{"user": {"id": 104, "profile": {"verified": true, "score": 89.1}}}')),
(5, parse_json('{"name": "Eve", "age": 35, "city": "Seattle"}'), 
     parse_json('["blueberry", "raspberry", "blackberry"]'),
     parse_json('{"user": {"id": 105, "profile": {"verified": false, "score": 78.9}}}'));

-- Test 1: Verify that the generated sort key column is automatically populated
-- This shows how make_sort_key extracts and combines JSON fields
SELECT id, 
       json_data, 
       get_json_int(json_data, '$.age') as age,
       get_json_string(json_data, '$.name') as name,
       get_json_string(json_data, '$.city') as city,
       get_json_string(json_array, '$[0]') as first_fruit,
       get_json_double(json_nested, '$.user.profile.score') as score,
       sort_key,
       length(sort_key) as sort_key_length
FROM json_test_table 
ORDER BY id;

-- Test 2: Use the generated sort key for ordering
-- This demonstrates the performance benefit of pre-computed sort keys
SELECT id, json_data, json_array
FROM json_test_table 
ORDER BY sort_key;

-- Test 3: Show how the sort key combines multiple extracted fields
-- The sort key contains: age, name, city, first_fruit, score
SELECT id, 
       get_json_int(json_data, '$.age') as age,
       get_json_string(json_data, '$.name') as name,
       get_json_string(json_data, '$.city') as city,
       get_json_string(json_array, '$[0]') as first_fruit,
       get_json_double(json_nested, '$.user.profile.score') as score,
       sort_key
FROM json_test_table 
ORDER BY sort_key;

-- Test 4: Use generated sort key in WHERE clause for filtering
-- This shows practical usage of the generated column
SELECT id, json_data, json_array
FROM json_test_table 
WHERE sort_key > (SELECT sort_key FROM json_test_table WHERE id = 2)
ORDER BY id;

-- Test 5: Demonstrate that the sort key properly handles different data types
-- The extracted fields include: int (age), string (name, city, first_fruit), double (score)
SELECT id, 
       get_json_int(json_data, '$.age') as age,
       get_json_string(json_data, '$.name') as name,
       get_json_string(json_data, '$.city') as city,
       get_json_string(json_array, '$[0]') as first_fruit,
       json_extract(json_nested, '$.user.profile.score') as score
FROM json_test_table 
ORDER BY sort_key;

-- Test 6: Test with NULL JSON values and missing fields
-- This verifies how the function handles NULL inputs and missing JSON paths
INSERT INTO json_test_table (id, json_data, json_array, json_nested) VALUES
(6, NULL, parse_json('["test"]'), parse_json('{"test": null}')),
(7, parse_json('{"age": 40}'), parse_json('[]'), parse_json('{"user": {"id": 106}}'));

-- Verify that NULL JSON and missing fields generate appropriate sort keys
SELECT id, 
       json_data,
       get_json_int(json_data, '$.age') as age,
       get_json_string(json_data, '$.name') as name,
       get_json_string(json_data, '$.city') as city,
       get_json_string(json_array, '$[0]') as first_fruit,
       get_json_double(json_nested, '$.user.profile.score') as score,
       sort_key
FROM json_test_table 
WHERE id IN (6, 7)
ORDER BY id;

-- Test 7: Performance test - verify the generated column is populated
-- This demonstrates the function's performance characteristics
SELECT 
    count(*) as total_rows,
    count(sort_key) as rows_with_sort_keys,
    avg(length(sort_key)) as avg_sort_key_length
FROM json_test_table;

-- Test 8: Show table structure to verify the generated column definition
SHOW CREATE TABLE json_test_table;

-- Test 9: Demonstrate that the generated column is automatically updated
-- Update a JSON value and verify the sort key changes
UPDATE json_test_table 
SET json_data = parse_json('{"name": "Alice Updated", "age": 26, "city": "New York"}')
WHERE id = 1;

-- Verify the sort key was automatically updated with new extracted values
SELECT id, 
       json_data,
       get_json_int(json_data, '$.age') as age,
       get_json_string(json_data, '$.name') as name,
       get_json_string(json_data, '$.city') as city,
       sort_key
FROM json_test_table 
WHERE id = 1;

-- Test 10: Use the sort key for efficient range queries
-- This shows how the extracted fields enable efficient filtering and sorting
SELECT id, json_data, json_array
FROM json_test_table 
WHERE sort_key BETWEEN 
    (SELECT sort_key FROM json_test_table WHERE id = 4) AND 
    (SELECT sort_key FROM json_test_table WHERE id = 2)
ORDER BY sort_key;

-- Clean up
DROP DATABASE test_make_sort_key_json;
