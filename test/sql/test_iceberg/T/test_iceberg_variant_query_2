-- name: test_iceberg_variant_query_2

-- iceberg catalog on hive does not variant yet.

create external catalog iceberg_sql_test_${uuid0}
PROPERTIES ("type"="iceberg", "iceberg.catalog.type"="hadoop", "iceberg.catalog.warehouse"="oss://${oss_bucket}/test_iceberg_variant_query_2/${uuid0}/warehouse/");

shell: ossutil64 mkdir oss://${oss_bucket}/test_iceberg_variant_query_2/${uuid0}/warehouse/iceberg_variant > /dev/null

use iceberg_sql_test_${uuid0}.iceberg_variant;

CREATE TABLE variant_boundary_arrays_test (
    test_id INT,
    test_label STRING,
    element_count INT,
    variant_col VARIANT
)
properties(
  'format-version' = '3'
);

CREATE TABLE variant_boundary_nesting_test (
    test_id INT,
    test_label STRING,
    nesting_level INT,
    variant_col VARIANT
)
properties(
  'format-version' = '3'
);

CREATE TABLE variant_boundary_numeric_test (
    test_id INT,
    test_label STRING,
    numeric_type STRING,
    variant_col VARIANT,
    expected_value STRING
)
properties(
  'format-version' = '3'
);


shell: ossutil64 cp ./sql/test_iceberg/data/variant_boundary_arrays_test/data/00000-24-674b8b26-6472-4128-8c32-9d66ef01aaef-0-00001.parquet oss://${oss_bucket}/test_iceberg_variant_query_2/${uuid0}/variant_boundary_arrays_test/data/00000-24-674b8b26-6472-4128-8c32-9d66ef01aaef-0-00001.parquet > /dev/null
shell: ossutil64 cp ./sql/test_iceberg/data/variant_boundary_nesting_test/data/00000-3259-51ac14b0-15f6-4c29-97c4-a01fcf3682e7-0-00001.parquet oss://${oss_bucket}/test_iceberg_variant_query_2/${uuid0}/variant_boundary_nesting_test/data/00000-3259-51ac14b0-15f6-4c29-97c4-a01fcf3682e7-0-00001.parquet > /dev/null
shell: ossutil64 cp ./sql/test_iceberg/data/variant_boundary_numeric_test/data/00000-3870-872c970a-5f72-465f-8b93-54fde4db0ffa-0-00001.parquet oss://${oss_bucket}/test_iceberg_variant_query_2/${uuid0}/variant_boundary_numeric_test/data/00000-3870-872c970a-5f72-465f-8b93-54fde4db0ffa-0-00001.parquet > /dev/null

alter table variant_boundary_arrays_test execute add_files(location='oss://${oss_bucket}/test_iceberg_variant_query_2/${uuid0}/variant_boundary_arrays_test/data/00000-24-674b8b26-6472-4128-8c32-9d66ef01aaef-0-00001.parquet', file_format='parquet');
alter table variant_boundary_nesting_test execute add_files(location='oss://${oss_bucket}/test_iceberg_variant_query_2/${uuid0}/variant_boundary_nesting_test/data/00000-3259-51ac14b0-15f6-4c29-97c4-a01fcf3682e7-0-00001.parquet', file_format='parquet');
alter table variant_boundary_numeric_test execute add_files(location='oss://${oss_bucket}/test_iceberg_variant_query_2/${uuid0}/variant_boundary_numeric_test/data/00000-3870-872c970a-5f72-465f-8b93-54fde4db0ffa-0-00001.parquet', file_format='parquet');


-- ========================================
-- P0 Boundary Conditions Validation Queries
-- ========================================

-- ========================================
-- Query 1: Large Array Element Access
-- Test IDs: UNC-3.1.4, UNC-3.1.5
-- ========================================
SELECT 'Query 1: Validate large array element extraction' AS test_description;
SELECT
    test_id,
    test_label,
    element_count,
    get_variant_int(variant_col, '$[0]') as first_element,
    get_variant_int(variant_col, concat('$[', cast(element_count / 2 as string), ']')) as middle_element,
    get_variant_int(variant_col, concat('$[', cast(element_count - 1 as string), ']')) as last_element,
    CASE
        WHEN get_variant_int(variant_col, '$[0]') = 1 AND
             get_variant_int(variant_col, concat('$[', cast(element_count - 1 as string), ']')) = element_count
        THEN 'PASS'
        ELSE 'FAIL'
    END as test_result
FROM variant_boundary_arrays_test
WHERE test_id <= 3
ORDER BY test_id;

-- ========================================
-- Query 2: Large Map Key Access
-- Test IDs: UNC-3.1.6, UNC-3.1.7
-- ========================================
SELECT 'Query 2: Validate large map key extraction' AS test_description;
SELECT
    test_id,
    test_label,
    element_count,
    get_variant_int(variant_col, '$.k1') as first_key,
    get_variant_int(variant_col, '$.k10') as tenth_key,
    get_variant_int(variant_col, concat('$.k', cast(element_count as string))) as last_key,
    CASE
        WHEN get_variant_int(variant_col, '$.k1') = 1 THEN 'PASS'
        ELSE 'FAIL'
    END as test_result
FROM variant_boundary_arrays_test
WHERE test_id > 3
ORDER BY test_id;

-- ========================================
-- Query 3: Deep Nesting Extraction
-- Test IDs: UNC-3.2.1, UNC-3.2.2, UNC-1.3.1
-- ========================================
SELECT 'Query 3: Validate deep nesting path extraction' AS test_description;
SELECT
    test_id,
    test_label,
    nesting_level,
    CASE nesting_level
        WHEN 8 THEN get_variant_string(variant_col, '$.l1.l2.l3.l4.l5.l6.l7.l8')
        WHEN 10 THEN get_variant_string(variant_col, '$.l1.l2.l3.l4.l5.l6.l7.l8.l9.l10')
        WHEN 15 THEN get_variant_string(variant_col, '$.l1.l2.l3.l4.l5.l6.l7.l8.l9.l10.l11.l12.l13.l14.l15')
        WHEN 20 THEN get_variant_string(variant_col, '$.l1.l2.l3.l4.l5.l6.l7.l8.l9.l10.l11.l12.l13.l14.l15.l16.l17.l18.l19.l20')
    END as extracted_value,
    CASE
        WHEN nesting_level = 8 AND get_variant_string(variant_col, '$.l1.l2.l3.l4.l5.l6.l7.l8') = 'deep_value_8' THEN 'PASS'
        WHEN nesting_level = 10 AND get_variant_string(variant_col, '$.l1.l2.l3.l4.l5.l6.l7.l8.l9.l10') = 'deep_value_10' THEN 'PASS'
        WHEN nesting_level = 15 AND get_variant_string(variant_col, '$.l1.l2.l3.l4.l5.l6.l7.l8.l9.l10.l11.l12.l13.l14.l15') = 'deep_value_15' THEN 'PASS'
        WHEN nesting_level = 20 AND get_variant_string(variant_col, '$.l1.l2.l3.l4.l5.l6.l7.l8.l9.l10.l11.l12.l13.l14.l15.l16.l17.l18.l19.l20') = 'deep_value_20' THEN 'PASS'
        ELSE 'FAIL'
    END as test_result
FROM variant_boundary_nesting_test
WHERE test_id <= 4
ORDER BY test_id;

-- ========================================
-- Query 4: Mixed Nesting (Arrays and Objects)
-- ========================================
SELECT 'Query 4: Validate mixed array/object deep nesting' AS test_description;
SELECT
    test_id,
    test_label,
    nesting_level,
    get_variant_string(variant_col, '$.a[0].b.c[0].d.e[0].f.g[0].h.i') as extracted_value,
    CASE
        WHEN get_variant_string(variant_col, '$.a[0].b.c[0].d.e[0].f.g[0].h.i') = 'mixed_deep_10' THEN 'PASS'
        ELSE 'FAIL'
    END as test_result
FROM variant_boundary_nesting_test
WHERE test_id = 5;

-- ========================================
-- Query 5: Nested Arrays
-- ========================================
SELECT 'Query 5: Validate nested array access' AS test_description;
SELECT
    test_id,
    test_label,
    get_variant_int(variant_col, '$[0][0][0][0][0]') as deeply_nested_value,
    CASE
        WHEN get_variant_int(variant_col, '$[0][0][0][0][0]') = 42 THEN 'PASS'
        ELSE 'FAIL'
    END as test_result
FROM variant_boundary_nesting_test
WHERE test_id = 6;

-- ========================================
-- Query 6: INT Boundaries
-- Test IDs: UNC-3.3.1, UNC-3.3.2
-- ========================================
SELECT 'Query 6: Validate INT min/max boundary values' AS test_description;
SELECT
    test_id,
    test_label,
    numeric_type,
    get_variant_int(variant_col, '$') as extracted_int,
    CAST(variant_col AS BIGINT) as cast_bigint,
    expected_value,
    CASE
        WHEN CAST(get_variant_int(variant_col, '$') AS STRING) = expected_value THEN 'PASS'
        ELSE 'FAIL'
    END as test_result
FROM variant_boundary_numeric_test
WHERE numeric_type = 'INT'
ORDER BY test_id;

-- ========================================
-- Query 7: BIGINT Boundaries
-- Test IDs: UNC-3.3.3, UNC-3.3.4
-- ========================================
SELECT 'Query 7: Validate BIGINT min/max boundary values' AS test_description;
SELECT
    test_id,
    test_label,
    numeric_type,
    CAST(variant_col AS BIGINT) as extracted_bigint,
    expected_value,
    CASE
        WHEN CAST(CAST(variant_col AS BIGINT) AS STRING) = expected_value THEN 'PASS'
        ELSE 'FAIL'
    END as test_result
FROM variant_boundary_numeric_test
WHERE numeric_type = 'BIGINT'
ORDER BY test_id;

-- ========================================
-- Query 8: SMALLINT Boundaries
-- ========================================
SELECT 'Query 8: Validate SMALLINT boundary values' AS test_description;
SELECT
    test_id,
    test_label,
    numeric_type,
    get_variant_int(variant_col, '$') as original_value,
    CAST(variant_col AS SMALLINT) as cast_smallint,
    expected_value,
    CASE
        WHEN CAST(CAST(variant_col AS SMALLINT) AS STRING) = expected_value THEN 'PASS'
        ELSE 'FAIL'
    END as test_result
FROM variant_boundary_numeric_test
WHERE numeric_type = 'SMALLINT'
ORDER BY test_id;

-- ========================================
-- Query 9: DOUBLE Boundaries
-- Test IDs: UNC-3.3.5, UNC-3.3.6
-- ========================================
SELECT 'Query 9: Validate DOUBLE extreme values' AS test_description;
SELECT
    test_id,
    test_label,
    numeric_type,
    get_variant_double(variant_col, '$') as extracted_double,
    CAST(variant_col AS DOUBLE) as cast_double,
    expected_value,
    CASE
        WHEN get_variant_double(variant_col, '$') IS NOT NULL THEN 'PASS'
        ELSE 'FAIL'
    END as test_result
FROM variant_boundary_numeric_test
WHERE numeric_type = 'DOUBLE'
ORDER BY test_id;

-- ========================================
-- Query 10: DECIMAL Boundaries
-- Test IDs: UNC-3.3.10, UNC-3.3.11
-- ========================================
SELECT 'Query 10: Validate DECIMAL precision and scale' AS test_description;
SELECT
    test_id,
    test_label,
    numeric_type,
    get_variant_string(variant_col, '$') as extracted_string,
    expected_value,
    CASE
        WHEN get_variant_string(variant_col, '$') = expected_value THEN 'PASS'
        ELSE 'FAIL'
    END as test_result
FROM variant_boundary_numeric_test
WHERE numeric_type LIKE 'DECIMAL%'
ORDER BY test_id;

-- ========================================
-- Query 11: Negative Zero Handling
-- Test ID: UNC-3.3.12
-- ========================================
SELECT 'Query 11: Validate negative zero handling' AS test_description;
SELECT
    test_id,
    test_label,
    get_variant_double(variant_col, '$') as extracted_value,
    CAST(variant_col AS DOUBLE) as cast_value,
    expected_value,
    CASE
        WHEN CAST(variant_col AS DOUBLE) = 0.0 THEN 'PASS'
        ELSE 'FAIL'
    END as test_result
FROM variant_boundary_numeric_test
WHERE test_label IN ('double_negative_zero', 'double_positive_zero')
ORDER BY test_id;

-- ========================================
-- Query 12: Comprehensive Numeric Type Detection
-- ========================================
SELECT 'Query 12: Verify variant_typeof for numeric types' AS test_description;
SELECT
    test_id,
    test_label,
    numeric_type,
    variant_typeof(variant_query(variant_col, '$')) as detected_type,
    CASE
        WHEN numeric_type = 'INT' AND variant_typeof(variant_query(variant_col, '$')) = 'Int32' THEN 'PASS'
        WHEN numeric_type = 'BIGINT' AND variant_typeof(variant_query(variant_col, '$')) = 'Int64' THEN 'PASS'
        WHEN numeric_type = 'SMALLINT' AND variant_typeof(variant_query(variant_col, '$')) = 'Int16' THEN 'PASS'
        WHEN numeric_type = 'DOUBLE' AND variant_typeof(variant_query(variant_col, '$')) = 'Double' THEN 'PASS'
        ELSE 'FAIL'
    END as test_result
FROM variant_boundary_numeric_test
WHERE test_id <= 10
ORDER BY test_id;

-- ========================================
-- Query 13: Array Size Performance Check
-- ========================================
SELECT 'Query 13: Array size and access performance summary' AS test_description;
SELECT
    test_label,
    element_count,
    CASE
        WHEN get_variant_int(variant_col, '$[0]') IS NOT NULL AND
             get_variant_int(variant_col, concat('$[', cast(element_count - 1 as string), ']')) IS NOT NULL
        THEN 'ACCESSIBLE'
        ELSE 'ERROR'
    END as accessibility_status
FROM variant_boundary_arrays_test
WHERE test_id <= 3
ORDER BY element_count;

drop table variant_boundary_arrays_test force;
drop table variant_boundary_nesting_test force;
drop table variant_boundary_numeric_test force;
set catalog default_catalog;
drop catalog iceberg_sql_test_${uuid0};

shell: ossutil64 rm -rf oss://${oss_bucket}/test_iceberg_variant_query_2/${uuid0}/ > /dev/null

-- use spark to generate those data files

-- -- ========================================
-- -- P0 Boundary Conditions Test Suite
-- -- Covers: UNC-3.1.x (Size), UNC-3.2.x (Nesting), UNC-3.3.x (Numeric)
-- -- ========================================
-- -- This test suite validates VARIANT boundary handling for:
-- -- - Large arrays and maps
-- -- - Deep nesting (8, 10, 20 levels)
-- -- - Numeric boundaries (INT min/max, BIGINT, DOUBLE, DECIMAL)
-- -- - Special numeric values (negative zero, infinity, NaN)
-- -- ========================================

-- use iceberg_glue2.zya;

-- DROP TABLE IF EXISTS variant_boundary_arrays_test;
-- DROP TABLE IF EXISTS variant_boundary_nesting_test;
-- DROP TABLE IF EXISTS variant_boundary_numeric_test;

-- -- ========================================
-- -- Test 1: Large Arrays and Maps
-- -- Test IDs: UNC-3.1.4, UNC-3.1.5, UNC-3.1.6, UNC-3.1.7
-- -- ========================================
-- CREATE TABLE variant_boundary_arrays_test (
--     test_id INT,
--     test_label STRING,
--     element_count INT,
--     variant_col VARIANT
-- ) USING iceberg
-- TBLPROPERTIES (
--     'format-version' = '3',
--     'write.format.default' = 'parquet',
--     'engine.hive.enabled' = 'false'
-- );

-- -- Generate large arrays
-- WITH precomputed_arrays AS (
--     SELECT
--         1 AS test_id,
--         'array_100_elements' AS test_label,
--         100 AS element_count,
--         parse_json(concat('[', array_join(transform(sequence(1, 100), x -> cast(x AS string)), ','), ']')) AS variant_col
--     UNION ALL
--     SELECT
--         2,
--         'array_1000_elements',
--         1000,
--         parse_json(concat('[', array_join(transform(sequence(1, 1000), x -> cast(x AS string)), ','), ']'))
--     UNION ALL
--     SELECT
--         3,
--         'array_10000_elements',
--         10000,
--         parse_json(concat('[', array_join(transform(sequence(1, 10000), x -> cast(x AS string)), ','), ']'))
-- )
-- INSERT INTO variant_boundary_arrays_test
-- SELECT * FROM precomputed_arrays;

-- -- Generate maps with many keys (using nested structure as workaround)
-- WITH precomputed_maps AS (
--     SELECT
--         4 AS test_id,
--         'map_10_keys' AS test_label,
--         10 AS element_count,
--         parse_json('{"k1":1,"k2":2,"k3":3,"k4":4,"k5":5,"k6":6,"k7":7,"k8":8,"k9":9,"k10":10}') AS variant_col
--     UNION ALL
--     SELECT
--         5,
--         'map_50_keys',
--         50,
--         parse_json(concat('{',
--             array_join(transform(sequence(1, 50), x -> concat('"k', cast(x as string), '":', cast(x as string))), ','),
--             '}'))
--     UNION ALL
--     SELECT
--         6,
--         'map_100_keys',
--         100,
--         parse_json(concat('{',
--             array_join(transform(sequence(1, 100), x -> concat('"k', cast(x as string), '":', cast(x as string))), ','),
--             '}'))
-- )
-- INSERT INTO variant_boundary_arrays_test
-- SELECT * FROM precomputed_maps;

-- -- ========================================
-- -- Test 2: Deep Nesting
-- -- Test IDs: UNC-3.2.1, UNC-3.2.2, UNC-1.3.1
-- -- ========================================
-- CREATE TABLE variant_boundary_nesting_test (
--     test_id INT,
--     test_label STRING,
--     nesting_level INT,
--     variant_col VARIANT
-- ) USING iceberg
-- TBLPROPERTIES (
--     'format-version' = '3',
--     'write.format.default' = 'parquet',
--     'engine.hive.enabled' = 'false'
-- );

-- INSERT INTO variant_boundary_nesting_test VALUES
--     -- 8-level nesting
--     (1, 'nesting_8_levels', 8,
--         parse_json('{"l1":{"l2":{"l3":{"l4":{"l5":{"l6":{"l7":{"l8":"deep_value_8"}}}}}}}}')),

--     -- 10-level nesting
--     (2, 'nesting_10_levels', 10,
--         parse_json('{"l1":{"l2":{"l3":{"l4":{"l5":{"l6":{"l7":{"l8":{"l9":{"l10":"deep_value_10"}}}}}}}}}}')),

--     -- 15-level nesting
--     (3, 'nesting_15_levels', 15,
--         parse_json('{"l1":{"l2":{"l3":{"l4":{"l5":{"l6":{"l7":{"l8":{"l9":{"l10":{"l11":{"l12":{"l13":{"l14":{"l15":"deep_value_15"}}}}}}}}}}}}}}}')),'

--     -- 20-level nesting
--     (4, 'nesting_20_levels', 20,
--         parse_json('{"l1":{"l2":{"l3":{"l4":{"l5":{"l6":{"l7":{"l8":{"l9":{"l10":{"l11":{"l12":{"l13":{"l14":{"l15":{"l16":{"l17":{"l18":{"l19":{"l20":"deep_value_20"}}}}}}}}}}}}}}}}}}}}}}')),

--     -- Mixed array and object nesting
--     (5, 'mixed_nesting_10_levels', 10,
--         parse_json('{"a":[{"b":{"c":[{"d":{"e":[{"f":{"g":[{"h":{"i":"mixed_deep_10"}}]}}]}}]}}]}')),

--     -- Nested arrays
--     (6, 'nested_array_5_levels', 5,
--         parse_json('[[[[[42]]]]]'));

-- -- ========================================
-- -- Test 3: Numeric Boundaries
-- -- Test IDs: UNC-3.3.1 through UNC-3.3.12
-- -- ========================================
-- CREATE TABLE variant_boundary_numeric_test (
--     test_id INT,
--     test_label STRING,
--     numeric_type STRING,
--     variant_col VARIANT,
--     expected_value STRING
-- ) USING iceberg
-- TBLPROPERTIES (
--     'format-version' = '3',
--     'write.format.default' = 'parquet',
--     'engine.hive.enabled' = 'false'
-- );

-- INSERT INTO variant_boundary_numeric_test VALUES
--     -- INT boundaries (32-bit)
--     (1, 'int_min', 'INT', parse_json('-2147483648'), '-2147483648'),
--     (2, 'int_max', 'INT', parse_json('2147483647'), '2147483647'),
--     (3, 'int_zero', 'INT', parse_json('0'), '0'),
--     (4, 'int_negative_one', 'INT', parse_json('-1'), '-1'),

--     -- BIGINT boundaries (64-bit)
--     (5, 'bigint_min', 'BIGINT', parse_json('-9223372036854775808'), '-9223372036854775808'),
--     (6, 'bigint_max', 'BIGINT', parse_json('9223372036854775807'), '9223372036854775807'),

--     -- SMALLINT boundaries (16-bit: -32768 to 32767)
--     (7, 'smallint_min', 'SMALLINT', parse_json('-32768'), '-32768'),
--     (8, 'smallint_max', 'SMALLINT', parse_json('32767'), '32767'),

--     -- DOUBLE boundaries
--     (9, 'double_very_small', 'DOUBLE', parse_json('4.9E-324'), '4.9E-324'),
--     (10, 'double_very_large', 'DOUBLE', parse_json('1.7976931348623157E308'), '1.7976931348623157E308'),
--     (11, 'double_negative_large', 'DOUBLE', parse_json('-1.7976931348623157E308'), '-1.7976931348623157E308'),

--     -- Special double values (may not be supported by JSON)
--     (12, 'double_negative_zero', 'DOUBLE', parse_json('-0.0'), '-0.0'),
--     (13, 'double_positive_zero', 'DOUBLE', parse_json('0.0'), '0.0'),

--     -- DECIMAL boundaries
--     (14, 'decimal_max_precision_38_0', 'DECIMAL(38,0)',
--         parse_json('99999999999999999999999999999999999999'), '99999999999999999999999999999999999999'),
--     (15, 'decimal_high_scale_38_38', 'DECIMAL(38,38)',
--         parse_json('0.99999999999999999999999999999999999999'), '0.99999999999999999999999999999999999999'),
--     (16, 'decimal_zero', 'DECIMAL(10,2)', parse_json('0.00'), '0.00'),
--     (17, 'decimal_negative', 'DECIMAL(10,2)', parse_json('-12345.67'), '-12345.67'),

--     -- Edge cases
--     (18, 'one_plus_epsilon', 'DOUBLE', parse_json('1.0000000000000002'), '1.0000000000000002'),
--     (19, 'negative_one_minus_epsilon', 'DOUBLE', parse_json('-1.0000000000000002'), '-1.0000000000000002');

-- -- Sanity checks
-- SELECT 'variant_boundary_arrays_test' AS table_name, COUNT(*) AS row_count FROM variant_boundary_arrays_test;
-- SELECT 'variant_boundary_nesting_test' AS table_name, COUNT(*) AS row_count FROM variant_boundary_nesting_test;
-- SELECT 'variant_boundary_numeric_test' AS table_name, COUNT(*) AS row_count FROM variant_boundary_numeric_test;
